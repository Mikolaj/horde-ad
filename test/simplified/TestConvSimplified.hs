{-# LANGUAGE OverloadedLists #-}
{-# OPTIONS_GHC -fno-cse #-}
{-# OPTIONS_GHC -Wno-incomplete-uni-patterns #-}
-- | Tests of convolution and disparity cost volume defined using the build
-- operation of ranked tensors.
module TestConvSimplified (testTrees) where

import Prelude

import Control.Exception (assert)
import Data.Array.RankedS qualified as OR
import Data.IntMap.Strict qualified as IM
import Data.Vector.Generic qualified as V
import GHC.Exts (IsList (..))
import GHC.TypeLits (KnownNat)
import Test.Tasty
import Test.Tasty.HUnit hiding (assert)

import Data.Array.Nested qualified as Nested

import HordeAd
import HordeAd.Core.AstEnv
import HordeAd.Core.AstFreshId (resetVarCounter)
import HordeAd.Core.TensorAst
import HordeAd.Internal.BackendOX (RepN (..))
import HordeAd.Internal.OrthotopeOrphanInstances (FlipR (..))

import CrossTesting

testTrees :: [TestTree]
testTrees =
  [ testCase "KonstG0Rev" testKonstG0Rev
  , testCase "KonstG0Tiny1" testKonstG0Tiny1
  , testCase "KonstG0TinyS" testKonstG0TinyS
  , testCase "KonstG0TinyA" testKonstG0TinyA
  , testCase "KonstG0LittleA" testKonstG0LittleA
  , testCase "Replicate0RevLaborious" testReplicate0RevLaborious
  , testCase "Replicate0Tiny1Laborious" testReplicate0Tiny1Laborious
  , testCase "Replicate0TinySLaborious" testReplicate0TinySLaborious
  , testCase "Replicate0TinyALaborious" testReplicate0TinyALaborious
  , testCase "Replicate0LittleALaborious" testReplicate0LittleALaborious
  , testCase "Konst5LittleBLaborious" testKonst5LittleBLaborious
  , testCase "Konst5LittleCLaborious" testKonst5LittleCLaborious
  , testCase "Konst5BigBLaborious" testKonst5BigBLaborious
  , testCase "KonstNotBigBLaborious" testKonstNotBigBLaborious
  , testCase "Konst5BigCLaborious" testKonst5BigCLaborious
  , testCase "KonstNotBigCLaborious" testKonstNotBigCLaborious
  , testCase "Konst5LittleBLaborious128b" testKonst5LittleBLaborious128b
  , testCase "Konst5LittleCLaborious128b" testKonst5LittleCLaborious128b
  , testCase "Konst5BigBLaborious128b" testKonst5BigBLaborious128b
  , testCase "KonstNotBigBLaborious128b" testKonstNotBigBLaborious128b
  , testCase "Konst5BigCLaborious128b" testKonst5BigCLaborious128b
  , testCase "KonstNotBigCLaborious128b" testKonstNotBigCLaborious128b
  , testCase "Konst5LittleBLaborious128c" testKonst5LittleBLaborious128c
  , testCase "Konst5LittleCLaborious128c" testKonst5LittleCLaborious128c
  , testCase "Konst5BigBLaborious128c" testKonst5BigBLaborious128c
  , testCase "KonstNotBigBLaborious128c" testKonstNotBigBLaborious128c
  , testCase "Konst5BigCLaborious128c" testKonst5BigCLaborious128c
  , testCase "KonstNotBigCLaborious128c" testKonstNotBigCLaborious128c
  , testCase "Konst5LittleBLaborious128bc" testKonst5LittleBLaborious128bc
  , testCase "Konst5LittleCLaborious128bc" testKonst5LittleCLaborious128bc
  , testCase "Konst5BigBLaborious128bc" testKonst5BigBLaborious128bc
  , testCase "KonstNotBigBLaborious128cb" testKonstNotBigBLaborious128cb
  , testCase "Konst5BigCLaborious128cb" testKonst5BigCLaborious128cb
  , testCase "KonstNotBigCLaborious128cb" testKonstNotBigCLaborious128cb
  , testCase "disparityKonst" test_disparityKonst
  , testCase "disparityKonst2" test_disparityKonst2
  , testCase "disparitySmall" test_disparitySmall
  , testCase "Conv2dUnpadded2PP" testConv2dUnpadded2PP
  , testCase "Conv2dUnpadded3PP" testConv2dUnpadded3PP
  ]

-- The examples reproduce and transformed in this file are borrowed
-- from https://github.com/benl23x5/adops.
-- Here it's defined using ranked tensors with sized indexes.

-- Test comments are currently outdated. The first implementation
-- is currently correct only by chance (and this may change).
-- The "laborious" implementation is the solid one.

-- | Unpadded full convolution,
--   where the output size is the same as the input size.
conv2d
  :: (ADReady target, GoodScalar r)
  => target (TKR r 4) -> target (TKR r 4) -> target (TKR r 4)
conv2d arrK arrA =
  let [nImgs, nCinpA, nAh, nAw] = rshape arrA
      [nCoutK, nCinpK, nKh, nKw] = rshape arrK
      nCinp = assert (nCinpA == nCinpK) nCinpA
      shB = [nImgs, nCoutK, nAh, nAw]
      shK1 = [1, nCinp, nKh, nKw]
  in rbuild shB $ \case
    [iImg, iCout, iBh, iBw] ->
      let arrAt = slicezF shK1 arrA [iImg, 0, iBh, iBw]
          arrKt = slicezF shK1 arrK [iCout, 0, 0, 0]
      in rdot0 arrAt arrKt
    _ -> error "conv2d: impossible pattern needlessly required"

-- | Slice a section out of a tensor,
--   given a base offset and shape of the section.
--
--   If the slice extends out side the source array then the corresponding
--   elements are set to zero.
slicezF :: forall target n r. (ADReady target, GoodScalar r, KnownNat n)
        => IShR n -> target (TKR r n) -> IndexOf target n -> target (TKR r n)
slicezF shOut d ixBase =
  rbuild shOut $ \ixResult ->
    rindex @target @r @n @0 d (zipWith_Index (+) ixBase ixResult)
      -- rindex0 would not require a single type application here

conv2d1
  :: (ADReady target, GoodScalar r, Differentiable r)
  => target (TKR r 4) -> target (TKR r 4)
conv2d1 = conv2d $ rconst $ Nested.rfromListPrimLinear (fromList [1, 1, 1, 1]) [-0.2]

conv2dA
  :: (ADReady target, GoodScalar r, Differentiable r)
  => target (TKR r 4) -> target (TKR r 4)
conv2dA = conv2d $ rconst $ Nested.rfromListPrimLinear (fromList [1, 2, 1, 1]) [-0.2, 25.0003]

conv2dB
  :: (ADReady target, GoodScalar r, Differentiable r)
  => target (TKR r 4) -> target (TKR r 4)
conv2dB = conv2d $ rconst $ runFlipR $ unRepN t16b

testKonstG0Rev :: Assertion
testKonstG0Rev =
  assertEqualUpToEpsilon1 1e-4
    (OR.fromList [2, 2, 2, 2] [18.1,29.1,32.1,40.1,582932.0,582934.99432,582597.1,582625.8943200001,18.1,29.1,32.1,40.1,582932.0,582934.99432,582597.1,582625.8943200001])
    (rev @_ @(TKR Double 4) conv2dB (rzero [2, 2, 2, 2]))

testKonstG0Tiny1 :: Assertion
testKonstG0Tiny1 =
  assertEqualUpToEpsilon' 1e-10
    (OR.fromList [1, 1, 1, 1] [-0.2])
    (rev' @Double @4 conv2d1 (FlipR $ Nested.rtoOrthotope $ runFlipR $ unRepN $ rzero [1, 1, 1, 1]))

testKonstG0TinyS :: Assertion
testKonstG0TinyS =
  assertEqualUpToEpsilon' 1e-10
    (OR.fromList [1, 1, 1, 1] [582665.99432])
    (rev' @Double @4
          (conv2d $ rconst $ runFlipR $ unRepN $ rreplicate0N [1, 1, 1, 1] (rsum0 t16b))
          (FlipR $ OR.fromList [1, 1, 1, 1] [0]))

testKonstG0TinyA :: Assertion
testKonstG0TinyA =
  assertEqualUpToEpsilon' 1e-10
    (OR.fromList [1, 2, 1, 1] [-0.2,25.0003])
    (rev' @Double @4 conv2dA (FlipR $ Nested.rtoOrthotope $ runFlipR $ unRepN $ rzero [1, 2, 1, 1]))

testKonstG0LittleA :: Assertion
testKonstG0LittleA =
  assertEqualUpToEpsilon' 1e-10
    (OR.fromList [2, 2, 2, 2] [-0.2,-0.2,-0.2,-0.2,25.0003,25.0003,25.0003,25.0003,-0.2,-0.2,-0.2,-0.2,25.0003,25.0003,25.0003,25.0003])
    (rev' @Double @4 conv2dA (FlipR $ Nested.rtoOrthotope $ runFlipR $ unRepN $ rzero [2, 2, 2, 2]))


-- * A laborious version

-- The implementation is in HordeAd.External.CommonRankedOps.
--
-- Some tests are copied from above and the required test results are
-- the same.

conv2d1Laborious
  :: (ADReady target, GoodScalar r, Differentiable r)
  => target (TKR r 4) -> target (TKR r 4)
conv2d1Laborious = conv2dUnpadded $ rconst $ Nested.rfromListPrimLinear (fromList [1, 1, 1, 1]) [-0.2]

conv2dALaborious
  :: (ADReady target, GoodScalar r, Differentiable r)
  => target (TKR r 4) -> target (TKR r 4)
conv2dALaborious =
  conv2dUnpadded $ rconst $ Nested.rfromListPrimLinear (fromList [1, 2, 1, 1]) [-0.2, 25.0003]

conv2dBLaborious
  :: (ADReady target, GoodScalar r, Differentiable r)
  => target (TKR r 4) -> target (TKR r 4)
conv2dBLaborious = conv2dUnpadded $ rconst $ runFlipR $ unRepN t16b

conv2dCLaborious
  :: (ADReady target, GoodScalar r, Differentiable r)
  => target (TKR r 4) -> target (TKR r 4)
conv2dCLaborious = flip conv2dUnpadded $ rconst $ runFlipR $ unRepN t16b

conv2dBLaborious128b
  :: (ADReady target, GoodScalar r, Differentiable r)
  => target (TKR r 4) -> target (TKR r 4)
conv2dBLaborious128b = conv2dUnpadded $ rconst $ Nested.rfromOrthotope SNat $ runFlipR t128b

conv2dCLaborious128b
  :: (ADReady target, GoodScalar r, Differentiable r)
  => target (TKR r 4) -> target (TKR r 4)
conv2dCLaborious128b = flip conv2dUnpadded $ rconst $ Nested.rfromOrthotope SNat $ runFlipR t128b

conv2dBLaborious128c
  :: (ADReady target, GoodScalar r, Differentiable r)
  => target (TKR r 4) -> target (TKR r 4)
conv2dBLaborious128c = conv2dUnpadded $ rconst $ Nested.rfromOrthotope SNat $ runFlipR t128c

conv2dCLaborious128c
  :: (ADReady target, GoodScalar r, Differentiable r)
  => target (TKR r 4) -> target (TKR r 4)
conv2dCLaborious128c = flip conv2dUnpadded $ rconst $ Nested.rfromOrthotope SNat $ runFlipR t128c

testReplicate0RevLaborious :: Assertion
testReplicate0RevLaborious =
  assertEqualUpToEpsilon1 1e-4
    (OR.fromList [2, 2, 2, 2] [18.1,29.1,32.1,40.1,582932.0,582934.99432,582597.1,582625.8943200001,18.1,29.1,32.1,40.1,582932.0,582934.99432,582597.1,582625.8943200001])
    (rev @_ @(TKR Double 4) conv2dBLaborious (rzero [2, 2, 2, 2]))

testReplicate0Tiny1Laborious :: Assertion
testReplicate0Tiny1Laborious =
  assertEqualUpToEpsilon' 1e-10
    (OR.fromList [1, 1, 1, 1] [-0.2])
    (rev' @Double @4 conv2d1Laborious (FlipR $ Nested.rtoOrthotope $ runFlipR $ unRepN $ rzero [1, 1, 1, 1]))

testReplicate0TinySLaborious :: Assertion
testReplicate0TinySLaborious =
  assertEqualUpToEpsilon' 1e-10
    (OR.fromList [1, 1, 1, 1] [582665.99432])
    (rev' @Double @4
          (conv2dUnpadded $ rconst $ runFlipR $ unRepN $ rreplicate0N [1, 1, 1, 1] (rsum0 t16b))
          (FlipR $ OR.fromList [1, 1, 1, 1] [0]))

testReplicate0TinyALaborious :: Assertion
testReplicate0TinyALaborious =
  assertEqualUpToEpsilon' 1e-10
    (OR.fromList [1, 2, 1, 1] [-0.2,25.0003])
    (rev' @Double @4 conv2dALaborious (FlipR $ Nested.rtoOrthotope $ runFlipR $ unRepN $ rzero [1, 2, 1, 1]))

testReplicate0LittleALaborious :: Assertion
testReplicate0LittleALaborious =
  assertEqualUpToEpsilon' 1e-10
    (OR.fromList [2, 2, 2, 2] [-0.2,-0.2,-0.2,-0.2,25.0003,25.0003,25.0003,25.0003,-0.2,-0.2,-0.2,-0.2,25.0003,25.0003,25.0003,25.0003])
    (rev' @Double @4 conv2dALaborious (FlipR $ Nested.rtoOrthotope $ runFlipR $ unRepN $ rzero [2, 2, 2, 2]))

-- with data t16

testKonst5LittleBLaborious :: Assertion
testKonst5LittleBLaborious =
  assertEqualUpToEpsilon' 1e-8
    (OR.fromList [2, 2, 2, 2] [18.1,29.1,32.1,40.1,582932.0,582934.99432,582597.1,582625.8943200001,18.1,29.1,32.1,40.1,582932.0,582934.99432,582597.1,582625.8943200001])
    (rev' @Double @4 conv2dBLaborious (FlipR $ Nested.rtoOrthotope $ runFlipR $ unRepN $ rreplicate0N [2, 2, 2, 2] 5))

testKonst5LittleCLaborious :: Assertion
testKonst5LittleCLaborious =
  assertEqualUpToEpsilon' 1e-8
    (OR.fromList [2, 2, 2, 2] [40.1,8.0,11.0,-3.0,582625.89432,28.79432,-309.09999999999997,25.8,40.1,8.0,11.0,-3.0,582625.89432,28.79432,-309.09999999999997,25.8])
    (rev' @Double @4 conv2dCLaborious (FlipR $ Nested.rtoOrthotope $ runFlipR $ unRepN $ rreplicate0N [2, 2, 2, 2] 5))

testKonst5BigBLaborious :: Assertion
testKonst5BigBLaborious =
  assertEqualUpToEpsilon' 1e-8
    (OR.fromList [3, 2, 4, 2] [18.1,29.1,32.1,40.1,32.1,40.1,32.1,40.1,582932.0,582934.99432,582597.1,582625.8943200001,582597.1,582625.8943200001,582597.1,582625.8943200001,18.1,29.1,32.1,40.1,32.1,40.1,32.1,40.1,582932.0,582934.99432,582597.1,582625.8943200001,582597.1,582625.8943200001,582597.1,582625.8943200001,18.1,29.1,32.1,40.1,32.1,40.1,32.1,40.1,582932.0,582934.99432,582597.1,582625.8943200001,582597.1,582625.8943200001,582597.1,582625.8943200001])
    (rev' @Double @4 conv2dBLaborious (FlipR $ Nested.rtoOrthotope $ runFlipR $ unRepN $ rreplicate0N [3, 2, 4, 2] 5))

-- The gradient is the same as above, because one argument is the same
-- and convolution is linear.
testKonstNotBigBLaborious :: Assertion
testKonstNotBigBLaborious =
  assertEqualUpToEpsilon' 1e-8
    (OR.fromList [3, 2, 4, 2] [18.1,29.1,32.1,40.1,32.1,40.1,32.1,40.1,582932.0,582934.99432,582597.1,582625.8943200001,582597.1,582625.8943200001,582597.1,582625.8943200001,18.1,29.1,32.1,40.1,32.1,40.1,32.1,40.1,582932.0,582934.99432,582597.1,582625.8943200001,582597.1,582625.8943200001,582597.1,582625.8943200001,18.1,29.1,32.1,40.1,32.1,40.1,32.1,40.1,582932.0,582934.99432,582597.1,582625.8943200001,582597.1,582625.8943200001,582597.1,582625.8943200001])
    (rev' @Double @4 conv2dBLaborious
          (FlipR $ Nested.rtoOrthotope $ runFlipR $ unRepN $ rfromList0N [3, 2, 4, 2] (map rscalar [37, 36 .. -10])))

testKonst5BigCLaborious :: Assertion
testKonst5BigCLaborious =
  assertEqualUpToEpsilon' 1e-8
    (OR.fromList [3, 2, 4, 2] [40.1,8.0,11.0,-3.0,0.0,0.0,0.0,0.0,582625.8943200001,28.794320000000003,-309.09999999999997,25.8,0.0,0.0,0.0,0.0,40.1,8.0,11.0,-3.0,0.0,0.0,0.0,0.0,582625.8943200001,28.794320000000003,-309.09999999999997,25.8,0.0,0.0,0.0,0.0,40.1,8.0,11.0,-3.0,0.0,0.0,0.0,0.0,582625.8943200001,28.794320000000003,-309.09999999999997,25.8,0.0,0.0,0.0,0.0])
    (rev' @Double @4 conv2dCLaborious (FlipR $ Nested.rtoOrthotope $ runFlipR $ unRepN $ rreplicate0N [3, 2, 4, 2] 5))

-- The gradient is the same as above, because one argument is the same
-- and convolution is linear.
testKonstNotBigCLaborious :: Assertion
testKonstNotBigCLaborious =
  assertEqualUpToEpsilon' 1e-8
    (OR.fromList [3, 2, 4, 2] [40.1,8.0,11.0,-3.0,0.0,0.0,0.0,0.0,582625.8943200001,28.794320000000003,-309.09999999999997,25.8,0.0,0.0,0.0,0.0,40.1,8.0,11.0,-3.0,0.0,0.0,0.0,0.0,582625.8943200001,28.794320000000003,-309.09999999999997,25.8,0.0,0.0,0.0,0.0,40.1,8.0,11.0,-3.0,0.0,0.0,0.0,0.0,582625.8943200001,28.794320000000003,-309.09999999999997,25.8,0.0,0.0,0.0,0.0])
    (rev' @Double @4 conv2dCLaborious
          (FlipR $ Nested.rtoOrthotope $ runFlipR $ unRepN $ rfromList0N [3, 2, 4, 2] (map rscalar [37, 36 .. -10])))

-- with data t128b

testKonst5LittleBLaborious128b :: Assertion
testKonst5LittleBLaborious128b =
  assertEqualUpToEpsilon' 1e-8
    (OR.fromList [2, 2, 2, 2] [112.3003,251.5006,209.49462,482.69492000000014,3.000000000000032,65.90000000000003,164.10000000000002,365.89432000010004,112.3003,251.5006,209.49462,482.69492000000014,3.000000000000032,65.90000000000003,164.10000000000002,365.89432000010004])
    (rev' @Double @4 conv2dBLaborious128b (FlipR $ Nested.rtoOrthotope $ runFlipR $ unRepN $ rreplicate0N [2, 2, 2, 2] 5))

testKonst5LittleCLaborious128b :: Assertion
testKonst5LittleCLaborious128b =
  assertEqualUpToEpsilon' 1e-8
    (OR.fromList [2, 2, 2, 2] [1627.8210700004993,1571.2321300004994,1132.9261600005002,1188.6375200005,2725.0393200008984,1831.7390200008983,2551.139320000898,1660.8390200008987,1627.8210700004993,1571.2321300004994,1132.9261600005002,1188.6375200005,2725.0393200008984,1831.7390200008983,2551.139320000898,1660.8390200008987])
    (rev' @Double @4 conv2dCLaborious128b (FlipR $ Nested.rtoOrthotope $ runFlipR $ unRepN $ rreplicate0N [2, 2, 2, 2] 5))

testKonst5BigBLaborious128b :: Assertion
testKonst5BigBLaborious128b =
  assertEqualUpToEpsilon' 1e-8
    (OR.fromList [3, 2, 4, 2] [112.3003,251.5006,209.49462,482.69492000000014,229.49462000000003,610.5892400000002,56.58894000000004,580.6778800001001,3.000000000000032,65.90000000000003,164.10000000000002,365.89432000010004,667.2003000000001,1060.8778800002,893.3003,1465.6665200003993,112.3003,251.5006,209.49462,482.69492000000014,229.49462000000003,610.5892400000002,56.58894000000004,580.6778800001001,3.000000000000032,65.90000000000003,164.10000000000002,365.89432000010004,667.2003000000001,1060.8778800002,893.3003,1465.6665200003993,112.3003,251.5006,209.49462,482.69492000000014,229.49462000000003,610.5892400000002,56.58894000000004,580.6778800001001,3.000000000000032,65.90000000000003,164.10000000000002,365.89432000010004,667.2003000000001,1060.8778800002,893.3003,1465.6665200003993])
    (rev' @Double @4 conv2dBLaborious128b (FlipR $ Nested.rtoOrthotope $ runFlipR $ unRepN $ rreplicate0N [3, 2, 4, 2] 5))

-- The gradient is the same as above, because one argument is the same
-- and convolution is linear.
testKonstNotBigBLaborious128b :: Assertion
testKonstNotBigBLaborious128b =
  assertEqualUpToEpsilon' 1e-8
    (OR.fromList [3, 2, 4, 2] [112.3003,251.5006,209.49462,482.69492000000014,229.49462000000003,610.5892400000002,56.58894000000004,580.6778800001001,3.000000000000032,65.90000000000003,164.10000000000002,365.89432000010004,667.2003000000001,1060.8778800002,893.3003,1465.6665200003993,112.3003,251.5006,209.49462,482.69492000000014,229.49462000000003,610.5892400000002,56.58894000000004,580.6778800001001,3.000000000000032,65.90000000000003,164.10000000000002,365.89432000010004,667.2003000000001,1060.8778800002,893.3003,1465.6665200003993,112.3003,251.5006,209.49462,482.69492000000014,229.49462000000003,610.5892400000002,56.58894000000004,580.6778800001001,3.000000000000032,65.90000000000003,164.10000000000002,365.89432000010004,667.2003000000001,1060.8778800002,893.3003,1465.6665200003993])
    (rev' @Double @4 conv2dBLaborious128b
          (FlipR $ Nested.rtoOrthotope $ runFlipR $ unRepN $ rfromList0N [3, 2, 4, 2] (map rscalar [37, 36 .. -10])))

testKonst5BigCLaborious128b :: Assertion
testKonst5BigCLaborious128b =
  assertEqualUpToEpsilon' 1e-8
    (OR.fromList [3, 2, 4, 2] [1627.8210700004993,1571.2321300004994,1132.9261600005002,1188.6375200005,675.7488800003999,828.6545600004001,215.6659200003,388.5716000003,2725.0393200008984,1831.7390200008983,2551.139320000898,1660.8390200008987,1903.750080000699,1174.5497800006997,854.9778800004001,628.8778800004001,1627.8210700004993,1571.2321300004994,1132.9261600005002,1188.6375200005,675.7488800003999,828.6545600004001,215.6659200003,388.5716000003,2725.0393200008984,1831.7390200008983,2551.139320000898,1660.8390200008987,1903.750080000699,1174.5497800006997,854.9778800004001,628.8778800004001,1627.8210700004993,1571.2321300004994,1132.9261600005002,1188.6375200005,675.7488800003999,828.6545600004001,215.6659200003,388.5716000003,2725.0393200008984,1831.7390200008983,2551.139320000898,1660.8390200008987,1903.750080000699,1174.5497800006997,854.9778800004001,628.8778800004001])
    (rev' @Double @4 conv2dCLaborious128b (FlipR $ Nested.rtoOrthotope $ runFlipR $ unRepN $ rreplicate0N [3, 2, 4, 2] 5))

-- The gradient is the same as above, because one argument is the same
-- and convolution is linear.
testKonstNotBigCLaborious128b :: Assertion
testKonstNotBigCLaborious128b =
  assertEqualUpToEpsilon' 1e-8
    (OR.fromList [3, 2, 4, 2] [1627.8210700004993,1571.2321300004994,1132.9261600005002,1188.6375200005,675.7488800003999,828.6545600004001,215.6659200003,388.5716000003,2725.0393200008984,1831.7390200008983,2551.139320000898,1660.8390200008987,1903.750080000699,1174.5497800006997,854.9778800004001,628.8778800004001,1627.8210700004993,1571.2321300004994,1132.9261600005002,1188.6375200005,675.7488800003999,828.6545600004001,215.6659200003,388.5716000003,2725.0393200008984,1831.7390200008983,2551.139320000898,1660.8390200008987,1903.750080000699,1174.5497800006997,854.9778800004001,628.8778800004001,1627.8210700004993,1571.2321300004994,1132.9261600005002,1188.6375200005,675.7488800003999,828.6545600004001,215.6659200003,388.5716000003,2725.0393200008984,1831.7390200008983,2551.139320000898,1660.8390200008987,1903.750080000699,1174.5497800006997,854.9778800004001,628.8778800004001])
    (rev' @Double @4 conv2dCLaborious128b
          (FlipR $ Nested.rtoOrthotope $ runFlipR $ unRepN $ rfromList0N [3, 2, 4, 2] (map rscalar [37, 36 .. -10])))

-- with data t128c

testKonst5LittleBLaborious128c :: Assertion
testKonst5LittleBLaborious128c =
  assertEqualUpToEpsilon' 1e-8
    (OR.fromList [2, 2, 2, 2] [54.100300000000004,111.20060000000001,119.09462,270.29492000000005,58.2,140.3,90.4,212.4,54.100300000000004,111.20060000000001,119.09462,270.29492000000005,58.2,140.3,90.4,212.4])
    (rev' @Double @4 conv2dBLaborious128c (FlipR $ Nested.rtoOrthotope $ runFlipR $ unRepN $ rreplicate0N [2, 2, 2, 2] 5))

testKonst5LittleCLaborious128c :: Assertion
testKonst5LittleCLaborious128c =
  assertEqualUpToEpsilon' 1e-8
    (OR.fromList [2, 2, 2, 2] [2640.8154000007976,1836.3264600007988,2412.414800000798,1662.026160000799,1712.044990000598,1566.644690000599,1445.5506800005985,1358.3503800005992,2640.8154000007976,1836.3264600007988,2412.414800000798,1662.026160000799,1712.044990000598,1566.644690000599,1445.5506800005985,1358.3503800005992])
    (rev' @Double @4 conv2dCLaborious128c (FlipR $ Nested.rtoOrthotope $ runFlipR $ unRepN $ rreplicate0N [2, 2, 2, 2] 5))

testKonst5BigBLaborious128c :: Assertion
testKonst5BigBLaborious128c =
  assertEqualUpToEpsilon' 1e-8
    (OR.fromList [3, 2, 4, 2] [54.100300000000004,111.20060000000001,119.09462,270.29492000000005,109.09462000000002,318.19492,174.08894000000004,477.28924000000006,58.2,140.3,90.4,212.4,120.4,292.39432000000005,-117.5,103.38864000010005,54.100300000000004,111.20060000000001,119.09462,270.29492000000005,109.09462000000002,318.19492,174.08894000000004,477.28924000000006,58.2,140.3,90.4,212.4,120.4,292.39432000000005,-117.5,103.38864000010005,54.100300000000004,111.20060000000001,119.09462,270.29492000000005,109.09462000000002,318.19492,174.08894000000004,477.28924000000006,58.2,140.3,90.4,212.4,120.4,292.39432000000005,-117.5,103.38864000010005])
    (rev' @Double @4 conv2dBLaborious128c (FlipR $ Nested.rtoOrthotope $ runFlipR $ unRepN $ rreplicate0N [3, 2, 4, 2] 5))

-- The gradient is the same as above, because one argument is the same
-- and convolution is linear.
testKonstNotBigBLaborious128c :: Assertion
testKonstNotBigBLaborious128c =
  assertEqualUpToEpsilon' 1e-8
    (OR.fromList [3, 2, 4, 2] [54.100300000000004,111.20060000000001,119.09462,270.29492000000005,109.09462000000002,318.19492,174.08894000000004,477.28924000000006,58.2,140.3,90.4,212.4,120.4,292.39432000000005,-117.5,103.38864000010005,54.100300000000004,111.20060000000001,119.09462,270.29492000000005,109.09462000000002,318.19492,174.08894000000004,477.28924000000006,58.2,140.3,90.4,212.4,120.4,292.39432000000005,-117.5,103.38864000010005,54.100300000000004,111.20060000000001,119.09462,270.29492000000005,109.09462000000002,318.19492,174.08894000000004,477.28924000000006,58.2,140.3,90.4,212.4,120.4,292.39432000000005,-117.5,103.38864000010005])
    (rev' @Double @4 conv2dBLaborious128c
          (FlipR $ Nested.rtoOrthotope $ runFlipR $ unRepN $ rfromList0N [3, 2, 4, 2] (map rscalar [37, 36 .. -10])))

testKonst5BigCLaborious128c :: Assertion
testKonst5BigCLaborious128c =
  assertEqualUpToEpsilon' 1e-8
    (OR.fromList [3, 2, 4, 2] [2640.8154000007976,1836.3264600007988,2412.414800000798,1662.026160000799,2121.6375200006987,1436.2432000006995,1953.5375200006988,1258.1432000006998,1712.044990000598,1566.644690000599,1445.5506800005985,1358.3503800005992,1279.150680000599,1224.1503800005996,987.1677200004992,962.1674200005002,2640.8154000007976,1836.3264600007988,2412.414800000798,1662.026160000799,2121.6375200006987,1436.2432000006995,1953.5375200006988,1258.1432000006998,1712.044990000598,1566.644690000599,1445.5506800005985,1358.3503800005992,1279.150680000599,1224.1503800005996,987.1677200004992,962.1674200005002,2640.8154000007976,1836.3264600007988,2412.414800000798,1662.026160000799,2121.6375200006987,1436.2432000006995,1953.5375200006988,1258.1432000006998,1712.044990000598,1566.644690000599,1445.5506800005985,1358.3503800005992,1279.150680000599,1224.1503800005996,987.1677200004992,962.1674200005002])
    (rev' @Double @4 conv2dCLaborious128c (FlipR $ Nested.rtoOrthotope $ runFlipR $ unRepN $ rreplicate0N [3, 2, 4, 2] 5))

-- The gradient is the same as above, because one argument is the same
-- and convolution is linear.
testKonstNotBigCLaborious128c :: Assertion
testKonstNotBigCLaborious128c =
  assertEqualUpToEpsilon' 1e-8
    (OR.fromList [3, 2, 4, 2] [2640.8154000007976,1836.3264600007988,2412.414800000798,1662.026160000799,2121.6375200006987,1436.2432000006995,1953.5375200006988,1258.1432000006998,1712.044990000598,1566.644690000599,1445.5506800005985,1358.3503800005992,1279.150680000599,1224.1503800005996,987.1677200004992,962.1674200005002,2640.8154000007976,1836.3264600007988,2412.414800000798,1662.026160000799,2121.6375200006987,1436.2432000006995,1953.5375200006988,1258.1432000006998,1712.044990000598,1566.644690000599,1445.5506800005985,1358.3503800005992,1279.150680000599,1224.1503800005996,987.1677200004992,962.1674200005002,2640.8154000007976,1836.3264600007988,2412.414800000798,1662.026160000799,2121.6375200006987,1436.2432000006995,1953.5375200006988,1258.1432000006998,1712.044990000598,1566.644690000599,1445.5506800005985,1358.3503800005992,1279.150680000599,1224.1503800005996,987.1677200004992,962.1674200005002])
    (rev' @Double @4 conv2dCLaborious128c
          (FlipR $ Nested.rtoOrthotope $ runFlipR $ unRepN $ rfromList0N [3, 2, 4, 2] (map rscalar [37, 36 .. -10])))

-- with data t128b and t128c

testKonst5LittleBLaborious128bc :: Assertion
testKonst5LittleBLaborious128bc =
  assertEqualUpToEpsilonShort 1e-8
    (OR.fromList [2,2,8,4] [112.3003,251.5006,417.79492000000005,494.89491000000015,209.49462,482.69492000000014,778.9778800001002,952.0721900001002,229.49462000000003,610.5892400000002,1113.1722000001,1412.1551500001997,56.58894000000004,580.6778800001001,1234.1494800003,1627.8210700004993,56.58894000000004,580.6778800001001,1234.1494800003,1627.8210700004993,56.58894000000004,580.6778800001001,1234.1494800003,1627.8210700004993,56.58894000000004,580.6778800001001,1234.1494800003,1627.8210700004993,56.58894000000004,580.6778800001001,1234.1494800003,1627.8210700004993,3.000000000000032,65.90000000000003,106.90000000000003,173.90000000000006,164.10000000000002,365.89432000010004,593.1946200001,821.2892400002004,667.2003000000001,1060.8778800002,1500.2781800001994,1870.0614400004986,893.3003,1465.6665200003993,2156.3671200003987,2725.039320000898,893.3003,1465.6665200003993,2156.3671200003987,2725.039320000898,893.3003,1465.6665200003993,2156.3671200003987,2725.039320000898,893.3003,1465.6665200003993,2156.3671200003987,2725.039320000898,893.3003,1465.6665200003993,2156.3671200003987,2725.039320000898,112.3003,251.5006,417.79492000000005,494.89491000000015,209.49462,482.69492000000014,778.9778800001002,952.0721900001002,229.49462000000003,610.5892400000002,1113.1722000001,1412.1551500001997,56.58894000000004,580.6778800001001,1234.1494800003,1627.8210700004993,56.58894000000004,580.6778800001001,1234.1494800003,1627.8210700004993,56.58894000000004,580.6778800001001,1234.1494800003,1627.8210700004993,56.58894000000004,580.6778800001001,1234.1494800003,1627.8210700004993,56.58894000000004,580.6778800001001,1234.1494800003,1627.8210700004993,3.000000000000032,65.90000000000003,106.90000000000003,173.90000000000006,164.10000000000002,365.89432000010004,593.1946200001,821.2892400002004,667.2003000000001,1060.8778800002,1500.2781800001994,1870.0614400004986,893.3003,1465.6665200003993,2156.3671200003987,2725.039320000898,893.3003,1465.6665200003993,2156.3671200003987,2725.039320000898,893.3003,1465.6665200003993,2156.3671200003987,2725.039320000898,893.3003,1465.6665200003993,2156.3671200003987,2725.039320000898,893.3003,1465.6665200003993,2156.3671200003987,2725.039320000898])
    (rev' @Double @4 conv2dBLaborious128b t128c)

testKonst5LittleCLaborious128bc :: Assertion
testKonst5LittleCLaborious128bc =
  assertEqualUpToEpsilonShort 1e-8
    (OR.fromList [2,2,8,4] [1627.8210700004993,1571.2321300004994,1047.1431900004002,393.6715900002,1132.9261600005002,1188.6375200005,803.7488800004002,316.57160000019996,675.7488800003999,828.6545600004001,577.7659200003001,220.57728000019998,215.6659200003,388.5716000003,245.5772800002,94.68864000010001,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,2725.0393200008984,1831.7390200008983,1259.3728000004999,568.6722000005001,2551.139320000898,1660.8390200008987,1151.3728000005,501.6722000005,1903.750080000699,1174.5497800006997,803.9778800004001,340.5775800004001,854.9778800004001,628.8778800004001,450.1892400002,198.8889400002,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1627.8210700004993,1571.2321300004994,1047.1431900004002,393.6715900002,1132.9261600005002,1188.6375200005,803.7488800004002,316.57160000019996,675.7488800003999,828.6545600004001,577.7659200003001,220.57728000019998,215.6659200003,388.5716000003,245.5772800002,94.68864000010001,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,2725.0393200008984,1831.7390200008983,1259.3728000004999,568.6722000005001,2551.139320000898,1660.8390200008987,1151.3728000005,501.6722000005,1903.750080000699,1174.5497800006997,803.9778800004001,340.5775800004001,854.9778800004001,628.8778800004001,450.1892400002,198.8889400002,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0])
    (rev' @Double @4 conv2dCLaborious128b t128c)

testKonst5BigBLaborious128bc :: Assertion
testKonst5BigBLaborious128bc =
  assertEqualUpToEpsilonShort 1e-8
    (OR.fromList [2,2,8,4] [112.3003,251.5006,417.79492000000005,494.89491000000015,209.49462,482.69492000000014,778.9778800001002,952.0721900001002,229.49462000000003,610.5892400000002,1113.1722000001,1412.1551500001997,56.58894000000004,580.6778800001001,1234.1494800003,1627.8210700004993,56.58894000000004,580.6778800001001,1234.1494800003,1627.8210700004993,56.58894000000004,580.6778800001001,1234.1494800003,1627.8210700004993,56.58894000000004,580.6778800001001,1234.1494800003,1627.8210700004993,56.58894000000004,580.6778800001001,1234.1494800003,1627.8210700004993,3.000000000000032,65.90000000000003,106.90000000000003,173.90000000000006,164.10000000000002,365.89432000010004,593.1946200001,821.2892400002004,667.2003000000001,1060.8778800002,1500.2781800001994,1870.0614400004986,893.3003,1465.6665200003993,2156.3671200003987,2725.039320000898,893.3003,1465.6665200003993,2156.3671200003987,2725.039320000898,893.3003,1465.6665200003993,2156.3671200003987,2725.039320000898,893.3003,1465.6665200003993,2156.3671200003987,2725.039320000898,893.3003,1465.6665200003993,2156.3671200003987,2725.039320000898,112.3003,251.5006,417.79492000000005,494.89491000000015,209.49462,482.69492000000014,778.9778800001002,952.0721900001002,229.49462000000003,610.5892400000002,1113.1722000001,1412.1551500001997,56.58894000000004,580.6778800001001,1234.1494800003,1627.8210700004993,56.58894000000004,580.6778800001001,1234.1494800003,1627.8210700004993,56.58894000000004,580.6778800001001,1234.1494800003,1627.8210700004993,56.58894000000004,580.6778800001001,1234.1494800003,1627.8210700004993,56.58894000000004,580.6778800001001,1234.1494800003,1627.8210700004993,3.000000000000032,65.90000000000003,106.90000000000003,173.90000000000006,164.10000000000002,365.89432000010004,593.1946200001,821.2892400002004,667.2003000000001,1060.8778800002,1500.2781800001994,1870.0614400004986,893.3003,1465.6665200003993,2156.3671200003987,2725.039320000898,893.3003,1465.6665200003993,2156.3671200003987,2725.039320000898,893.3003,1465.6665200003993,2156.3671200003987,2725.039320000898,893.3003,1465.6665200003993,2156.3671200003987,2725.039320000898,893.3003,1465.6665200003993,2156.3671200003987,2725.039320000898])
    (rev' @Double @4 conv2dBLaborious128b t128c)

-- The gradient is the same as above, because one argument is the same
-- and convolution is linear.
testKonstNotBigBLaborious128cb :: Assertion
testKonstNotBigBLaborious128cb =
  assertEqualUpToEpsilonShort 1e-8
    (OR.fromList [4,2,4,4] [54.100300000000004,111.20060000000001,191.4006,228.4006,119.09462,270.29492000000005,435.28356000009995,519.1778800001,109.09462000000002,318.19492,563.3835600001,687.2778800001003,174.08894000000004,477.28924000000006,774.2665200002001,931.9551600002003,58.2,140.3,226.39432,266.49431000000004,90.4,212.4,343.69432000000006,432.89431000000013,120.4,292.39432000000005,549.78864,724.8772700001001,-117.5,103.38864000010005,459.88296000009996,695.8659100003002,54.100300000000004,111.20060000000001,191.4006,228.4006,119.09462,270.29492000000005,435.28356000009995,519.1778800001,109.09462000000002,318.19492,563.3835600001,687.2778800001003,174.08894000000004,477.28924000000006,774.2665200002001,931.9551600002003,58.2,140.3,226.39432,266.49431000000004,90.4,212.4,343.69432000000006,432.89431000000013,120.4,292.39432000000005,549.78864,724.8772700001001,-117.5,103.38864000010005,459.88296000009996,695.8659100003002,54.100300000000004,111.20060000000001,191.4006,228.4006,119.09462,270.29492000000005,435.28356000009995,519.1778800001,109.09462000000002,318.19492,563.3835600001,687.2778800001003,174.08894000000004,477.28924000000006,774.2665200002001,931.9551600002003,58.2,140.3,226.39432,266.49431000000004,90.4,212.4,343.69432000000006,432.89431000000013,120.4,292.39432000000005,549.78864,724.8772700001001,-117.5,103.38864000010005,459.88296000009996,695.8659100003002,54.100300000000004,111.20060000000001,191.4006,228.4006,119.09462,270.29492000000005,435.28356000009995,519.1778800001,109.09462000000002,318.19492,563.3835600001,687.2778800001003,174.08894000000004,477.28924000000006,774.2665200002001,931.9551600002003,58.2,140.3,226.39432,266.49431000000004,90.4,212.4,343.69432000000006,432.89431000000013,120.4,292.39432000000005,549.78864,724.8772700001001,-117.5,103.38864000010005,459.88296000009996,695.8659100003002])
    (rev' @Double @4 conv2dBLaborious128c t128b)

testKonst5BigCLaborious128cb :: Assertion
testKonst5BigCLaborious128cb =
  assertEqualUpToEpsilonShort 1e-8
    (OR.fromList [4,2,4,4] [2640.8154000007976,1836.3264600007988,1163.4488800005001,483.7716000003,2412.414800000798,1662.026160000799,1046.2488800005003,446.7716000003,2121.6375200006987,1436.2432000006995,914.5659200004003,399.8772800003,1953.5375200006988,1258.1432000006998,794.3659200004003,359.8772800003,1712.044990000598,1566.644690000599,1143.0671100004001,478.5721900004001,1445.5506800005985,1358.3503800005992,1016.8728000004002,438.47220000040005,1279.150680000599,1224.1503800005996,922.5728000004001,389.3722000004,987.1677200004992,962.1674200005002,710.5841600003,303.48356000030003,2640.8154000007976,1836.3264600007988,1163.4488800005001,483.7716000003,2412.414800000798,1662.026160000799,1046.2488800005003,446.7716000003,2121.6375200006987,1436.2432000006995,914.5659200004003,399.8772800003,1953.5375200006988,1258.1432000006998,794.3659200004003,359.8772800003,1712.044990000598,1566.644690000599,1143.0671100004001,478.5721900004001,1445.5506800005985,1358.3503800005992,1016.8728000004002,438.47220000040005,1279.150680000599,1224.1503800005996,922.5728000004001,389.3722000004,987.1677200004992,962.1674200005002,710.5841600003,303.48356000030003,2640.8154000007976,1836.3264600007988,1163.4488800005001,483.7716000003,2412.414800000798,1662.026160000799,1046.2488800005003,446.7716000003,2121.6375200006987,1436.2432000006995,914.5659200004003,399.8772800003,1953.5375200006988,1258.1432000006998,794.3659200004003,359.8772800003,1712.044990000598,1566.644690000599,1143.0671100004001,478.5721900004001,1445.5506800005985,1358.3503800005992,1016.8728000004002,438.47220000040005,1279.150680000599,1224.1503800005996,922.5728000004001,389.3722000004,987.1677200004992,962.1674200005002,710.5841600003,303.48356000030003,2640.8154000007976,1836.3264600007988,1163.4488800005001,483.7716000003,2412.414800000798,1662.026160000799,1046.2488800005003,446.7716000003,2121.6375200006987,1436.2432000006995,914.5659200004003,399.8772800003,1953.5375200006988,1258.1432000006998,794.3659200004003,359.8772800003,1712.044990000598,1566.644690000599,1143.0671100004001,478.5721900004001,1445.5506800005985,1358.3503800005992,1016.8728000004002,438.47220000040005,1279.150680000599,1224.1503800005996,922.5728000004001,389.3722000004,987.1677200004992,962.1674200005002,710.5841600003,303.48356000030003])
    (rev' @Double @4 conv2dCLaborious128c t128b)

-- The gradient is the same as above, because one argument is the same
-- and convolution is linear.
testKonstNotBigCLaborious128cb :: Assertion
testKonstNotBigCLaborious128cb =
  assertEqualUpToEpsilonShort 1e-8
    (OR.fromList [4,2,4,4] [2640.8154000007976,1836.3264600007988,1163.4488800005001,483.7716000003,2412.414800000798,1662.026160000799,1046.2488800005003,446.7716000003,2121.6375200006987,1436.2432000006995,914.5659200004003,399.8772800003,1953.5375200006988,1258.1432000006998,794.3659200004003,359.8772800003,1712.044990000598,1566.644690000599,1143.0671100004001,478.5721900004001,1445.5506800005985,1358.3503800005992,1016.8728000004002,438.47220000040005,1279.150680000599,1224.1503800005996,922.5728000004001,389.3722000004,987.1677200004992,962.1674200005002,710.5841600003,303.48356000030003,2640.8154000007976,1836.3264600007988,1163.4488800005001,483.7716000003,2412.414800000798,1662.026160000799,1046.2488800005003,446.7716000003,2121.6375200006987,1436.2432000006995,914.5659200004003,399.8772800003,1953.5375200006988,1258.1432000006998,794.3659200004003,359.8772800003,1712.044990000598,1566.644690000599,1143.0671100004001,478.5721900004001,1445.5506800005985,1358.3503800005992,1016.8728000004002,438.47220000040005,1279.150680000599,1224.1503800005996,922.5728000004001,389.3722000004,987.1677200004992,962.1674200005002,710.5841600003,303.48356000030003,2640.8154000007976,1836.3264600007988,1163.4488800005001,483.7716000003,2412.414800000798,1662.026160000799,1046.2488800005003,446.7716000003,2121.6375200006987,1436.2432000006995,914.5659200004003,399.8772800003,1953.5375200006988,1258.1432000006998,794.3659200004003,359.8772800003,1712.044990000598,1566.644690000599,1143.0671100004001,478.5721900004001,1445.5506800005985,1358.3503800005992,1016.8728000004002,438.47220000040005,1279.150680000599,1224.1503800005996,922.5728000004001,389.3722000004,987.1677200004992,962.1674200005002,710.5841600003,303.48356000030003,2640.8154000007976,1836.3264600007988,1163.4488800005001,483.7716000003,2412.414800000798,1662.026160000799,1046.2488800005003,446.7716000003,2121.6375200006987,1436.2432000006995,914.5659200004003,399.8772800003,1953.5375200006988,1258.1432000006998,794.3659200004003,359.8772800003,1712.044990000598,1566.644690000599,1143.0671100004001,478.5721900004001,1445.5506800005985,1358.3503800005992,1016.8728000004002,438.47220000040005,1279.150680000599,1224.1503800005996,922.5728000004001,389.3722000004,987.1677200004992,962.1674200005002,710.5841600003,303.48356000030003])
    (rev' @Double @4 conv2dCLaborious128c t128b)


-- * A failed version (all tests had to be removed)

-- That's due to the conditional not being lazy and the indexing
-- (and gather) crashing when out of bounds. Either of these needs to be
-- fixed or, alternatively, the Ast term needs to be simplified after all
-- variables are known, but before interpretation, and all inaccessible
-- subtensor expressions need to be replaced with something safe, like 0,
-- which would likely grow the term a lot.
--
-- The failure would manifest in rev` that uses vectorization
-- and for tensors larger than 1-element, where indexes out of bounds
-- are generated (on purpose) in this code.
-- It would manifest with the older version of rindex that crashed
-- when out of bounds.


-- * Disparity

-- | Disparity cost volume.
--
--   Take two arrays of multi channel 2d images, where the first contains
--   left views of the scene and the second contains right views.
--
--   For each pair of images, slice the right image over the left image,
--   and for each offset produce the L1 distance indicating how well
--   correponding
--   multi-channel image elements in the right image match those in the left.
--
--   Described in:
--    Anytime Stereo Image Depth Estimation on Mobile Devices
--    Wang, Lai et al, ICRA 2019
--    https://arxiv.org/abs/1810.11408
--    Section III b).
--
costVolume
  :: forall r target. (ADReady target, GoodScalar r)
  => Int -> Int -> target (TKR r 4) -> target (TKR r 4) -> target (TKR r 4)
costVolume iStart nCount arrL arrR =
  let [nImgs, nChas, nRows, nCols] = rshape arrL
      shO = [nImgs, nCount, nRows, nCols]
  in rbuild shO $ \[iImg, iDisp, iRow, iCol] ->
       let arrVecL = rbuild (nChas :$: ZSR) $ \[iCha] ->
                       indexz0 arrL [iImg, iCha, iRow, iCol]
           iSrc = iCol - fromIntegral iStart - iDisp
           arrVecR = rbuild [nChas] $ \[iCha] ->
                       indexz0 arrR [iImg, iCha, iRow, iSrc]
       in rsum0 $ rzipWith1 (\xL xR -> abs (xL - xR)) arrVecL arrVecR

test_disparityKonst :: Assertion
test_disparityKonst = do
  let arrL :: ADReady target => target (TKR Double 4)
      arrL = rreplicate0N [1, 2, 4, 6] (rscalar (-0.2))
      arrR :: ADReady target => target (TKR Double 4)
      arrR = rreplicate0N [1, 2, 4, 6] (rscalar 0.3)
      arrO = costVolume @Double 0 4 arrL arrR
      arrDL = revDt (\aL -> costVolume 0 4 aL (rconstant arrR)) arrL arrO
      arrDR = revDt (\aR -> costVolume 0 4 (rconstant arrL) aR) arrR arrO
  assertEqualUpToEpsilon1 1e-7
    (OR.fromList [1,4,4,6] [1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,0.4,1.0,1.0,1.0,1.0,1.0,0.4,1.0,1.0,1.0,1.0,1.0,0.4,1.0,1.0,1.0,1.0,1.0,0.4,1.0,1.0,1.0,1.0,1.0,0.4,0.4,1.0,1.0,1.0,1.0,0.4,0.4,1.0,1.0,1.0,1.0,0.4,0.4,1.0,1.0,1.0,1.0,0.4,0.4,1.0,1.0,1.0,1.0,0.4,0.4,0.4,1.0,1.0,1.0,0.4,0.4,0.4,1.0,1.0,1.0,0.4,0.4,0.4,1.0,1.0,1.0,0.4,0.4,0.4,1.0,1.0,1.0])
    arrO
  assertEqualUpToEpsilon1 1e-7
    (OR.fromList [1,2,4,6] [-2.2,-2.8,-3.4,-4.0,-4.0,-4.0,-2.2,-2.8,-3.4,-4.0,-4.0,-4.0,-2.2,-2.8,-3.4,-4.0,-4.0,-4.0,-2.2,-2.8,-3.4,-4.0,-4.0,-4.0,-2.2,-2.8,-3.4,-4.0,-4.0,-4.0,-2.2,-2.8,-3.4,-4.0,-4.0,-4.0,-2.2,-2.8,-3.4,-4.0,-4.0,-4.0,-2.2,-2.8,-3.4,-4.0,-4.0,-4.0])
    arrDL
  assertEqualUpToEpsilon1 1e-7
    (OR.fromList [1,2,4,6] [4.0,4.0,4.0,3.0,2.0,1.0,4.0,4.0,4.0,3.0,2.0,1.0,4.0,4.0,4.0,3.0,2.0,1.0,4.0,4.0,4.0,3.0,2.0,1.0,4.0,4.0,4.0,3.0,2.0,1.0,4.0,4.0,4.0,3.0,2.0,1.0,4.0,4.0,4.0,3.0,2.0,1.0,4.0,4.0,4.0,3.0,2.0,1.0])
   arrDR
  assertEqualUpToEpsilon' 1e-7
    (OR.fromList [1,2,4,6] [4.0,4.0,4.0,3.0,2.0,1.0,4.0,4.0,4.0,3.0,2.0,1.0,4.0,4.0,4.0,3.0,2.0,1.0,4.0,4.0,4.0,3.0,2.0,1.0,4.0,4.0,4.0,3.0,2.0,1.0,4.0,4.0,4.0,3.0,2.0,1.0,4.0,4.0,4.0,3.0,2.0,1.0,4.0,4.0,4.0,3.0,2.0,1.0])
    (rev' @Double @4 (costVolume 0 4 arrL) (FlipR $ Nested.rtoOrthotope $ runFlipR $ unRepN $ arrR))
  assertEqualUpToEpsilon' 1e-7
    (OR.fromList [1,2,4,6] [-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0])
    (rev' @Double @4 (\aL -> costVolume 0 2 aL arrR) (FlipR $ Nested.rtoOrthotope $ runFlipR $ unRepN $ arrL))
  assertEqualUpToEpsilon' 1e-7
    (OR.fromList [1,2,4,6] [2.0,2.0,2.0,2.0,2.0,1.0,2.0,2.0,2.0,2.0,2.0,1.0,2.0,2.0,2.0,2.0,2.0,1.0,2.0,2.0,2.0,2.0,2.0,1.0,2.0,2.0,2.0,2.0,2.0,1.0,2.0,2.0,2.0,2.0,2.0,1.0,2.0,2.0,2.0,2.0,2.0,1.0,2.0,2.0,2.0,2.0,2.0,1.0])
    (rev' @Double @4 (costVolume 0 2 arrL) (FlipR $ Nested.rtoOrthotope $ runFlipR $ unRepN $ arrR))

test_disparityKonst2 :: Assertion
test_disparityKonst2 = do
  let arrL :: (BaseTensor target, GoodScalar r, Differentiable r) => target (TKR r 4)
      arrL = ringestData [1, 2, 4, 6] [0.4,0.4,0.4,1.0,1.0,1.0,0.4,0.4,0.4,1.0,1.0,1.0,0.4,0.4,0.4,1.0,1.0,1.0, 1.7041241452319316,1.21999,0.21355339059327375,0.7867666666666666,0.7331698975466578,0.6964466094067263,1.1,1.1041141452319316,0.42000000000000004,0.3536533905932737,0.78,1.253169897546658,1.1,0.50001,0.42000000000000004,0.2801,0.78,1.3,1.1,0.50001,0.42000000000000004,0.2801,0.78,1.3,2.808238290463863,1.21999,-0.5672067811865474,0.7867666666666666,1.986339795093316,0.6964466094067263]
      arrR :: (BaseTensor target, GoodScalar r, Differentiable r) => target (TKR r 4)
      arrR = ringestData [1, 2, 4, 6] [0.2, 0.5, -0.2, 0.0001, 0.44, 0.9, -0.9, 0.00001, -0.22, -0.28, -0.34, -0.40, -0.40,-0.22,-0.28,-0.34, 0.22360679774997896,0.35355339059327373,0.20412414523193154,0.5, -0.35355339059327373,0.16666666666666666,0.17677669529663687,-0.25, -2.808238290463863,-1.21999,-0.5672067811865474,-0.7867666666666666,-1.986339795093316,-0.6964466094067263,2.808238290463863,1.21999,-0.5672067811865474,0.7867666666666666,0.6964466094067263,0.42000000000000004,0.3536533905932737,0.78,1.253169897546658,0.50001,0.42000000000000004,0.2801,0.78,1.1,0.50001,0.42000000000000004,0.2801,0.78]
      arrO = OR.constant [1, 4, 4, 6] (1 :: Double)
      res1 = OR.fromList [1,2,4,6] [4.0,2.0,2.0,4.0,4.0,4.0,4.0,4.0,4.0,4.0,4.0,4.0,4.0,4.0,4.0,4.0,4.0,4.0,4.0,4.0,2.0,4.0,4.0,4.0,4.0,4.0,4.0,4.0,4.0,4.0,2.0,0.0,0.0,-2.0,0.0,4.0,4.0,2.0,0.0,-4.0,1.0,4.0,4.0,4.0,-4.0,2.0,4.0,2.0]
      res2 = OR.fromList [1,2,4,6] [-4.0,0.0,-4.0,-3.0,-2.0,-1.0,-4.0,-4.0,-4.0,-3.0,-2.0,-1.0,-4.0,-4.0,-4.0,-3.0,-2.0,-1.0,-4.0,-2.0,-4.0,-3.0,-2.0,-1.0,-4.0,-4.0,-4.0,-3.0,-2.0,-1.0,4.0,4.0,-4.0,1.0,-2.0,-1.0,-2.0,3.0,2.0,-1.0,-2.0,-1.0,-2.0,0.0,-2.0,-3.0,-2.0,1.0]
      arrDL :: RepN (TKR Double 4)
      arrDL = revDt (\aL -> costVolume 0 4 aL (rconstant arrR)) arrL (RepN $ FlipR $ Nested.rfromOrthotope SNat arrO)
      arrDR :: RepN (TKR Double 4)
      arrDR = revDt (costVolume 0 4 (rconstant arrL)) arrR (RepN $ FlipR $ Nested.rfromOrthotope SNat arrO)
  assertEqualUpToEpsilon1 1e-7
    res1
    arrDL
  assertEqualUpToEpsilon1 1e-7
    res2
    arrDR
  assertEqualUpToEpsilon' 1e-7
    res1
    (rev' @Double @4 (\aL -> costVolume 0 4 aL (rconstant arrR)) (FlipR $ Nested.rtoOrthotope $ runFlipR $ unRepN $ arrL))
  assertEqualUpToEpsilon' 1e-7
    res2
    (rev' @Double @4 (costVolume 0 4 (rconstant arrL)) (FlipR $ Nested.rtoOrthotope $ runFlipR $ unRepN $ arrR))

test_disparitySmall :: Assertion
test_disparitySmall = do
  let arrL :: ADReady target => target (TKR Double 4)
      arrL = ringestData [1, 2, 3, 2] [0.2, 0.5, -0.2, 0.0001, 0.44, 0.9, -0.9, 0.00001, -0.22, -0.28, -0.34, -0.40]
      arrR :: ADReady target => target (TKR Double 4)
      arrR = ringestData [1, 2, 3, 2] [-0.40,-0.22,-0.28,-0.34, 0.22360679774997896,0.35355339059327373,0.20412414523193154,0.5, -0.35355339059327373,0.16666666666666666,0.17677669529663687,-0.25]
      arrO = costVolume @Double 0 4 arrL arrR
      arrDL = revDt (\aL -> costVolume 0 4 aL (rconstant arrR)) arrL arrO
      arrDR = revDt (\aR -> costVolume 0 4 (rconstant arrL) aR) arrR arrO
  assertEqualUpToEpsilon1 1e-7
    (OR.fromList [1,4,3,2] [1.7041241452319316,1.21999,0.21355339059327375,0.7867666666666666,0.7331698975466578,0.6964466094067263,1.1,1.1041141452319316,0.42000000000000004,0.3536533905932737,0.78,1.253169897546658,1.1,0.50001,0.42000000000000004,0.2801,0.78,1.3,1.1,0.50001,0.42000000000000004,0.2801,0.78,1.3])
    arrO
  assertEqualUpToEpsilon' 1e-7
    (OR.fromList [1,2,3,2] [-2.0,-1.0,-2.0,-1.0,-2.0,-1.0,2.0,1.0,-2.0,1.0,2.0,1.0])
    (rev' @Double @4 (costVolume 0 4 arrL) (FlipR $ Nested.rtoOrthotope $ runFlipR $ unRepN $ arrR))
  assertEqualUpToEpsilon1 1e-7
    (OR.fromList [1,2,3,2] [5.004124145231932,3.3241241452319317,-1.0464466094067264,1.7006200572599404,3.0731698975466575,4.5496165069533845,-5.004124145231932,-1.3240841452319316,-1.0464466094067264,-0.9933132760733929,-3.0731698975466575,-4.5496165069533845])
    arrDL
  assertEqualUpToEpsilon1 1e-7
    (OR.fromList [1,2,3,2] [-2.808238290463863,-1.21999,-0.5672067811865474,-0.7867666666666666,-1.986339795093316,-0.6964466094067263,2.808238290463863,1.21999,-0.5672067811865474,0.7867666666666666,1.986339795093316,0.6964466094067263])
   arrDR
  assertEqualUpToEpsilon' 1e-7
    (OR.fromList [1,2,3,2] [-1.0,0.0,-1.0,0.0,-1.0,0.0,1.0,0.0,-1.0,0.0,1.0,0.0])
    (rev' @Double @4 (costVolume 1 4 arrL) (FlipR $ Nested.rtoOrthotope $ runFlipR $ unRepN arrR))
  assertEqualUpToEpsilon' 1e-7
    (OR.fromList [1,2,3,2] [2.0,2.0,-2.0,2.0,2.0,2.0,-2.0,2.0,-2.0,-2.0,-2.0,-2.0])
    (rev' @Double @4 (\aL -> costVolume 2 2 aL arrR) (FlipR $ Nested.rtoOrthotope $ runFlipR $ unRepN arrL))
  assertEqualUpToEpsilon' 1e-7
    (OR.fromList [1,2,3,2] [-1.0,0.0,-1.0,0.0,-1.0,0.0,1.0,0.0,-1.0,0.0,1.0,0.0])
    (rev' @Double @4 (costVolume 1 2 arrL) (FlipR $ Nested.rtoOrthotope $ runFlipR $ unRepN arrR))


-- * PP Tests

{- This probably needs some exotic instance of AdaptableHVector, so should be removed:
testConv2dUnpaddedPP :: Assertion
testConv2dUnpaddedPP = do
  resetVarCounter
  let f :: HVector (AstGeneric AstMethodLet FullSpan) -> AAstTensor AstMethodLet FullSpan (TKR Double 4)
      f v = conv2dUnpadded (rfromD $ rankedHVector v V.! 0) (rfromD $ rankedHVector v V.! 1)
      g :: Double -> RepN (TKR Double 4)
      g x = FlipR $ Nested.rfromOrthotope SNat $ OR.fromList [2,2,2,2] $ replicate 16 x
      (artifactRev, _) =
        revArtifactAdapt
                 True
                 f
                 (V.fromList [ DynamicRanked @Double @4 (g 1.1)
                             , DynamicRanked @Double @4 (g 2.3) ])
  printArtifactPretty IM.empty (simplifyArtifact artifactRev)
    @?= "\\u61 u175 u176 -> [rscatter [2,2,2,2] (rscatter [2,2,1,2,2,2] (rsum (rsum (rsum (rgather [2,2,2,2,1,2,2,2] (rtranspose [0,4,1,2,3] (rreplicate 2 (rreshape [2,2,2,8] (rgather [2,2,2,1,2,2,2] (rfromVector (fromList [rgather [2,2,2,1,2,2,2] u176 (\\[i37, i38, i39, i40, i41, i42, i43] -> [i37 + i40, i41, i38 + i42, i39 + i43]), rreplicate 2 (rreplicate 2 (rreplicate 2 (rreplicate 1 (rreplicate 2 (rreplicate 2 (rreplicate 2 0.0))))))])) (\\[i44, i45, i46, i47, i48, i49, i50] -> [ifF ((0 <=. i44 + i47 &&* 2 >. i44 + i47) &&* ((0 <=. i48 &&* 2 >. i48) &&* ((0 <=. i45 + i49 &&* 2 >. i45 + i49) &&* (0 <=. i46 + i50 &&* 2 >. i46 + i50)))) 0 1, i44, i45, i46, i47, i48, i49, i50])))) * rtranspose [2,0,1] (rreplicate 8 u61)) (\\[i148, i149, i150, i151, i152, i153, i154, i155] -> [remF (quotF (i155 + 2 * i154 + 4 * i153 + 8 * i151 + 8 * i152) 8) 2, remF (i155 + 2 * i154 + 4 * i153 + 8 * i151 + 8 * i152) 8, i148, i149, i150]))))) (\\[i62, i63, i64, i65, i66] -> [ifF ((0 <=. i62 + i63 &&* 2 >. i62 + i63) &&* ((0 <=. i64 &&* 2 >. i64) &&* ((0 <=. i65 &&* 2 >. i65) &&* (0 <=. i66 &&* 2 >. i66)))) 0 1, i62, i63, i64, i65, i66]) ! [0]) (\\[i68, i69] -> [i68 + i69]), rscatter [2,2,2,2] (rscatter [2,2,2,2,1,2,2,2] (rsum (rgather [2,2,2,2,1,2,2,2] (rtranspose [0,1,2,4,3] (rreplicate 2 (rreplicate 2 (rreplicate 2 (rreshape [2,8] (rgather [2,1,2,2,2] (rfromVector (fromList [rgather [2,1,2,2,2] u175 (\\[i52, i53] -> [i52 + i53]), rreplicate 2 (rreplicate 1 (rreplicate 2 (rreplicate 2 (rreplicate 2 0.0))))])) (\\[i54, i55, i56, i57, i58] -> [ifF ((0 <=. i54 + i55 &&* 2 >. i54 + i55) &&* ((0 <=. i56 &&* 2 >. i56) &&* ((0 <=. i57 &&* 2 >. i57) &&* (0 <=. i58 &&* 2 >. i58)))) 0 1, i54, i55, i56, i57, i58])))))) * rtranspose [1,3,4,0,2] (rreplicate 8 u61)) (\\[i163, i164, i165, i166, i167, i168, i169, i170] -> [remF (quotF (i170 + 2 * i169 + 4 * i168 + 8 * i167 + 8 * i166 + 32 * i164 + 16 * i165) 32) 2, remF (quotF (i170 + 2 * i169 + 4 * i168 + 8 * i167 + 8 * i166 + 32 * i164 + 16 * i165) 16) 2, remF (quotF (i170 + 2 * i169 + 4 * i168 + 8 * i167 + 8 * i166 + 32 * i164 + 16 * i165) 8) 2, remF (i170 + 2 * i169 + 4 * i168 + 8 * i167 + 8 * i166 + 32 * i164 + 16 * i165) 8, i163]))) (\\[i70, i71, i72, i73, i74, i75, i76] -> [ifF ((0 <=. i70 + i73 &&* 2 >. i70 + i73) &&* ((0 <=. i74 &&* 2 >. i74) &&* ((0 <=. i71 + i75 &&* 2 >. i71 + i75) &&* (0 <=. i72 + i76 &&* 2 >. i72 + i76)))) 0 1, i70, i71, i72, i73, i74, i75, i76]) ! [0]) (\\[i78, i79, i80, i81, i82, i83, i84] -> [i78 + i81, i82, i79 + i83, i80 + i84])]"
-}

testConv2dUnpadded2PP :: Assertion
testConv2dUnpadded2PP = do
  resetVarCounter
  let f :: AstTensor AstMethodLet FullSpan TKUntyped
        -> AstTensor AstMethodLet FullSpan TKUntyped
      f hv = let v = dunHVector hv
             in dmkHVector
                $ V.singleton $ DynamicRanked @Double @4
                $ conv2dUnpadded (rfromD $ v V.! 0) (rfromD $ v V.! 1)
      shs = V.fromList [ voidFromSh @Double (2 :$: 2 :$: 2 :$: 2 :$: ZSR)
                       , voidFromSh @Double (2 :$: 2 :$: 2 :$: 2 :$: ZSR) ]
      (artifactRev, _) =
        revArtifactFromForwardPass
          True (forwardPassByInterpretation f emptyEnv) (FTKUntyped shs)
  printArtifactPretty IM.empty (simplifyArtifact artifactRev)
    @?= "\\h58 u172 u173 -> [rscatter [2,2,2,2] (rscatter [2,2,1,2,2,2] (rsum (rsum (rsum (rgather [2,2,2,2,1,2,2,2] (rtranspose [0,4,1,2,3] (rreplicate 2 (rreshape [2,2,2,8] (rgather [2,2,2,1,2,2,2] (rfromVector (fromList [rgather [2,2,2,1,2,2,2] u173 (\\[i34, i35, i36, i37, i38, i39, i40] -> [i34 + i37, i38, i35 + i39, i36 + i40]), rreplicate 2 (rreplicate 2 (rreplicate 2 (rreplicate 1 (rreplicate 2 (rreplicate 2 (rreplicate 2 0.0))))))])) (\\[i41, i42, i43, i44, i45, i46, i47] -> [ifF ((0 <=. i41 + i44 &&* 2 >. i41 + i44) &&* ((0 <=. i45 &&* 2 >. i45) &&* ((0 <=. i42 + i46 &&* 2 >. i42 + i46) &&* (0 <=. i43 + i47 &&* 2 >. i43 + i47)))) 0 1, i41, i42, i43, i44, i45, i46, i47])))) * rtranspose [2,0,1] (rreplicate 8 (rproject h58 0))) (\\[i149, i150, i151, i152, i153, i154, i155, i156] -> [remF (quotF (i156 + 2 * i155 + 4 * i154 + 8 * i152 + 8 * i153) 8) 2, remF (i156 + 2 * i155 + 4 * i154 + 8 * i152 + 8 * i153) 8, i149, i150, i151]))))) (\\[i63, i64, i65, i66, i67] -> [ifF ((0 <=. i63 + i64 &&* 2 >. i63 + i64) &&* ((0 <=. i65 &&* 2 >. i65) &&* ((0 <=. i66 &&* 2 >. i66) &&* (0 <=. i67 &&* 2 >. i67)))) 0 1, i63, i64, i65, i66, i67]) ! [0]) (\\[i69, i70] -> [i69 + i70]), rscatter [2,2,2,2] (rscatter [2,2,2,2,1,2,2,2] (rsum (rgather [2,2,2,2,1,2,2,2] (rtranspose [0,1,2,4,3] (rreplicate 2 (rreplicate 2 (rreplicate 2 (rreshape [2,8] (rgather [2,1,2,2,2] (rfromVector (fromList [rgather [2,1,2,2,2] u172 (\\[i49, i50] -> [i49 + i50]), rreplicate 2 (rreplicate 1 (rreplicate 2 (rreplicate 2 (rreplicate 2 0.0))))])) (\\[i51, i52, i53, i54, i55] -> [ifF ((0 <=. i51 + i52 &&* 2 >. i51 + i52) &&* ((0 <=. i53 &&* 2 >. i53) &&* ((0 <=. i54 &&* 2 >. i54) &&* (0 <=. i55 &&* 2 >. i55)))) 0 1, i51, i52, i53, i54, i55])))))) * rtranspose [1,3,4,0,2] (rreplicate 8 (rproject h58 0))) (\\[i164, i165, i166, i167, i168, i169, i170, i171] -> [remF (quotF (i171 + 2 * i170 + 4 * i169 + 8 * i168 + 8 * i167 + 32 * i165 + 16 * i166) 32) 2, remF (quotF (i171 + 2 * i170 + 4 * i169 + 8 * i168 + 8 * i167 + 32 * i165 + 16 * i166) 16) 2, remF (quotF (i171 + 2 * i170 + 4 * i169 + 8 * i168 + 8 * i167 + 32 * i165 + 16 * i166) 8) 2, remF (i171 + 2 * i170 + 4 * i169 + 8 * i168 + 8 * i167 + 32 * i165 + 16 * i166) 8, i164]))) (\\[i71, i72, i73, i74, i75, i76, i77] -> [ifF ((0 <=. i71 + i74 &&* 2 >. i71 + i74) &&* ((0 <=. i75 &&* 2 >. i75) &&* ((0 <=. i72 + i76 &&* 2 >. i72 + i76) &&* (0 <=. i73 + i77 &&* 2 >. i73 + i77)))) 0 1, i71, i72, i73, i74, i75, i76, i77]) ! [0]) (\\[i79, i80, i81, i82, i83, i84, i85] -> [i79 + i82, i83, i80 + i84, i81 + i85])]"

-- This is fragile due to indexing out of bounds, see above.
testConv2dUnpadded3PP :: Assertion
testConv2dUnpadded3PP = do
  resetVarCounter
  let f :: AstTensor AstMethodLet FullSpan TKUntyped
        -> AstTensor AstMethodLet FullSpan TKUntyped
      f hv = let v = dunHVector hv
             in dmkHVector
                $ V.singleton $ DynamicRanked @Double @4
                $ conv2d (rfromD $ v V.! 0) (rfromD $ v V.! 1)
      shs = V.fromList [ voidFromSh @Double (2 :$: 2 :$: 2 :$: 2 :$: ZSR)
                       , voidFromSh @Double (2 :$: 2 :$: 2 :$: 2 :$: ZSR) ]
      (artifactRev, _) =
        revArtifactFromForwardPass
          True (forwardPassByInterpretation f emptyEnv) (FTKUntyped shs)
  printArtifactPretty IM.empty artifactRev
    @?= "\\h34 u44 u45 -> let w32 = rtranspose [4,1,0,2,3] (rreplicate 2 (rreshape [2,2,2,8] (rgather [2,2,2,1,2,2,2] u45 (\\[i22, i23, i24, i25, i26, i27, i28] -> [i22 + i25, i26, i23 + i27, i24 + i28])))) ; w33 = rtranspose [4,0,3,1,2] (rreplicate 2 (rreplicate 2 (rreplicate 2 (rreshape [2,8] (rgather [2,1,2,2,2] u44 (\\[i30, i31] -> [i30 + i31])))))) in [rscatter [2,2,2,2] (rreshape [2,1,2,2,2] (rsum (rsum (rsum (rtranspose [1,3,4,2,0] (w32 * rreplicate 8 (rproject h34 0))))))) (\\[i35, i36] -> [i35 + i36]), rscatter [2,2,2,2] (rreshape [2,2,2,1,2,2,2] (rsum (rtranspose [2,1,3,4,0] (w33 * rreplicate 8 (rproject h34 0))))) (\\[i37, i38, i39, i40, i41, i42, i43] -> [i37 + i40, i41, i38 + i42, i39 + i43])]"
  printArtifactPretty IM.empty (simplifyArtifact artifactRev)
    @?= "\\h34 u144 u145 -> [rscatter [2,2,2,2] (rsum (rsum (rsum (rgather [2,2,2,2,1,2,2,2] (rtranspose [0,4,1,2,3] (rreplicate 2 (rreshape [2,2,2,8] (rgather [2,2,2,1,2,2,2] u145 (\\[i22, i23, i24, i25, i26, i27, i28] -> [i22 + i25, i26, i23 + i27, i24 + i28])))) * rtranspose [2,0,1] (rreplicate 8 (rproject h34 0))) (\\[i121, i122, i123, i124, i125, i126, i127, i128] -> [remF (quotF (i128 + 2 * i127 + 4 * i126 + 8 * i124 + 8 * i125) 8) 2, remF (i128 + 2 * i127 + 4 * i126 + 8 * i124 + 8 * i125) 8, i121, i122, i123]))))) (\\[i35, i36] -> [i35 + i36]), rscatter [2,2,2,2] (rsum (rgather [2,2,2,2,1,2,2,2] (rtranspose [0,1,2,4,3] (rreplicate 2 (rreplicate 2 (rreplicate 2 (rreshape [2,8] (rgather [2,1,2,2,2] u144 (\\[i30, i31] -> [i30 + i31])))))) * rtranspose [1,3,4,0,2] (rreplicate 8 (rproject h34 0))) (\\[i136, i137, i138, i139, i140, i141, i142, i143] -> [remF (quotF (i143 + 2 * i142 + 4 * i141 + 8 * i140 + 8 * i139 + 32 * i137 + 16 * i138) 32) 2, remF (quotF (i143 + 2 * i142 + 4 * i141 + 8 * i140 + 8 * i139 + 32 * i137 + 16 * i138) 16) 2, remF (quotF (i143 + 2 * i142 + 4 * i141 + 8 * i140 + 8 * i139 + 32 * i137 + 16 * i138) 8) 2, remF (i143 + 2 * i142 + 4 * i141 + 8 * i140 + 8 * i139 + 32 * i137 + 16 * i138) 8, i136]))) (\\[i37, i38, i39, i40, i41, i42, i43] -> [i37 + i40, i41, i38 + i42, i39 + i43])]"
  printArtifactPrimalPretty IM.empty artifactRev
    @?= "\\u146 u147 -> let w32 = rtranspose [4,1,0,2,3] (rreplicate 2 (rreshape [2,2,2,8] (rgather [2,2,2,1,2,2,2] u147 (\\[i22, i23, i24, i25, i26, i27, i28] -> [i22 + i25, i26, i23 + i27, i24 + i28])))) ; w33 = rtranspose [4,0,3,1,2] (rreplicate 2 (rreplicate 2 (rreplicate 2 (rreshape [2,8] (rgather [2,1,2,2,2] u146 (\\[i30, i31] -> [i30 + i31])))))) in [rsum (w32 * w33)]"
  printArtifactPrimalPretty IM.empty (simplifyArtifact artifactRev)
    @?= "\\u246 u247 -> [rsum (rtranspose [4,1,0,2,3] (rreplicate 2 (rreshape [2,2,2,8] (rgather [2,2,2,1,2,2,2] u247 (\\[i22, i23, i24, i25, i26, i27, i28] -> [i22 + i25, i26, i23 + i27, i24 + i28])))) * rtranspose [4,0,3,1,2] (rreplicate 2 (rreplicate 2 (rreplicate 2 (rreshape [2,8] (rgather [2,1,2,2,2] u246 (\\[i30, i31] -> [i30 + i31])))))))]"
