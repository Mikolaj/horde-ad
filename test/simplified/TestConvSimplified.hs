{-# LANGUAGE AllowAmbiguousTypes, OverloadedLists #-}
{-# OPTIONS_GHC -Wno-incomplete-uni-patterns #-}
module TestConvSimplified (testTrees) where

import Prelude

import           Control.Exception (assert)
import qualified Data.Array.RankedS as OR
import           Data.Boolean
import           GHC.TypeLits (KnownNat)
import           Test.Tasty
import           Test.Tasty.HUnit hiding (assert)

import HordeAd

import HordeAd.Internal.TensorOps
import TestAdaptorSimplified (assertEqualUpToEpsilon', rev', t128b, t128c, t16b)
import Tool.EqEpsilon

testTrees :: [TestTree]
testTrees =
  [ testCase "KonstG0Rev" testKonstG0Rev
  , testCase "KonstG0Tiny1" testKonstG0Tiny1
  , testCase "KonstG0TinyS" testKonstG0TinyS
  , testCase "KonstG0TinyA" testKonstG0TinyA
  , testCase "KonstG0LittleA" testKonstG0LittleA
  , testCase "Konst0RevLaborious" testKonst0RevLaborious
  , testCase "Konst0Tiny1Laborious" testKonst0Tiny1Laborious
  , testCase "Konst0TinySLaborious" testKonst0TinySLaborious
  , testCase "Konst0TinyALaborious" testKonst0TinyALaborious
  , testCase "Konst0LittleALaborious" testKonst0LittleALaborious
  , testCase "Konst5LittleBLaborious" testKonst5LittleBLaborious
  , testCase "Konst5LittleCLaborious" testKonst5LittleCLaborious
  , testCase "Konst5BigBLaborious" testKonst5BigBLaborious
  , testCase "KonstNotBigBLaborious" testKonstNotBigBLaborious
  , testCase "Konst5BigCLaborious" testKonst5BigCLaborious
  , testCase "KonstNotBigCLaborious" testKonstNotBigCLaborious
  , testCase "Konst5LittleBLaborious128b" testKonst5LittleBLaborious128b
  , testCase "Konst5LittleCLaborious128b" testKonst5LittleCLaborious128b
  , testCase "Konst5BigBLaborious128b" testKonst5BigBLaborious128b
  , testCase "KonstNotBigBLaborious128b" testKonstNotBigBLaborious128b
  , testCase "Konst5BigCLaborious128b" testKonst5BigCLaborious128b
  , testCase "KonstNotBigCLaborious128b" testKonstNotBigCLaborious128b
  , testCase "Konst5LittleBLaborious128c" testKonst5LittleBLaborious128c
  , testCase "Konst5LittleCLaborious128c" testKonst5LittleCLaborious128c
  , testCase "Konst5BigBLaborious128c" testKonst5BigBLaborious128c
  , testCase "KonstNotBigBLaborious128c" testKonstNotBigBLaborious128c
  , testCase "Konst5BigCLaborious128c" testKonst5BigCLaborious128c
  , testCase "KonstNotBigCLaborious128c" testKonstNotBigCLaborious128c
  , testCase "Konst5LittleBLaborious128bc" testKonst5LittleBLaborious128bc
  , testCase "Konst5LittleCLaborious128bc" testKonst5LittleCLaborious128bc
  , testCase "Konst5BigBLaborious128bc" testKonst5BigBLaborious128bc
  , testCase "KonstNotBigBLaborious128cb" testKonstNotBigBLaborious128cb
  , testCase "Konst5BigCLaborious128cb" testKonst5BigCLaborious128cb
  , testCase "KonstNotBigCLaborious128cb" testKonstNotBigCLaborious128cb
  , testCase "Konst0RevFailed" testKonst0RevFailed
  , testCase "Konst0Tiny1Failed" testKonst0Tiny1Failed
  , testCase "Konst0TinySFailed" testKonst0TinySFailed
  , testCase "disparityKonst" test_disparityKonst
  , testCase "disparitySmall" test_disparitySmall
  ]

-- The examples reproduce and transformed in this file are borrowed
-- from https://github.com/benl23x5/adops.
-- Here it's defined using ranked tensors with sized indexes.

-- Test comments are currently outdated. The first implementation
-- is currently correct only by chance (and this may change).
-- The "laborious" implementation is the solid one.

-- | Unpadded full convolution,
--   where the output size is the same as the input size.
conv2d
  :: ADReady r
  => TensorOf 4 r -> TensorOf 4 r -> TensorOf 4 r
conv2d arrK arrA =
  let [nImgs, nCinpA, nAh, nAw] = tshape arrA
      [nCoutK, nCinpK, nKh, nKw] = tshape arrK
      nCinp = assert (nCinpA == nCinpK) nCinpA
      shB = [nImgs, nCoutK, nAh, nAw]
      shK1 = [1, nCinp, nKh, nKw]
  in tbuild shB $ \case
    [iImg, iCout, iBh, iBw] ->
      let arrAt = slicez shK1 arrA [iImg, 0, iBh, iBw]
          arrKt = slicez shK1 arrK [iCout, 0, 0, 0]
      in tdot0 arrAt arrKt
    _ -> error "conv2d: impossible pattern needlessly required"

-- | Slice a section out of a tensor,
--   given a base offset and shape of the section.
--
--   If the slice extends out side the source array then the corresponding
--   elements are set to zero.
slicez :: forall n r. (ADReady r, KnownNat n)
       => ShapeInt n -> TensorOf n r -> IndexOf n r -> TensorOf n r
slicez shOut d ixBase =
  tbuild shOut $ \ixResult ->
    tindex @r @n @0 d (zipWith_Index (+) ixBase ixResult)
      -- tindex0 would not require a single type application here

conv2d1
  :: ADReady r
  => TensorOf 4 r -> TensorOf 4 r
conv2d1 = conv2dFailed $ tconst $ OR.fromList [1, 1, 1, 1] [-0.2]

conv2dA
  :: ADReady r
  => TensorOf 4 r -> TensorOf 4 r
conv2dA = conv2d $ tconst $ OR.fromList [1, 2, 1, 1] [-0.2, 25.0003]

conv2dB
  :: ADReady r
  => TensorOf 4 r -> TensorOf 4 r
conv2dB = conv2d $ tconst t16b

testKonstG0Rev :: Assertion
testKonstG0Rev =
  assertEqualUpToEpsilon 1e-10
    (OR.fromList [2, 2, 2, 2] [18.1,29.1,32.1,40.1,582932.0,582934.99432,582597.1,582625.8943200001,18.1,29.1,32.1,40.1,582932.0,582934.99432,582597.1,582625.8943200001])
    (rev @(OR.Array 4 Double) conv2dB (tkonst0N [2, 2, 2, 2] 0))

testKonstG0Tiny1 :: Assertion
testKonstG0Tiny1 =
  assertEqualUpToEpsilon' 1e-10
    (OR.fromList [1, 1, 1, 1] [-0.2])
    (rev' @(OR.Array 4 Double) conv2d1 (tkonst0N [1, 1, 1, 1] 0))

testKonstG0TinyS :: Assertion
testKonstG0TinyS =
  assertEqualUpToEpsilon' 1e-10
    (OR.fromList [1, 1, 1, 1] [582665.99432])
    (rev' @(OR.Array 4 Double)
          (conv2d $ tconst $ tkonst0NR [1, 1, 1, 1] (tsum0R t16b))
          (OR.fromList [1, 1, 1, 1] [0]))

testKonstG0TinyA :: Assertion
testKonstG0TinyA =
  assertEqualUpToEpsilon' 1e-10
    (OR.fromList [1, 2, 1, 1] [-0.2,25.0003])
    (rev' @(OR.Array 4 Double) conv2dA (tkonst0N [1, 2, 1, 1] 0))

testKonstG0LittleA :: Assertion
testKonstG0LittleA =
  assertEqualUpToEpsilon' 1e-10
    (OR.fromList [2, 2, 2, 2] [-0.2,-0.2,-0.2,-0.2,25.0003,25.0003,25.0003,25.0003,-0.2,-0.2,-0.2,-0.2,25.0003,25.0003,25.0003,25.0003])
    (rev' @(OR.Array 4 Double) conv2dA (tkonst0N [2, 2, 2, 2] 0))


-- * A laborious version

-- It guards the out of bounds indexing behind a conditional
-- to prevent changed values after vectorization,
-- despite the indexing giving 0 when out of bounds.
-- If another value than 0 was needed, the conditional
-- would be necessary even without vectorization.
--
-- Some tests are copied from above and the required test results are
-- the same.

-- | Unpadded full convolution,
--   where the output size is the same as the input size.
conv2dLaborious
  :: ADReady r
  => TensorOf 4 r -> TensorOf 4 r -> TensorOf 4 r
conv2dLaborious arrK arrA =
  let [nImgs, nCinpA, nAh, nAw] = tshape arrA
      [nCoutK, nCinpK, nKh, nKw] = tshape arrK
      nCinp = assert (nCinpA == nCinpK) nCinpA
      shB = [nImgs, nCoutK, nAh, nAw]
      shK1 = [1, nCinp, nKh, nKw]
  in tbuild shB $ \case
    [iImg, iCout, iBh, iBw] ->
      let arrAt = slicezLaborious shK1 arrA [iImg, 0, iBh, iBw]
          arrKt = slicezLaborious shK1 arrK [iCout, 0, 0, 0]
      in tdot0 arrAt arrKt
    _ -> error "conv2d: impossible pattern needlessly required"

-- | Slice a section out of a tensor,
--   given a base offset and shape of the section.
--
--   If the slice extends out side the source array then the corresponding
--   elements are set to zero.
slicezLaborious
  :: (ADReady r, KnownNat n)
  => ShapeInt n -> TensorOf n r -> IndexOf n r -> TensorOf n r
slicezLaborious shOut d ixBase =
  tbuild shOut $ \ixResult -> indexz0Laborious d (zipWith_Index (+) ixBase ixResult)

-- Note that this is now spurious, since the current version of index
-- returns 0 when out of bounds. But if another values was required,
-- the current vections of index would be needed together with this
-- conditional.
-- | Retrieve the element at the given index,
--   returning zero for out of range indices.
indexz0Laborious
  :: forall r n. (ADReady r, KnownNat n)
  => TensorOf n r -> IndexOf n r -> TensorOf 0 r
indexz0Laborious d ix = ifB (within0 @r (tshape d) ix) (d ! ix) 0

-- | Given an index and shape, check if the index is fully within the shape.
within0 :: forall r n. ADReady r
        => ShapeInt n -> IndexOf n r -> BooleanOf r
within0 sh ix =
  let within :: IntOf r -> IntOf r -> BooleanOf r
      within i dim = 0 <=* i &&* dim >* i
  in foldr (&&*) true
     $ zipWith within (indexToList ix) (map fromIntegral $ shapeToList sh)

conv2d1Laborious
  :: ADReady r
  => TensorOf 4 r -> TensorOf 4 r
conv2d1Laborious = conv2dLaborious $ tconst $ OR.fromList [1, 1, 1, 1] [-0.2]

conv2dALaborious
  :: ADReady r
  => TensorOf 4 r -> TensorOf 4 r
conv2dALaborious = conv2dLaborious $ tconst $ OR.fromList [1, 2, 1, 1] [-0.2, 25.0003]

conv2dBLaborious
  :: ADReady r
  => TensorOf 4 r -> TensorOf 4 r
conv2dBLaborious = conv2dLaborious $ tconst t16b

conv2dCLaborious
  :: ADReady r
  => TensorOf 4 r -> TensorOf 4 r
conv2dCLaborious = flip conv2dLaborious $ tconst t16b

conv2dBLaborious128b
  :: ADReady r
  => TensorOf 4 r -> TensorOf 4 r
conv2dBLaborious128b = conv2dLaborious $ tconst t128b

conv2dCLaborious128b
  :: ADReady r
  => TensorOf 4 r -> TensorOf 4 r
conv2dCLaborious128b = flip conv2dLaborious $ tconst t128b

conv2dBLaborious128c
  :: ADReady r
  => TensorOf 4 r -> TensorOf 4 r
conv2dBLaborious128c = conv2dLaborious $ tconst t128c

conv2dCLaborious128c
  :: ADReady r
  => TensorOf 4 r -> TensorOf 4 r
conv2dCLaborious128c = flip conv2dLaborious $ tconst t128c

testKonst0RevLaborious :: Assertion
testKonst0RevLaborious =
  assertEqualUpToEpsilon 1e-10
    (OR.fromList [2, 2, 2, 2] [18.1,29.1,32.1,40.1,582932.0,582934.99432,582597.1,582625.8943200001,18.1,29.1,32.1,40.1,582932.0,582934.99432,582597.1,582625.8943200001])
    (rev @(OR.Array 4 Double) conv2dBLaborious (tkonst0N [2, 2, 2, 2] 0))

testKonst0Tiny1Laborious :: Assertion
testKonst0Tiny1Laborious =
  assertEqualUpToEpsilon' 1e-10
    (OR.fromList [1, 1, 1, 1] [-0.2])
    (rev' @(OR.Array 4 Double) conv2d1Laborious (tkonst0N [1, 1, 1, 1] 0))

testKonst0TinySLaborious :: Assertion
testKonst0TinySLaborious =
  assertEqualUpToEpsilon' 1e-10
    (OR.fromList [1, 1, 1, 1] [582665.99432])
    (rev' @(OR.Array 4 Double)
          (conv2dLaborious $ tconst $ tkonst0NR [1, 1, 1, 1] (tsum0R t16b))
          (OR.fromList [1, 1, 1, 1] [0]))

testKonst0TinyALaborious :: Assertion
testKonst0TinyALaborious =
  assertEqualUpToEpsilon' 1e-10
    (OR.fromList [1, 2, 1, 1] [-0.2,25.0003])
    (rev' @(OR.Array 4 Double) conv2dALaborious (tkonst0N [1, 2, 1, 1] 0))

testKonst0LittleALaborious :: Assertion
testKonst0LittleALaborious =
  assertEqualUpToEpsilon' 1e-10
    (OR.fromList [2, 2, 2, 2] [-0.2,-0.2,-0.2,-0.2,25.0003,25.0003,25.0003,25.0003,-0.2,-0.2,-0.2,-0.2,25.0003,25.0003,25.0003,25.0003])
    (rev' @(OR.Array 4 Double) conv2dALaborious (tkonst0N [2, 2, 2, 2] 0))

-- with data t16

testKonst5LittleBLaborious :: Assertion
testKonst5LittleBLaborious =
  assertEqualUpToEpsilon' 1e-8
    (OR.fromList [2, 2, 2, 2] [18.1,29.1,32.1,40.1,582932.0,582934.99432,582597.1,582625.8943200001,18.1,29.1,32.1,40.1,582932.0,582934.99432,582597.1,582625.8943200001])
    (rev' @(OR.Array 4 Double) conv2dBLaborious (tkonst0N [2, 2, 2, 2] 5))

testKonst5LittleCLaborious :: Assertion
testKonst5LittleCLaborious =
  assertEqualUpToEpsilon' 1e-8
    (OR.fromList [2, 2, 2, 2] [40.1,8.0,11.0,-3.0,582625.89432,28.79432,-309.09999999999997,25.8,40.1,8.0,11.0,-3.0,582625.89432,28.79432,-309.09999999999997,25.8])
    (rev' @(OR.Array 4 Double) conv2dCLaborious (tkonst0N [2, 2, 2, 2] 5))

testKonst5BigBLaborious :: Assertion
testKonst5BigBLaborious =
  assertEqualUpToEpsilon' 1e-8
    (OR.fromList [3, 2, 4, 2] [18.1,29.1,32.1,40.1,32.1,40.1,32.1,40.1,582932.0,582934.99432,582597.1,582625.8943200001,582597.1,582625.8943200001,582597.1,582625.8943200001,18.1,29.1,32.1,40.1,32.1,40.1,32.1,40.1,582932.0,582934.99432,582597.1,582625.8943200001,582597.1,582625.8943200001,582597.1,582625.8943200001,18.1,29.1,32.1,40.1,32.1,40.1,32.1,40.1,582932.0,582934.99432,582597.1,582625.8943200001,582597.1,582625.8943200001,582597.1,582625.8943200001])
    (rev' @(OR.Array 4 Double) conv2dBLaborious (tkonst0N [3, 2, 4, 2] 5))

-- The gradient is the same as above, because one argument is the same
-- and convolution is linear.
testKonstNotBigBLaborious :: Assertion
testKonstNotBigBLaborious =
  assertEqualUpToEpsilon' 1e-8
    (OR.fromList [3, 2, 4, 2] [18.1,29.1,32.1,40.1,32.1,40.1,32.1,40.1,582932.0,582934.99432,582597.1,582625.8943200001,582597.1,582625.8943200001,582597.1,582625.8943200001,18.1,29.1,32.1,40.1,32.1,40.1,32.1,40.1,582932.0,582934.99432,582597.1,582625.8943200001,582597.1,582625.8943200001,582597.1,582625.8943200001,18.1,29.1,32.1,40.1,32.1,40.1,32.1,40.1,582932.0,582934.99432,582597.1,582625.8943200001,582597.1,582625.8943200001,582597.1,582625.8943200001])
    (rev' @(OR.Array 4 Double) conv2dBLaborious
          (tfromList0N [3, 2, 4, 2] [37, 36 .. -10]))

testKonst5BigCLaborious :: Assertion
testKonst5BigCLaborious =
  assertEqualUpToEpsilon' 1e-8
    (OR.fromList [3, 2, 4, 2] [40.1,8.0,11.0,-3.0,0.0,0.0,0.0,0.0,582625.8943200001,28.794320000000003,-309.09999999999997,25.8,0.0,0.0,0.0,0.0,40.1,8.0,11.0,-3.0,0.0,0.0,0.0,0.0,582625.8943200001,28.794320000000003,-309.09999999999997,25.8,0.0,0.0,0.0,0.0,40.1,8.0,11.0,-3.0,0.0,0.0,0.0,0.0,582625.8943200001,28.794320000000003,-309.09999999999997,25.8,0.0,0.0,0.0,0.0])
    (rev' @(OR.Array 4 Double) conv2dCLaborious (tkonst0N [3, 2, 4, 2] 5))

-- The gradient is the same as above, because one argument is the same
-- and convolution is linear.
testKonstNotBigCLaborious :: Assertion
testKonstNotBigCLaborious =
  assertEqualUpToEpsilon' 1e-8
    (OR.fromList [3, 2, 4, 2] [40.1,8.0,11.0,-3.0,0.0,0.0,0.0,0.0,582625.8943200001,28.794320000000003,-309.09999999999997,25.8,0.0,0.0,0.0,0.0,40.1,8.0,11.0,-3.0,0.0,0.0,0.0,0.0,582625.8943200001,28.794320000000003,-309.09999999999997,25.8,0.0,0.0,0.0,0.0,40.1,8.0,11.0,-3.0,0.0,0.0,0.0,0.0,582625.8943200001,28.794320000000003,-309.09999999999997,25.8,0.0,0.0,0.0,0.0])
    (rev' @(OR.Array 4 Double) conv2dCLaborious
          (tfromList0N [3, 2, 4, 2] [37, 36 .. -10]))

-- with data t128b

testKonst5LittleBLaborious128b :: Assertion
testKonst5LittleBLaborious128b =
  assertEqualUpToEpsilon' 1e-8
    (OR.fromList [2, 2, 2, 2] [112.3003,251.5006,209.49462,482.69492000000014,3.000000000000032,65.90000000000003,164.10000000000002,365.89432000010004,112.3003,251.5006,209.49462,482.69492000000014,3.000000000000032,65.90000000000003,164.10000000000002,365.89432000010004])
    (rev' @(OR.Array 4 Double) conv2dBLaborious128b (tkonst0N [2, 2, 2, 2] 5))

testKonst5LittleCLaborious128b :: Assertion
testKonst5LittleCLaborious128b =
  assertEqualUpToEpsilon' 1e-8
    (OR.fromList [2, 2, 2, 2] [1627.8210700004993,1571.2321300004994,1132.9261600005002,1188.6375200005,2725.0393200008984,1831.7390200008983,2551.139320000898,1660.8390200008987,1627.8210700004993,1571.2321300004994,1132.9261600005002,1188.6375200005,2725.0393200008984,1831.7390200008983,2551.139320000898,1660.8390200008987])
    (rev' @(OR.Array 4 Double) conv2dCLaborious128b (tkonst0N [2, 2, 2, 2] 5))

testKonst5BigBLaborious128b :: Assertion
testKonst5BigBLaborious128b =
  assertEqualUpToEpsilon' 1e-8
    (OR.fromList [3, 2, 4, 2] [112.3003,251.5006,209.49462,482.69492000000014,229.49462000000003,610.5892400000002,56.58894000000004,580.6778800001001,3.000000000000032,65.90000000000003,164.10000000000002,365.89432000010004,667.2003000000001,1060.8778800002,893.3003,1465.6665200003993,112.3003,251.5006,209.49462,482.69492000000014,229.49462000000003,610.5892400000002,56.58894000000004,580.6778800001001,3.000000000000032,65.90000000000003,164.10000000000002,365.89432000010004,667.2003000000001,1060.8778800002,893.3003,1465.6665200003993,112.3003,251.5006,209.49462,482.69492000000014,229.49462000000003,610.5892400000002,56.58894000000004,580.6778800001001,3.000000000000032,65.90000000000003,164.10000000000002,365.89432000010004,667.2003000000001,1060.8778800002,893.3003,1465.6665200003993])
    (rev' @(OR.Array 4 Double) conv2dBLaborious128b (tkonst0N [3, 2, 4, 2] 5))

-- The gradient is the same as above, because one argument is the same
-- and convolution is linear.
testKonstNotBigBLaborious128b :: Assertion
testKonstNotBigBLaborious128b =
  assertEqualUpToEpsilon' 1e-8
    (OR.fromList [3, 2, 4, 2] [112.3003,251.5006,209.49462,482.69492000000014,229.49462000000003,610.5892400000002,56.58894000000004,580.6778800001001,3.000000000000032,65.90000000000003,164.10000000000002,365.89432000010004,667.2003000000001,1060.8778800002,893.3003,1465.6665200003993,112.3003,251.5006,209.49462,482.69492000000014,229.49462000000003,610.5892400000002,56.58894000000004,580.6778800001001,3.000000000000032,65.90000000000003,164.10000000000002,365.89432000010004,667.2003000000001,1060.8778800002,893.3003,1465.6665200003993,112.3003,251.5006,209.49462,482.69492000000014,229.49462000000003,610.5892400000002,56.58894000000004,580.6778800001001,3.000000000000032,65.90000000000003,164.10000000000002,365.89432000010004,667.2003000000001,1060.8778800002,893.3003,1465.6665200003993])
    (rev' @(OR.Array 4 Double) conv2dBLaborious128b
          (tfromList0N [3, 2, 4, 2] [37, 36 .. -10]))

testKonst5BigCLaborious128b :: Assertion
testKonst5BigCLaborious128b =
  assertEqualUpToEpsilon' 1e-8
    (OR.fromList [3, 2, 4, 2] [1627.8210700004993,1571.2321300004994,1132.9261600005002,1188.6375200005,675.7488800003999,828.6545600004001,215.6659200003,388.5716000003,2725.0393200008984,1831.7390200008983,2551.139320000898,1660.8390200008987,1903.750080000699,1174.5497800006997,854.9778800004001,628.8778800004001,1627.8210700004993,1571.2321300004994,1132.9261600005002,1188.6375200005,675.7488800003999,828.6545600004001,215.6659200003,388.5716000003,2725.0393200008984,1831.7390200008983,2551.139320000898,1660.8390200008987,1903.750080000699,1174.5497800006997,854.9778800004001,628.8778800004001,1627.8210700004993,1571.2321300004994,1132.9261600005002,1188.6375200005,675.7488800003999,828.6545600004001,215.6659200003,388.5716000003,2725.0393200008984,1831.7390200008983,2551.139320000898,1660.8390200008987,1903.750080000699,1174.5497800006997,854.9778800004001,628.8778800004001])
    (rev' @(OR.Array 4 Double) conv2dCLaborious128b (tkonst0N [3, 2, 4, 2] 5))

-- The gradient is the same as above, because one argument is the same
-- and convolution is linear.
testKonstNotBigCLaborious128b :: Assertion
testKonstNotBigCLaborious128b =
  assertEqualUpToEpsilon' 1e-8
    (OR.fromList [3, 2, 4, 2] [1627.8210700004993,1571.2321300004994,1132.9261600005002,1188.6375200005,675.7488800003999,828.6545600004001,215.6659200003,388.5716000003,2725.0393200008984,1831.7390200008983,2551.139320000898,1660.8390200008987,1903.750080000699,1174.5497800006997,854.9778800004001,628.8778800004001,1627.8210700004993,1571.2321300004994,1132.9261600005002,1188.6375200005,675.7488800003999,828.6545600004001,215.6659200003,388.5716000003,2725.0393200008984,1831.7390200008983,2551.139320000898,1660.8390200008987,1903.750080000699,1174.5497800006997,854.9778800004001,628.8778800004001,1627.8210700004993,1571.2321300004994,1132.9261600005002,1188.6375200005,675.7488800003999,828.6545600004001,215.6659200003,388.5716000003,2725.0393200008984,1831.7390200008983,2551.139320000898,1660.8390200008987,1903.750080000699,1174.5497800006997,854.9778800004001,628.8778800004001])
    (rev' @(OR.Array 4 Double) conv2dCLaborious128b
          (tfromList0N [3, 2, 4, 2] [37, 36 .. -10]))

-- with data t128c

testKonst5LittleBLaborious128c :: Assertion
testKonst5LittleBLaborious128c =
  assertEqualUpToEpsilon' 1e-8
    (OR.fromList [2, 2, 2, 2] [54.100300000000004,111.20060000000001,119.09462,270.29492000000005,58.2,140.3,90.4,212.4,54.100300000000004,111.20060000000001,119.09462,270.29492000000005,58.2,140.3,90.4,212.4])
    (rev' @(OR.Array 4 Double) conv2dBLaborious128c (tkonst0N [2, 2, 2, 2] 5))

testKonst5LittleCLaborious128c :: Assertion
testKonst5LittleCLaborious128c =
  assertEqualUpToEpsilon' 1e-8
    (OR.fromList [2, 2, 2, 2] [2640.8154000007976,1836.3264600007988,2412.414800000798,1662.026160000799,1712.044990000598,1566.644690000599,1445.5506800005985,1358.3503800005992,2640.8154000007976,1836.3264600007988,2412.414800000798,1662.026160000799,1712.044990000598,1566.644690000599,1445.5506800005985,1358.3503800005992])
    (rev' @(OR.Array 4 Double) conv2dCLaborious128c (tkonst0N [2, 2, 2, 2] 5))

testKonst5BigBLaborious128c :: Assertion
testKonst5BigBLaborious128c =
  assertEqualUpToEpsilon' 1e-8
    (OR.fromList [3, 2, 4, 2] [54.100300000000004,111.20060000000001,119.09462,270.29492000000005,109.09462000000002,318.19492,174.08894000000004,477.28924000000006,58.2,140.3,90.4,212.4,120.4,292.39432000000005,-117.5,103.38864000010005,54.100300000000004,111.20060000000001,119.09462,270.29492000000005,109.09462000000002,318.19492,174.08894000000004,477.28924000000006,58.2,140.3,90.4,212.4,120.4,292.39432000000005,-117.5,103.38864000010005,54.100300000000004,111.20060000000001,119.09462,270.29492000000005,109.09462000000002,318.19492,174.08894000000004,477.28924000000006,58.2,140.3,90.4,212.4,120.4,292.39432000000005,-117.5,103.38864000010005])
    (rev' @(OR.Array 4 Double) conv2dBLaborious128c (tkonst0N [3, 2, 4, 2] 5))

-- The gradient is the same as above, because one argument is the same
-- and convolution is linear.
testKonstNotBigBLaborious128c :: Assertion
testKonstNotBigBLaborious128c =
  assertEqualUpToEpsilon' 1e-8
    (OR.fromList [3, 2, 4, 2] [54.100300000000004,111.20060000000001,119.09462,270.29492000000005,109.09462000000002,318.19492,174.08894000000004,477.28924000000006,58.2,140.3,90.4,212.4,120.4,292.39432000000005,-117.5,103.38864000010005,54.100300000000004,111.20060000000001,119.09462,270.29492000000005,109.09462000000002,318.19492,174.08894000000004,477.28924000000006,58.2,140.3,90.4,212.4,120.4,292.39432000000005,-117.5,103.38864000010005,54.100300000000004,111.20060000000001,119.09462,270.29492000000005,109.09462000000002,318.19492,174.08894000000004,477.28924000000006,58.2,140.3,90.4,212.4,120.4,292.39432000000005,-117.5,103.38864000010005])
    (rev' @(OR.Array 4 Double) conv2dBLaborious128c
          (tfromList0N [3, 2, 4, 2] [37, 36 .. -10]))

testKonst5BigCLaborious128c :: Assertion
testKonst5BigCLaborious128c =
  assertEqualUpToEpsilon' 1e-8
    (OR.fromList [3, 2, 4, 2] [2640.8154000007976,1836.3264600007988,2412.414800000798,1662.026160000799,2121.6375200006987,1436.2432000006995,1953.5375200006988,1258.1432000006998,1712.044990000598,1566.644690000599,1445.5506800005985,1358.3503800005992,1279.150680000599,1224.1503800005996,987.1677200004992,962.1674200005002,2640.8154000007976,1836.3264600007988,2412.414800000798,1662.026160000799,2121.6375200006987,1436.2432000006995,1953.5375200006988,1258.1432000006998,1712.044990000598,1566.644690000599,1445.5506800005985,1358.3503800005992,1279.150680000599,1224.1503800005996,987.1677200004992,962.1674200005002,2640.8154000007976,1836.3264600007988,2412.414800000798,1662.026160000799,2121.6375200006987,1436.2432000006995,1953.5375200006988,1258.1432000006998,1712.044990000598,1566.644690000599,1445.5506800005985,1358.3503800005992,1279.150680000599,1224.1503800005996,987.1677200004992,962.1674200005002])
    (rev' @(OR.Array 4 Double) conv2dCLaborious128c (tkonst0N [3, 2, 4, 2] 5))

-- The gradient is the same as above, because one argument is the same
-- and convolution is linear.
testKonstNotBigCLaborious128c :: Assertion
testKonstNotBigCLaborious128c =
  assertEqualUpToEpsilon' 1e-8
    (OR.fromList [3, 2, 4, 2] [2640.8154000007976,1836.3264600007988,2412.414800000798,1662.026160000799,2121.6375200006987,1436.2432000006995,1953.5375200006988,1258.1432000006998,1712.044990000598,1566.644690000599,1445.5506800005985,1358.3503800005992,1279.150680000599,1224.1503800005996,987.1677200004992,962.1674200005002,2640.8154000007976,1836.3264600007988,2412.414800000798,1662.026160000799,2121.6375200006987,1436.2432000006995,1953.5375200006988,1258.1432000006998,1712.044990000598,1566.644690000599,1445.5506800005985,1358.3503800005992,1279.150680000599,1224.1503800005996,987.1677200004992,962.1674200005002,2640.8154000007976,1836.3264600007988,2412.414800000798,1662.026160000799,2121.6375200006987,1436.2432000006995,1953.5375200006988,1258.1432000006998,1712.044990000598,1566.644690000599,1445.5506800005985,1358.3503800005992,1279.150680000599,1224.1503800005996,987.1677200004992,962.1674200005002])
    (rev' @(OR.Array 4 Double) conv2dCLaborious128c
          (tfromList0N [3, 2, 4, 2] [37, 36 .. -10]))

-- with data t128b and t128c

testKonst5LittleBLaborious128bc :: Assertion
testKonst5LittleBLaborious128bc =
  assertEqualUpToEpsilon' 1e-8
    (OR.fromList [2,2,8,4] [112.3003,251.5006,417.79492000000005,494.89491000000015,209.49462,482.69492000000014,778.9778800001002,952.0721900001002,229.49462000000003,610.5892400000002,1113.1722000001,1412.1551500001997,56.58894000000004,580.6778800001001,1234.1494800003,1627.8210700004993,56.58894000000004,580.6778800001001,1234.1494800003,1627.8210700004993,56.58894000000004,580.6778800001001,1234.1494800003,1627.8210700004993,56.58894000000004,580.6778800001001,1234.1494800003,1627.8210700004993,56.58894000000004,580.6778800001001,1234.1494800003,1627.8210700004993,3.000000000000032,65.90000000000003,106.90000000000003,173.90000000000006,164.10000000000002,365.89432000010004,593.1946200001,821.2892400002004,667.2003000000001,1060.8778800002,1500.2781800001994,1870.0614400004986,893.3003,1465.6665200003993,2156.3671200003987,2725.039320000898,893.3003,1465.6665200003993,2156.3671200003987,2725.039320000898,893.3003,1465.6665200003993,2156.3671200003987,2725.039320000898,893.3003,1465.6665200003993,2156.3671200003987,2725.039320000898,893.3003,1465.6665200003993,2156.3671200003987,2725.039320000898,112.3003,251.5006,417.79492000000005,494.89491000000015,209.49462,482.69492000000014,778.9778800001002,952.0721900001002,229.49462000000003,610.5892400000002,1113.1722000001,1412.1551500001997,56.58894000000004,580.6778800001001,1234.1494800003,1627.8210700004993,56.58894000000004,580.6778800001001,1234.1494800003,1627.8210700004993,56.58894000000004,580.6778800001001,1234.1494800003,1627.8210700004993,56.58894000000004,580.6778800001001,1234.1494800003,1627.8210700004993,56.58894000000004,580.6778800001001,1234.1494800003,1627.8210700004993,3.000000000000032,65.90000000000003,106.90000000000003,173.90000000000006,164.10000000000002,365.89432000010004,593.1946200001,821.2892400002004,667.2003000000001,1060.8778800002,1500.2781800001994,1870.0614400004986,893.3003,1465.6665200003993,2156.3671200003987,2725.039320000898,893.3003,1465.6665200003993,2156.3671200003987,2725.039320000898,893.3003,1465.6665200003993,2156.3671200003987,2725.039320000898,893.3003,1465.6665200003993,2156.3671200003987,2725.039320000898,893.3003,1465.6665200003993,2156.3671200003987,2725.039320000898])
    (rev' @(OR.Array 4 Double) conv2dBLaborious128b t128c)

testKonst5LittleCLaborious128bc :: Assertion
testKonst5LittleCLaborious128bc =
  assertEqualUpToEpsilon' 1e-8
    (OR.fromList [2,2,8,4] [1627.8210700004993,1571.2321300004994,1047.1431900004002,393.6715900002,1132.9261600005002,1188.6375200005,803.7488800004002,316.57160000019996,675.7488800003999,828.6545600004001,577.7659200003001,220.57728000019998,215.6659200003,388.5716000003,245.5772800002,94.68864000010001,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,2725.0393200008984,1831.7390200008983,1259.3728000004999,568.6722000005001,2551.139320000898,1660.8390200008987,1151.3728000005,501.6722000005,1903.750080000699,1174.5497800006997,803.9778800004001,340.5775800004001,854.9778800004001,628.8778800004001,450.1892400002,198.8889400002,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1627.8210700004993,1571.2321300004994,1047.1431900004002,393.6715900002,1132.9261600005002,1188.6375200005,803.7488800004002,316.57160000019996,675.7488800003999,828.6545600004001,577.7659200003001,220.57728000019998,215.6659200003,388.5716000003,245.5772800002,94.68864000010001,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,2725.0393200008984,1831.7390200008983,1259.3728000004999,568.6722000005001,2551.139320000898,1660.8390200008987,1151.3728000005,501.6722000005,1903.750080000699,1174.5497800006997,803.9778800004001,340.5775800004001,854.9778800004001,628.8778800004001,450.1892400002,198.8889400002,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0])
    (rev' @(OR.Array 4 Double) conv2dCLaborious128b t128c)

testKonst5BigBLaborious128bc :: Assertion
testKonst5BigBLaborious128bc =
  assertEqualUpToEpsilon' 1e-8
    (OR.fromList [2,2,8,4] [112.3003,251.5006,417.79492000000005,494.89491000000015,209.49462,482.69492000000014,778.9778800001002,952.0721900001002,229.49462000000003,610.5892400000002,1113.1722000001,1412.1551500001997,56.58894000000004,580.6778800001001,1234.1494800003,1627.8210700004993,56.58894000000004,580.6778800001001,1234.1494800003,1627.8210700004993,56.58894000000004,580.6778800001001,1234.1494800003,1627.8210700004993,56.58894000000004,580.6778800001001,1234.1494800003,1627.8210700004993,56.58894000000004,580.6778800001001,1234.1494800003,1627.8210700004993,3.000000000000032,65.90000000000003,106.90000000000003,173.90000000000006,164.10000000000002,365.89432000010004,593.1946200001,821.2892400002004,667.2003000000001,1060.8778800002,1500.2781800001994,1870.0614400004986,893.3003,1465.6665200003993,2156.3671200003987,2725.039320000898,893.3003,1465.6665200003993,2156.3671200003987,2725.039320000898,893.3003,1465.6665200003993,2156.3671200003987,2725.039320000898,893.3003,1465.6665200003993,2156.3671200003987,2725.039320000898,893.3003,1465.6665200003993,2156.3671200003987,2725.039320000898,112.3003,251.5006,417.79492000000005,494.89491000000015,209.49462,482.69492000000014,778.9778800001002,952.0721900001002,229.49462000000003,610.5892400000002,1113.1722000001,1412.1551500001997,56.58894000000004,580.6778800001001,1234.1494800003,1627.8210700004993,56.58894000000004,580.6778800001001,1234.1494800003,1627.8210700004993,56.58894000000004,580.6778800001001,1234.1494800003,1627.8210700004993,56.58894000000004,580.6778800001001,1234.1494800003,1627.8210700004993,56.58894000000004,580.6778800001001,1234.1494800003,1627.8210700004993,3.000000000000032,65.90000000000003,106.90000000000003,173.90000000000006,164.10000000000002,365.89432000010004,593.1946200001,821.2892400002004,667.2003000000001,1060.8778800002,1500.2781800001994,1870.0614400004986,893.3003,1465.6665200003993,2156.3671200003987,2725.039320000898,893.3003,1465.6665200003993,2156.3671200003987,2725.039320000898,893.3003,1465.6665200003993,2156.3671200003987,2725.039320000898,893.3003,1465.6665200003993,2156.3671200003987,2725.039320000898,893.3003,1465.6665200003993,2156.3671200003987,2725.039320000898])
    (rev' @(OR.Array 4 Double) conv2dBLaborious128b t128c)

-- The gradient is the same as above, because one argument is the same
-- and convolution is linear.
testKonstNotBigBLaborious128cb :: Assertion
testKonstNotBigBLaborious128cb =
  assertEqualUpToEpsilon' 1e-8
    (OR.fromList [4,2,4,4] [54.100300000000004,111.20060000000001,191.4006,228.4006,119.09462,270.29492000000005,435.28356000009995,519.1778800001,109.09462000000002,318.19492,563.3835600001,687.2778800001003,174.08894000000004,477.28924000000006,774.2665200002001,931.9551600002003,58.2,140.3,226.39432,266.49431000000004,90.4,212.4,343.69432000000006,432.89431000000013,120.4,292.39432000000005,549.78864,724.8772700001001,-117.5,103.38864000010005,459.88296000009996,695.8659100003002,54.100300000000004,111.20060000000001,191.4006,228.4006,119.09462,270.29492000000005,435.28356000009995,519.1778800001,109.09462000000002,318.19492,563.3835600001,687.2778800001003,174.08894000000004,477.28924000000006,774.2665200002001,931.9551600002003,58.2,140.3,226.39432,266.49431000000004,90.4,212.4,343.69432000000006,432.89431000000013,120.4,292.39432000000005,549.78864,724.8772700001001,-117.5,103.38864000010005,459.88296000009996,695.8659100003002,54.100300000000004,111.20060000000001,191.4006,228.4006,119.09462,270.29492000000005,435.28356000009995,519.1778800001,109.09462000000002,318.19492,563.3835600001,687.2778800001003,174.08894000000004,477.28924000000006,774.2665200002001,931.9551600002003,58.2,140.3,226.39432,266.49431000000004,90.4,212.4,343.69432000000006,432.89431000000013,120.4,292.39432000000005,549.78864,724.8772700001001,-117.5,103.38864000010005,459.88296000009996,695.8659100003002,54.100300000000004,111.20060000000001,191.4006,228.4006,119.09462,270.29492000000005,435.28356000009995,519.1778800001,109.09462000000002,318.19492,563.3835600001,687.2778800001003,174.08894000000004,477.28924000000006,774.2665200002001,931.9551600002003,58.2,140.3,226.39432,266.49431000000004,90.4,212.4,343.69432000000006,432.89431000000013,120.4,292.39432000000005,549.78864,724.8772700001001,-117.5,103.38864000010005,459.88296000009996,695.8659100003002])
    (rev' @(OR.Array 4 Double) conv2dBLaborious128c t128b)

testKonst5BigCLaborious128cb :: Assertion
testKonst5BigCLaborious128cb =
  assertEqualUpToEpsilon' 1e-8
    (OR.fromList [4,2,4,4] [2640.8154000007976,1836.3264600007988,1163.4488800005001,483.7716000003,2412.414800000798,1662.026160000799,1046.2488800005003,446.7716000003,2121.6375200006987,1436.2432000006995,914.5659200004003,399.8772800003,1953.5375200006988,1258.1432000006998,794.3659200004003,359.8772800003,1712.044990000598,1566.644690000599,1143.0671100004001,478.5721900004001,1445.5506800005985,1358.3503800005992,1016.8728000004002,438.47220000040005,1279.150680000599,1224.1503800005996,922.5728000004001,389.3722000004,987.1677200004992,962.1674200005002,710.5841600003,303.48356000030003,2640.8154000007976,1836.3264600007988,1163.4488800005001,483.7716000003,2412.414800000798,1662.026160000799,1046.2488800005003,446.7716000003,2121.6375200006987,1436.2432000006995,914.5659200004003,399.8772800003,1953.5375200006988,1258.1432000006998,794.3659200004003,359.8772800003,1712.044990000598,1566.644690000599,1143.0671100004001,478.5721900004001,1445.5506800005985,1358.3503800005992,1016.8728000004002,438.47220000040005,1279.150680000599,1224.1503800005996,922.5728000004001,389.3722000004,987.1677200004992,962.1674200005002,710.5841600003,303.48356000030003,2640.8154000007976,1836.3264600007988,1163.4488800005001,483.7716000003,2412.414800000798,1662.026160000799,1046.2488800005003,446.7716000003,2121.6375200006987,1436.2432000006995,914.5659200004003,399.8772800003,1953.5375200006988,1258.1432000006998,794.3659200004003,359.8772800003,1712.044990000598,1566.644690000599,1143.0671100004001,478.5721900004001,1445.5506800005985,1358.3503800005992,1016.8728000004002,438.47220000040005,1279.150680000599,1224.1503800005996,922.5728000004001,389.3722000004,987.1677200004992,962.1674200005002,710.5841600003,303.48356000030003,2640.8154000007976,1836.3264600007988,1163.4488800005001,483.7716000003,2412.414800000798,1662.026160000799,1046.2488800005003,446.7716000003,2121.6375200006987,1436.2432000006995,914.5659200004003,399.8772800003,1953.5375200006988,1258.1432000006998,794.3659200004003,359.8772800003,1712.044990000598,1566.644690000599,1143.0671100004001,478.5721900004001,1445.5506800005985,1358.3503800005992,1016.8728000004002,438.47220000040005,1279.150680000599,1224.1503800005996,922.5728000004001,389.3722000004,987.1677200004992,962.1674200005002,710.5841600003,303.48356000030003])
    (rev' @(OR.Array 4 Double) conv2dCLaborious128c t128b)

-- The gradient is the same as above, because one argument is the same
-- and convolution is linear.
testKonstNotBigCLaborious128cb :: Assertion
testKonstNotBigCLaborious128cb =
  assertEqualUpToEpsilon' 1e-8
    (OR.fromList [4,2,4,4] [2640.8154000007976,1836.3264600007988,1163.4488800005001,483.7716000003,2412.414800000798,1662.026160000799,1046.2488800005003,446.7716000003,2121.6375200006987,1436.2432000006995,914.5659200004003,399.8772800003,1953.5375200006988,1258.1432000006998,794.3659200004003,359.8772800003,1712.044990000598,1566.644690000599,1143.0671100004001,478.5721900004001,1445.5506800005985,1358.3503800005992,1016.8728000004002,438.47220000040005,1279.150680000599,1224.1503800005996,922.5728000004001,389.3722000004,987.1677200004992,962.1674200005002,710.5841600003,303.48356000030003,2640.8154000007976,1836.3264600007988,1163.4488800005001,483.7716000003,2412.414800000798,1662.026160000799,1046.2488800005003,446.7716000003,2121.6375200006987,1436.2432000006995,914.5659200004003,399.8772800003,1953.5375200006988,1258.1432000006998,794.3659200004003,359.8772800003,1712.044990000598,1566.644690000599,1143.0671100004001,478.5721900004001,1445.5506800005985,1358.3503800005992,1016.8728000004002,438.47220000040005,1279.150680000599,1224.1503800005996,922.5728000004001,389.3722000004,987.1677200004992,962.1674200005002,710.5841600003,303.48356000030003,2640.8154000007976,1836.3264600007988,1163.4488800005001,483.7716000003,2412.414800000798,1662.026160000799,1046.2488800005003,446.7716000003,2121.6375200006987,1436.2432000006995,914.5659200004003,399.8772800003,1953.5375200006988,1258.1432000006998,794.3659200004003,359.8772800003,1712.044990000598,1566.644690000599,1143.0671100004001,478.5721900004001,1445.5506800005985,1358.3503800005992,1016.8728000004002,438.47220000040005,1279.150680000599,1224.1503800005996,922.5728000004001,389.3722000004,987.1677200004992,962.1674200005002,710.5841600003,303.48356000030003,2640.8154000007976,1836.3264600007988,1163.4488800005001,483.7716000003,2412.414800000798,1662.026160000799,1046.2488800005003,446.7716000003,2121.6375200006987,1436.2432000006995,914.5659200004003,399.8772800003,1953.5375200006988,1258.1432000006998,794.3659200004003,359.8772800003,1712.044990000598,1566.644690000599,1143.0671100004001,478.5721900004001,1445.5506800005985,1358.3503800005992,1016.8728000004002,438.47220000040005,1279.150680000599,1224.1503800005996,922.5728000004001,389.3722000004,987.1677200004992,962.1674200005002,710.5841600003,303.48356000030003])
    (rev' @(OR.Array 4 Double) conv2dCLaborious128c t128b)


-- * A failed version

-- That's due to the conditional not being lazy and the indexing
-- (and gather) crashing when out of bounds. Either of these needs to be
-- fixed or, alternatively, the Ast term needs to be simplified after all
-- variables are known, but before interpretation, and all inaccessible
-- subtensor expressions need to be replaced with something safe, like 0,
-- which would likely grow the term a lot.
--
-- The failure would manifest in rev` that uses vectorization
-- and for tensors larger than 1-element, where indexes out of bounds
-- are generated (on purpose) in this code.
-- It would manifest with the older version of tindex that crashed
-- when out of bounds.

conv2dFailed
  :: ADReady r
  => TensorOf 4 r -> TensorOf 4 r -> TensorOf 4 r
conv2dFailed arrK arrA =
  let [nImgs, nCinpA, nAh, nAw] = tshape arrA
      [nCoutK, nCinpK, nKh, nKw] = tshape arrK
      nCinp = assert (nCinpA == nCinpK) nCinpA
      shB = [nImgs, nCoutK, nAh, nAw]
      shK1 = [1, nCinp, nKh, nKw]
  in tbuild shB $ \case
    [iImg, iCout, iBh, iBw] ->
      let arrAt = slicezFailed shK1 arrA [iImg, 0, iBh, iBw]
          arrKt = slicezFailed shK1 arrK [iCout, 0, 0, 0]
      in tdot0 arrAt arrKt
    _ -> error "conv2d: impossible pattern needlessly required"

-- | Slice a section out of a tensor,
--   given a base offset and shape of the section.
--
--   If the slice extends out side the source array then the corresponding
--   elements are set to zero.
slicezFailed
  :: (ADReady r, KnownNat n)
  => ShapeInt n -> TensorOf n r -> IndexOf n r -> TensorOf n r
slicezFailed shOut d ixBase =
  tbuild shOut $ \ixResult ->
    indexz0Failed d (zipWith_Index (+) ixBase ixResult)

-- | Retrieve the element at the given index,
--   returning zero for out of range indices.
indexz0Failed
  :: forall r n. (ADReady r, KnownNat n)
  => TensorOf n r -> IndexOf n r -> TensorOf 0 r
indexz0Failed d ix = ifB (within0 @r (tshape d) ix) (d ! ix) 0

conv2d1Failed
  :: ADReady r
  => TensorOf 4 r -> TensorOf 4 r
conv2d1Failed = conv2dFailed $ tconst $ OR.fromList [1, 1, 1, 1] [-0.2]

conv2dBFailed
  :: ADReady r
  => TensorOf 4 r -> TensorOf 4 r
conv2dBFailed = conv2dFailed $ tconst t16b

testKonst0RevFailed :: Assertion
testKonst0RevFailed =
  assertEqualUpToEpsilon 1e-10
    (OR.fromList [2, 2, 2, 2] [18.1,29.1,32.1,40.1,582932.0,582934.99432,582597.1,582625.8943200001,18.1,29.1,32.1,40.1,582932.0,582934.99432,582597.1,582625.8943200001])
    (rev @(OR.Array 4 Double) conv2dBFailed (tkonst0N [2, 2, 2, 2] 0))

testKonst0Tiny1Failed :: Assertion
testKonst0Tiny1Failed =
  assertEqualUpToEpsilon' 1e-10
    (OR.fromList [1, 1, 1, 1] [-0.2])
    (rev' @(OR.Array 4 Double) conv2d1Failed (tkonst0N [1, 1, 1, 1] 0))

testKonst0TinySFailed :: Assertion
testKonst0TinySFailed =
  assertEqualUpToEpsilon' 1e-10
    (OR.fromList [1, 1, 1, 1] [582665.99432])
    (rev' @(OR.Array 4 Double)
          (conv2dFailed $ tconst $ tkonst0NR [1, 1, 1, 1] (tsum0R t16b))
          (OR.fromList [1, 1, 1, 1] [0]))


-- * Disparity

-- | Disparity cost volume.
--
--   Take two arrays of multi channel 2d images, where the first contains
--   left views of the scene and the second contains right views.
--
--   For each pair of images, slice the right image over the left image,
--   and for each offset produce the L1 distance indicating how well
--   correponding
--   multi-channel image elements in the right image match those in the left.
--
--   Described in:
--    Anytime Stereo Image Depth Estimation on Mobile Devices
--    Wang, Lai et al, ICRA 2019
--    https://arxiv.org/abs/1810.11408
--    Section III b).
--
costVolume
  :: ADReady r
  => Int -> Int -> TensorOf 4 r -> TensorOf 4 r -> TensorOf 4 r
costVolume iStart nCount arrL arrR =
  let [nImgs, nChas,  nRows, nCols] = tshape arrL
      shO = [nImgs, nCount, nRows, nCols]
  in tbuild shO $ \[iImg, iDisp, iRow, iCol] ->
       let arrVecL = tbuild (nChas :$ ZS) $ \[iCha] ->
                       indexz0Laborious arrL [iImg, iCha, iRow, iCol]
           iSrc = iCol - fromIntegral iStart - iDisp
           arrVecR = tbuild [nChas] $ \[iCha] ->
                       indexz0Laborious arrR [iImg, iCha, iRow, iSrc]
       in tsum0 $ tzipWith1 (\xL xR -> abs (xL - xR)) arrVecL arrVecR

test_disparityKonst :: Assertion
test_disparityKonst = do
  let arrL :: ADReady r => TensorOf 4 r
      arrL = tkonst0N [1, 2, 4, 6] (-0.2)
      arrR :: ADReady r => TensorOf 4 r
      arrR = tkonst0N [1, 2, 4, 6] 0.3
      arrO = value @(OR.Array 4 Double) (uncurry $ costVolume 0 4) (arrL, arrR)
      arrDL = revDt (\aL -> costVolume 0 2 aL (tconstant arrR)) arrL arrO
      arrDR = revDt (\aR -> costVolume 0 2 (tconstant arrL) aR) arrR arrO
  assertEqualUpToEpsilon 1e-7
    (OR.fromList [1,4,4,6] [1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,0.4,1.0,1.0,1.0,1.0,1.0,0.4,1.0,1.0,1.0,1.0,1.0,0.4,1.0,1.0,1.0,1.0,1.0,0.4,1.0,1.0,1.0,1.0,1.0,0.4,0.4,1.0,1.0,1.0,1.0,0.4,0.4,1.0,1.0,1.0,1.0,0.4,0.4,1.0,1.0,1.0,1.0,0.4,0.4,1.0,1.0,1.0,1.0,0.4,0.4,0.4,1.0,1.0,1.0,0.4,0.4,0.4,1.0,1.0,1.0,0.4,0.4,0.4,1.0,1.0,1.0,0.4,0.4,0.4,1.0,1.0,1.0])
    arrO
  assertEqualUpToEpsilon 1e-7
    (OR.fromList [1,2,4,6] [-2.2,-2.8,-3.4,-4.0,-4.0,-4.0,-2.2,-2.8,-3.4,-4.0,-4.0,-4.0,-2.2,-2.8,-3.4,-4.0,-4.0,-4.0,-2.2,-2.8,-3.4,-4.0,-4.0,-4.0,-2.2,-2.8,-3.4,-4.0,-4.0,-4.0,-2.2,-2.8,-3.4,-4.0,-4.0,-4.0,-2.2,-2.8,-3.4,-4.0,-4.0,-4.0,-2.2,-2.8,-3.4,-4.0,-4.0,-4.0])
    arrDL
  assertEqualUpToEpsilon 1e-7
    (OR.fromList [1,2,4,6] [4.0,4.0,4.0,3.0,2.0,1.0,4.0,4.0,4.0,3.0,2.0,1.0,4.0,4.0,4.0,3.0,2.0,1.0,4.0,4.0,4.0,3.0,2.0,1.0,4.0,4.0,4.0,3.0,2.0,1.0,4.0,4.0,4.0,3.0,2.0,1.0,4.0,4.0,4.0,3.0,2.0,1.0,4.0,4.0,4.0,3.0,2.0,1.0])
   arrDR
  assertEqualUpToEpsilon' 1e-7
    (OR.fromList [1,2,4,6] [4.0,4.0,4.0,3.0,2.0,1.0,4.0,4.0,4.0,3.0,2.0,1.0,4.0,4.0,4.0,3.0,2.0,1.0,4.0,4.0,4.0,3.0,2.0,1.0,4.0,4.0,4.0,3.0,2.0,1.0,4.0,4.0,4.0,3.0,2.0,1.0,4.0,4.0,4.0,3.0,2.0,1.0,4.0,4.0,4.0,3.0,2.0,1.0])
    (rev' @(OR.Array 4 Double) (costVolume 0 4 arrL) arrR)
  assertEqualUpToEpsilon' 1e-7
    (OR.fromList [1,2,4,6] [-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0])
    (rev' @(OR.Array 4 Double) (\aL -> costVolume 0 2 aL arrR) arrL)
  assertEqualUpToEpsilon' 1e-7
    (OR.fromList [1,2,4,6] [2.0,2.0,2.0,2.0,2.0,1.0,2.0,2.0,2.0,2.0,2.0,1.0,2.0,2.0,2.0,2.0,2.0,1.0,2.0,2.0,2.0,2.0,2.0,1.0,2.0,2.0,2.0,2.0,2.0,1.0,2.0,2.0,2.0,2.0,2.0,1.0,2.0,2.0,2.0,2.0,2.0,1.0,2.0,2.0,2.0,2.0,2.0,1.0])
    (rev' @(OR.Array 4 Double) (costVolume 0 2 arrL) arrR)

test_disparitySmall :: Assertion
test_disparitySmall = do
  let arrL :: ADReady r => TensorOf 4 r
      arrL = tfromList0N [1, 2, 3, 2] [0.2, 0.5, -0.2, 0.0001, 0.44, 0.9, -0.9, 0.00001, -0.22, -0.28, -0.34, -0.40]
      arrR :: ADReady r => TensorOf 4 r
      arrR = tfromList0N [1, 2, 3, 2] [-0.40,-0.22,-0.28,-0.34, 0.22360679774997896,0.35355339059327373,0.20412414523193154,0.5, -0.35355339059327373,0.16666666666666666,0.17677669529663687,-0.25]
      arrO = value @(OR.Array 4 Double) (uncurry $ costVolume 0 4) (arrL, arrR)
      arrDL = revDt (\aL -> costVolume 0 2 aL (tconstant arrR)) arrL arrO
      arrDR = revDt (\aR -> costVolume 0 2 (tconstant arrL) aR) arrR arrO
  assertEqualUpToEpsilon 1e-7
    (OR.fromList [1,4,3,2] [1.7041241452319316,1.21999,0.21355339059327375,0.7867666666666666,0.7331698975466578,0.6964466094067263,1.1,1.1041141452319316,0.42000000000000004,0.3536533905932737,0.78,1.253169897546658,1.1,0.50001,0.42000000000000004,0.2801,0.78,1.3,1.1,0.50001,0.42000000000000004,0.2801,0.78,1.3])
    arrO
  assertEqualUpToEpsilon' 1e-7
    (OR.fromList [1,2,3,2] [-2.0,-1.0,-2.0,-1.0,-2.0,-1.0,2.0,1.0,-2.0,1.0,2.0,1.0])
    (rev' @(OR.Array 4 Double) (costVolume 0 4 arrL) arrR)
  assertEqualUpToEpsilon 1e-7
    (OR.fromList [1,2,3,2] [5.004124145231932,3.3241241452319317,-1.0464466094067264,1.7006200572599404,3.0731698975466575,4.5496165069533845,-5.004124145231932,-1.3240841452319316,-1.0464466094067264,-0.9933132760733929,-3.0731698975466575,-4.5496165069533845])
    arrDL
  assertEqualUpToEpsilon 1e-7
    (OR.fromList [1,2,3,2] [-2.808238290463863,-1.21999,-0.5672067811865474,-0.7867666666666666,-1.986339795093316,-0.6964466094067263,2.808238290463863,1.21999,-0.5672067811865474,0.7867666666666666,1.986339795093316,0.6964466094067263])
   arrDR
  assertEqualUpToEpsilon' 1e-7
    (OR.fromList [1,2,3,2] [-1.0,0.0,-1.0,0.0,-1.0,0.0,1.0,0.0,-1.0,0.0,1.0,0.0])
    (rev' @(OR.Array 4 Double) (costVolume 1 4 arrL) arrR)
  assertEqualUpToEpsilon' 1e-7
    (OR.fromList [1,2,3,2] [2.0,2.0,-2.0,2.0,2.0,2.0,-2.0,2.0,-2.0,-2.0,-2.0,-2.0])
    (rev' @(OR.Array 4 Double) (\aL -> costVolume 2 2 aL arrR) arrL)
  assertEqualUpToEpsilon' 1e-7
    (OR.fromList [1,2,3,2] [-1.0,0.0,-1.0,0.0,-1.0,0.0,1.0,0.0,-1.0,0.0,1.0,0.0])
    (rev' @(OR.Array 4 Double) (costVolume 1 2 arrL) arrR)
