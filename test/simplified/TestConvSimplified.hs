{-# LANGUAGE OverloadedLists #-}
{-# OPTIONS_GHC -fno-cse #-}
{-# OPTIONS_GHC -Wno-incomplete-uni-patterns #-}
-- | Tests of convolution and disparity cost volume defined using the build
-- operation of ranked tensors.
module TestConvSimplified (testTrees) where

import Prelude

import Control.Exception (assert)
import Data.Array.RankedS qualified as OR
import Data.IntMap.Strict qualified as IM
import Data.Vector.Generic qualified as V
import GHC.Exts (IsList (..))
import GHC.TypeLits (KnownNat)
import Test.Tasty
import Test.Tasty.HUnit hiding (assert)

import Data.Array.Nested qualified as Nested
import Data.Array.Nested.Internal.Ranked qualified as Nested.Internal

import HordeAd
import HordeAd.Core.AstEnv
import HordeAd.Core.AstFreshId (rankedHVector, resetVarCounter)
import HordeAd.Core.TensorAst
import HordeAd.Internal.BackendOX (ORArray)
import HordeAd.Internal.OrthotopeOrphanInstances (FlipR (..))

import CrossTesting

testTrees :: [TestTree]
testTrees =
  [ testCase "KonstG0Rev" testKonstG0Rev
  , testCase "KonstG0Tiny1" testKonstG0Tiny1
  , testCase "KonstG0TinyS" testKonstG0TinyS
  , testCase "KonstG0TinyA" testKonstG0TinyA
  , testCase "KonstG0LittleA" testKonstG0LittleA
  , testCase "Replicate0RevLaborious" testReplicate0RevLaborious
  , testCase "Replicate0Tiny1Laborious" testReplicate0Tiny1Laborious
  , testCase "Replicate0TinySLaborious" testReplicate0TinySLaborious
  , testCase "Replicate0TinyALaborious" testReplicate0TinyALaborious
  , testCase "Replicate0LittleALaborious" testReplicate0LittleALaborious
  , testCase "Konst5LittleBLaborious" testKonst5LittleBLaborious
  , testCase "Konst5LittleCLaborious" testKonst5LittleCLaborious
  , testCase "Konst5BigBLaborious" testKonst5BigBLaborious
  , testCase "KonstNotBigBLaborious" testKonstNotBigBLaborious
  , testCase "Konst5BigCLaborious" testKonst5BigCLaborious
  , testCase "KonstNotBigCLaborious" testKonstNotBigCLaborious
  , testCase "Konst5LittleBLaborious128b" testKonst5LittleBLaborious128b
  , testCase "Konst5LittleCLaborious128b" testKonst5LittleCLaborious128b
  , testCase "Konst5BigBLaborious128b" testKonst5BigBLaborious128b
  , testCase "KonstNotBigBLaborious128b" testKonstNotBigBLaborious128b
  , testCase "Konst5BigCLaborious128b" testKonst5BigCLaborious128b
  , testCase "KonstNotBigCLaborious128b" testKonstNotBigCLaborious128b
  , testCase "Konst5LittleBLaborious128c" testKonst5LittleBLaborious128c
  , testCase "Konst5LittleCLaborious128c" testKonst5LittleCLaborious128c
  , testCase "Konst5BigBLaborious128c" testKonst5BigBLaborious128c
  , testCase "KonstNotBigBLaborious128c" testKonstNotBigBLaborious128c
  , testCase "Konst5BigCLaborious128c" testKonst5BigCLaborious128c
  , testCase "KonstNotBigCLaborious128c" testKonstNotBigCLaborious128c
  , testCase "Konst5LittleBLaborious128bc" testKonst5LittleBLaborious128bc
  , testCase "Konst5LittleCLaborious128bc" testKonst5LittleCLaborious128bc
  , testCase "Konst5BigBLaborious128bc" testKonst5BigBLaborious128bc
  , testCase "KonstNotBigBLaborious128cb" testKonstNotBigBLaborious128cb
  , testCase "Konst5BigCLaborious128cb" testKonst5BigCLaborious128cb
  , testCase "KonstNotBigCLaborious128cb" testKonstNotBigCLaborious128cb
  , testCase "disparityKonst" test_disparityKonst
  , testCase "disparityKonst2" test_disparityKonst2
  , testCase "disparitySmall" test_disparitySmall
  , testCase "Conv2dUnpaddedPP" testConv2dUnpaddedPP
  , testCase "Conv2dUnpadded2PP" testConv2dUnpadded2PP
  , testCase "Conv2dUnpadded3PP" testConv2dUnpadded3PP
  ]

-- The examples reproduce and transformed in this file are borrowed
-- from https://github.com/benl23x5/adops.
-- Here it's defined using ranked tensors with sized indexes.

-- Test comments are currently outdated. The first implementation
-- is currently correct only by chance (and this may change).
-- The "laborious" implementation is the solid one.

-- | Unpadded full convolution,
--   where the output size is the same as the input size.
conv2d
  :: (ADReady ranked, GoodScalar r)
  => ranked r 4 -> ranked r 4 -> ranked r 4
conv2d arrK arrA =
  let [nImgs, nCinpA, nAh, nAw] = rshape arrA
      [nCoutK, nCinpK, nKh, nKw] = rshape arrK
      nCinp = assert (nCinpA == nCinpK) nCinpA
      shB = [nImgs, nCoutK, nAh, nAw]
      shK1 = [1, nCinp, nKh, nKw]
  in rbuild shB $ \case
    [iImg, iCout, iBh, iBw] ->
      let arrAt = slicezF shK1 arrA [iImg, 0, iBh, iBw]
          arrKt = slicezF shK1 arrK [iCout, 0, 0, 0]
      in rdot0 arrAt arrKt
    _ -> error "conv2d: impossible pattern needlessly required"

-- | Slice a section out of a tensor,
--   given a base offset and shape of the section.
--
--   If the slice extends out side the source array then the corresponding
--   elements are set to zero.
slicezF :: forall ranked n r. (ADReady ranked, GoodScalar r, KnownNat n)
        => IShR n -> ranked r n -> IndexOf ranked n -> ranked r n
slicezF shOut d ixBase =
  rbuild shOut $ \ixResult ->
    rindex @ranked @r @n @0 d (zipWith_Index (+) ixBase ixResult)
      -- rindex0 would not require a single type application here

conv2d1
  :: (ADReady ranked, GoodScalar r, Differentiable r)
  => ranked r 4 -> ranked r 4
conv2d1 = conv2d $ rconst $ Nested.Internal.rfromListPrimLinear (fromList [1, 1, 1, 1]) [-0.2]

conv2dA
  :: (ADReady ranked, GoodScalar r, Differentiable r)
  => ranked r 4 -> ranked r 4
conv2dA = conv2d $ rconst $ Nested.Internal.rfromListPrimLinear (fromList [1, 2, 1, 1]) [-0.2, 25.0003]

conv2dB
  :: (ADReady ranked, GoodScalar r, Differentiable r)
  => ranked r 4 -> ranked r 4
conv2dB = conv2d $ rconst $ runFlipR t16b

testKonstG0Rev :: Assertion
testKonstG0Rev =
  assertEqualUpToEpsilon1 1e-4
    (OR.fromList [2, 2, 2, 2] [18.1,29.1,32.1,40.1,582932.0,582934.99432,582597.1,582625.8943200001,18.1,29.1,32.1,40.1,582932.0,582934.99432,582597.1,582625.8943200001])
    (rev @_ @(TKR Double 4) conv2dB (rzero [2, 2, 2, 2]))

testKonstG0Tiny1 :: Assertion
testKonstG0Tiny1 =
  assertEqualUpToEpsilon' 1e-10
    (OR.fromList [1, 1, 1, 1] [-0.2])
    (rev' @Double @4 conv2d1 (FlipR $ Nested.rtoOrthotope $ runFlipR $ rzero [1, 1, 1, 1]))

testKonstG0TinyS :: Assertion
testKonstG0TinyS =
  assertEqualUpToEpsilon' 1e-10
    (OR.fromList [1, 1, 1, 1] [582665.99432])
    (rev' @Double @4
          (conv2d $ rconst $ runFlipR $ rreplicate0N [1, 1, 1, 1] (rsum0 t16b))
          (FlipR $ OR.fromList [1, 1, 1, 1] [0]))

testKonstG0TinyA :: Assertion
testKonstG0TinyA =
  assertEqualUpToEpsilon' 1e-10
    (OR.fromList [1, 2, 1, 1] [-0.2,25.0003])
    (rev' @Double @4 conv2dA (FlipR $ Nested.rtoOrthotope $ runFlipR $ rzero [1, 2, 1, 1]))

testKonstG0LittleA :: Assertion
testKonstG0LittleA =
  assertEqualUpToEpsilon' 1e-10
    (OR.fromList [2, 2, 2, 2] [-0.2,-0.2,-0.2,-0.2,25.0003,25.0003,25.0003,25.0003,-0.2,-0.2,-0.2,-0.2,25.0003,25.0003,25.0003,25.0003])
    (rev' @Double @4 conv2dA (FlipR $ Nested.rtoOrthotope $ runFlipR $ rzero [2, 2, 2, 2]))


-- * A laborious version

-- The implementation is in HordeAd.External.CommonRankedOps.
--
-- Some tests are copied from above and the required test results are
-- the same.

conv2d1Laborious
  :: (ADReady ranked, GoodScalar r, Differentiable r)
  => ranked r 4 -> ranked r 4
conv2d1Laborious = conv2dUnpadded $ rconst $ Nested.Internal.rfromListPrimLinear (fromList [1, 1, 1, 1]) [-0.2]

conv2dALaborious
  :: (ADReady ranked, GoodScalar r, Differentiable r)
  => ranked r 4 -> ranked r 4
conv2dALaborious =
  conv2dUnpadded $ rconst $ Nested.Internal.rfromListPrimLinear (fromList [1, 2, 1, 1]) [-0.2, 25.0003]

conv2dBLaborious
  :: (ADReady ranked, GoodScalar r, Differentiable r)
  => ranked r 4 -> ranked r 4
conv2dBLaborious = conv2dUnpadded $ rconst $ runFlipR t16b

conv2dCLaborious
  :: (ADReady ranked, GoodScalar r, Differentiable r)
  => ranked r 4 -> ranked r 4
conv2dCLaborious = flip conv2dUnpadded $ rconst $ runFlipR t16b

conv2dBLaborious128b
  :: (ADReady ranked, GoodScalar r, Differentiable r)
  => ranked r 4 -> ranked r 4
conv2dBLaborious128b = conv2dUnpadded $ rconst $ Nested.rfromOrthotope SNat $ runFlipR t128b

conv2dCLaborious128b
  :: (ADReady ranked, GoodScalar r, Differentiable r)
  => ranked r 4 -> ranked r 4
conv2dCLaborious128b = flip conv2dUnpadded $ rconst $ Nested.rfromOrthotope SNat $ runFlipR t128b

conv2dBLaborious128c
  :: (ADReady ranked, GoodScalar r, Differentiable r)
  => ranked r 4 -> ranked r 4
conv2dBLaborious128c = conv2dUnpadded $ rconst $ Nested.rfromOrthotope SNat $ runFlipR t128c

conv2dCLaborious128c
  :: (ADReady ranked, GoodScalar r, Differentiable r)
  => ranked r 4 -> ranked r 4
conv2dCLaborious128c = flip conv2dUnpadded $ rconst $ Nested.rfromOrthotope SNat $ runFlipR t128c

testReplicate0RevLaborious :: Assertion
testReplicate0RevLaborious =
  assertEqualUpToEpsilon1 1e-4
    (OR.fromList [2, 2, 2, 2] [18.1,29.1,32.1,40.1,582932.0,582934.99432,582597.1,582625.8943200001,18.1,29.1,32.1,40.1,582932.0,582934.99432,582597.1,582625.8943200001])
    (rev @_ @(TKR Double 4) conv2dBLaborious (rzero [2, 2, 2, 2]))

testReplicate0Tiny1Laborious :: Assertion
testReplicate0Tiny1Laborious =
  assertEqualUpToEpsilon' 1e-10
    (OR.fromList [1, 1, 1, 1] [-0.2])
    (rev' @Double @4 conv2d1Laborious (FlipR $ Nested.rtoOrthotope $ runFlipR $ rzero [1, 1, 1, 1]))

testReplicate0TinySLaborious :: Assertion
testReplicate0TinySLaborious =
  assertEqualUpToEpsilon' 1e-10
    (OR.fromList [1, 1, 1, 1] [582665.99432])
    (rev' @Double @4
          (conv2dUnpadded $ rconst $ runFlipR $ rreplicate0N [1, 1, 1, 1] (rsum0 t16b))
          (FlipR $ OR.fromList [1, 1, 1, 1] [0]))

testReplicate0TinyALaborious :: Assertion
testReplicate0TinyALaborious =
  assertEqualUpToEpsilon' 1e-10
    (OR.fromList [1, 2, 1, 1] [-0.2,25.0003])
    (rev' @Double @4 conv2dALaborious (FlipR $ Nested.rtoOrthotope $ runFlipR $ rzero [1, 2, 1, 1]))

testReplicate0LittleALaborious :: Assertion
testReplicate0LittleALaborious =
  assertEqualUpToEpsilon' 1e-10
    (OR.fromList [2, 2, 2, 2] [-0.2,-0.2,-0.2,-0.2,25.0003,25.0003,25.0003,25.0003,-0.2,-0.2,-0.2,-0.2,25.0003,25.0003,25.0003,25.0003])
    (rev' @Double @4 conv2dALaborious (FlipR $ Nested.rtoOrthotope $ runFlipR $ rzero [2, 2, 2, 2]))

-- with data t16

testKonst5LittleBLaborious :: Assertion
testKonst5LittleBLaborious =
  assertEqualUpToEpsilon' 1e-8
    (OR.fromList [2, 2, 2, 2] [18.1,29.1,32.1,40.1,582932.0,582934.99432,582597.1,582625.8943200001,18.1,29.1,32.1,40.1,582932.0,582934.99432,582597.1,582625.8943200001])
    (rev' @Double @4 conv2dBLaborious (FlipR $ Nested.rtoOrthotope $ runFlipR $ rreplicate0N [2, 2, 2, 2] 5))

testKonst5LittleCLaborious :: Assertion
testKonst5LittleCLaborious =
  assertEqualUpToEpsilon' 1e-8
    (OR.fromList [2, 2, 2, 2] [40.1,8.0,11.0,-3.0,582625.89432,28.79432,-309.09999999999997,25.8,40.1,8.0,11.0,-3.0,582625.89432,28.79432,-309.09999999999997,25.8])
    (rev' @Double @4 conv2dCLaborious (FlipR $ Nested.rtoOrthotope $ runFlipR $ rreplicate0N [2, 2, 2, 2] 5))

testKonst5BigBLaborious :: Assertion
testKonst5BigBLaborious =
  assertEqualUpToEpsilon' 1e-8
    (OR.fromList [3, 2, 4, 2] [18.1,29.1,32.1,40.1,32.1,40.1,32.1,40.1,582932.0,582934.99432,582597.1,582625.8943200001,582597.1,582625.8943200001,582597.1,582625.8943200001,18.1,29.1,32.1,40.1,32.1,40.1,32.1,40.1,582932.0,582934.99432,582597.1,582625.8943200001,582597.1,582625.8943200001,582597.1,582625.8943200001,18.1,29.1,32.1,40.1,32.1,40.1,32.1,40.1,582932.0,582934.99432,582597.1,582625.8943200001,582597.1,582625.8943200001,582597.1,582625.8943200001])
    (rev' @Double @4 conv2dBLaborious (FlipR $ Nested.rtoOrthotope $ runFlipR $ rreplicate0N [3, 2, 4, 2] 5))

-- The gradient is the same as above, because one argument is the same
-- and convolution is linear.
testKonstNotBigBLaborious :: Assertion
testKonstNotBigBLaborious =
  assertEqualUpToEpsilon' 1e-8
    (OR.fromList [3, 2, 4, 2] [18.1,29.1,32.1,40.1,32.1,40.1,32.1,40.1,582932.0,582934.99432,582597.1,582625.8943200001,582597.1,582625.8943200001,582597.1,582625.8943200001,18.1,29.1,32.1,40.1,32.1,40.1,32.1,40.1,582932.0,582934.99432,582597.1,582625.8943200001,582597.1,582625.8943200001,582597.1,582625.8943200001,18.1,29.1,32.1,40.1,32.1,40.1,32.1,40.1,582932.0,582934.99432,582597.1,582625.8943200001,582597.1,582625.8943200001,582597.1,582625.8943200001])
    (rev' @Double @4 conv2dBLaborious
          (FlipR $ Nested.rtoOrthotope $ runFlipR $ rfromList0N [3, 2, 4, 2] (map rscalar [37, 36 .. -10])))

testKonst5BigCLaborious :: Assertion
testKonst5BigCLaborious =
  assertEqualUpToEpsilon' 1e-8
    (OR.fromList [3, 2, 4, 2] [40.1,8.0,11.0,-3.0,0.0,0.0,0.0,0.0,582625.8943200001,28.794320000000003,-309.09999999999997,25.8,0.0,0.0,0.0,0.0,40.1,8.0,11.0,-3.0,0.0,0.0,0.0,0.0,582625.8943200001,28.794320000000003,-309.09999999999997,25.8,0.0,0.0,0.0,0.0,40.1,8.0,11.0,-3.0,0.0,0.0,0.0,0.0,582625.8943200001,28.794320000000003,-309.09999999999997,25.8,0.0,0.0,0.0,0.0])
    (rev' @Double @4 conv2dCLaborious (FlipR $ Nested.rtoOrthotope $ runFlipR $ rreplicate0N [3, 2, 4, 2] 5))

-- The gradient is the same as above, because one argument is the same
-- and convolution is linear.
testKonstNotBigCLaborious :: Assertion
testKonstNotBigCLaborious =
  assertEqualUpToEpsilon' 1e-8
    (OR.fromList [3, 2, 4, 2] [40.1,8.0,11.0,-3.0,0.0,0.0,0.0,0.0,582625.8943200001,28.794320000000003,-309.09999999999997,25.8,0.0,0.0,0.0,0.0,40.1,8.0,11.0,-3.0,0.0,0.0,0.0,0.0,582625.8943200001,28.794320000000003,-309.09999999999997,25.8,0.0,0.0,0.0,0.0,40.1,8.0,11.0,-3.0,0.0,0.0,0.0,0.0,582625.8943200001,28.794320000000003,-309.09999999999997,25.8,0.0,0.0,0.0,0.0])
    (rev' @Double @4 conv2dCLaborious
          (FlipR $ Nested.rtoOrthotope $ runFlipR $ rfromList0N [3, 2, 4, 2] (map rscalar [37, 36 .. -10])))

-- with data t128b

testKonst5LittleBLaborious128b :: Assertion
testKonst5LittleBLaborious128b =
  assertEqualUpToEpsilon' 1e-8
    (OR.fromList [2, 2, 2, 2] [112.3003,251.5006,209.49462,482.69492000000014,3.000000000000032,65.90000000000003,164.10000000000002,365.89432000010004,112.3003,251.5006,209.49462,482.69492000000014,3.000000000000032,65.90000000000003,164.10000000000002,365.89432000010004])
    (rev' @Double @4 conv2dBLaborious128b (FlipR $ Nested.rtoOrthotope $ runFlipR $ rreplicate0N [2, 2, 2, 2] 5))

testKonst5LittleCLaborious128b :: Assertion
testKonst5LittleCLaborious128b =
  assertEqualUpToEpsilon' 1e-8
    (OR.fromList [2, 2, 2, 2] [1627.8210700004993,1571.2321300004994,1132.9261600005002,1188.6375200005,2725.0393200008984,1831.7390200008983,2551.139320000898,1660.8390200008987,1627.8210700004993,1571.2321300004994,1132.9261600005002,1188.6375200005,2725.0393200008984,1831.7390200008983,2551.139320000898,1660.8390200008987])
    (rev' @Double @4 conv2dCLaborious128b (FlipR $ Nested.rtoOrthotope $ runFlipR $ rreplicate0N [2, 2, 2, 2] 5))

testKonst5BigBLaborious128b :: Assertion
testKonst5BigBLaborious128b =
  assertEqualUpToEpsilon' 1e-8
    (OR.fromList [3, 2, 4, 2] [112.3003,251.5006,209.49462,482.69492000000014,229.49462000000003,610.5892400000002,56.58894000000004,580.6778800001001,3.000000000000032,65.90000000000003,164.10000000000002,365.89432000010004,667.2003000000001,1060.8778800002,893.3003,1465.6665200003993,112.3003,251.5006,209.49462,482.69492000000014,229.49462000000003,610.5892400000002,56.58894000000004,580.6778800001001,3.000000000000032,65.90000000000003,164.10000000000002,365.89432000010004,667.2003000000001,1060.8778800002,893.3003,1465.6665200003993,112.3003,251.5006,209.49462,482.69492000000014,229.49462000000003,610.5892400000002,56.58894000000004,580.6778800001001,3.000000000000032,65.90000000000003,164.10000000000002,365.89432000010004,667.2003000000001,1060.8778800002,893.3003,1465.6665200003993])
    (rev' @Double @4 conv2dBLaborious128b (FlipR $ Nested.rtoOrthotope $ runFlipR $ rreplicate0N [3, 2, 4, 2] 5))

-- The gradient is the same as above, because one argument is the same
-- and convolution is linear.
testKonstNotBigBLaborious128b :: Assertion
testKonstNotBigBLaborious128b =
  assertEqualUpToEpsilon' 1e-8
    (OR.fromList [3, 2, 4, 2] [112.3003,251.5006,209.49462,482.69492000000014,229.49462000000003,610.5892400000002,56.58894000000004,580.6778800001001,3.000000000000032,65.90000000000003,164.10000000000002,365.89432000010004,667.2003000000001,1060.8778800002,893.3003,1465.6665200003993,112.3003,251.5006,209.49462,482.69492000000014,229.49462000000003,610.5892400000002,56.58894000000004,580.6778800001001,3.000000000000032,65.90000000000003,164.10000000000002,365.89432000010004,667.2003000000001,1060.8778800002,893.3003,1465.6665200003993,112.3003,251.5006,209.49462,482.69492000000014,229.49462000000003,610.5892400000002,56.58894000000004,580.6778800001001,3.000000000000032,65.90000000000003,164.10000000000002,365.89432000010004,667.2003000000001,1060.8778800002,893.3003,1465.6665200003993])
    (rev' @Double @4 conv2dBLaborious128b
          (FlipR $ Nested.rtoOrthotope $ runFlipR $ rfromList0N [3, 2, 4, 2] (map rscalar [37, 36 .. -10])))

testKonst5BigCLaborious128b :: Assertion
testKonst5BigCLaborious128b =
  assertEqualUpToEpsilon' 1e-8
    (OR.fromList [3, 2, 4, 2] [1627.8210700004993,1571.2321300004994,1132.9261600005002,1188.6375200005,675.7488800003999,828.6545600004001,215.6659200003,388.5716000003,2725.0393200008984,1831.7390200008983,2551.139320000898,1660.8390200008987,1903.750080000699,1174.5497800006997,854.9778800004001,628.8778800004001,1627.8210700004993,1571.2321300004994,1132.9261600005002,1188.6375200005,675.7488800003999,828.6545600004001,215.6659200003,388.5716000003,2725.0393200008984,1831.7390200008983,2551.139320000898,1660.8390200008987,1903.750080000699,1174.5497800006997,854.9778800004001,628.8778800004001,1627.8210700004993,1571.2321300004994,1132.9261600005002,1188.6375200005,675.7488800003999,828.6545600004001,215.6659200003,388.5716000003,2725.0393200008984,1831.7390200008983,2551.139320000898,1660.8390200008987,1903.750080000699,1174.5497800006997,854.9778800004001,628.8778800004001])
    (rev' @Double @4 conv2dCLaborious128b (FlipR $ Nested.rtoOrthotope $ runFlipR $ rreplicate0N [3, 2, 4, 2] 5))

-- The gradient is the same as above, because one argument is the same
-- and convolution is linear.
testKonstNotBigCLaborious128b :: Assertion
testKonstNotBigCLaborious128b =
  assertEqualUpToEpsilon' 1e-8
    (OR.fromList [3, 2, 4, 2] [1627.8210700004993,1571.2321300004994,1132.9261600005002,1188.6375200005,675.7488800003999,828.6545600004001,215.6659200003,388.5716000003,2725.0393200008984,1831.7390200008983,2551.139320000898,1660.8390200008987,1903.750080000699,1174.5497800006997,854.9778800004001,628.8778800004001,1627.8210700004993,1571.2321300004994,1132.9261600005002,1188.6375200005,675.7488800003999,828.6545600004001,215.6659200003,388.5716000003,2725.0393200008984,1831.7390200008983,2551.139320000898,1660.8390200008987,1903.750080000699,1174.5497800006997,854.9778800004001,628.8778800004001,1627.8210700004993,1571.2321300004994,1132.9261600005002,1188.6375200005,675.7488800003999,828.6545600004001,215.6659200003,388.5716000003,2725.0393200008984,1831.7390200008983,2551.139320000898,1660.8390200008987,1903.750080000699,1174.5497800006997,854.9778800004001,628.8778800004001])
    (rev' @Double @4 conv2dCLaborious128b
          (FlipR $ Nested.rtoOrthotope $ runFlipR $ rfromList0N [3, 2, 4, 2] (map rscalar [37, 36 .. -10])))

-- with data t128c

testKonst5LittleBLaborious128c :: Assertion
testKonst5LittleBLaborious128c =
  assertEqualUpToEpsilon' 1e-8
    (OR.fromList [2, 2, 2, 2] [54.100300000000004,111.20060000000001,119.09462,270.29492000000005,58.2,140.3,90.4,212.4,54.100300000000004,111.20060000000001,119.09462,270.29492000000005,58.2,140.3,90.4,212.4])
    (rev' @Double @4 conv2dBLaborious128c (FlipR $ Nested.rtoOrthotope $ runFlipR $ rreplicate0N [2, 2, 2, 2] 5))

testKonst5LittleCLaborious128c :: Assertion
testKonst5LittleCLaborious128c =
  assertEqualUpToEpsilon' 1e-8
    (OR.fromList [2, 2, 2, 2] [2640.8154000007976,1836.3264600007988,2412.414800000798,1662.026160000799,1712.044990000598,1566.644690000599,1445.5506800005985,1358.3503800005992,2640.8154000007976,1836.3264600007988,2412.414800000798,1662.026160000799,1712.044990000598,1566.644690000599,1445.5506800005985,1358.3503800005992])
    (rev' @Double @4 conv2dCLaborious128c (FlipR $ Nested.rtoOrthotope $ runFlipR $ rreplicate0N [2, 2, 2, 2] 5))

testKonst5BigBLaborious128c :: Assertion
testKonst5BigBLaborious128c =
  assertEqualUpToEpsilon' 1e-8
    (OR.fromList [3, 2, 4, 2] [54.100300000000004,111.20060000000001,119.09462,270.29492000000005,109.09462000000002,318.19492,174.08894000000004,477.28924000000006,58.2,140.3,90.4,212.4,120.4,292.39432000000005,-117.5,103.38864000010005,54.100300000000004,111.20060000000001,119.09462,270.29492000000005,109.09462000000002,318.19492,174.08894000000004,477.28924000000006,58.2,140.3,90.4,212.4,120.4,292.39432000000005,-117.5,103.38864000010005,54.100300000000004,111.20060000000001,119.09462,270.29492000000005,109.09462000000002,318.19492,174.08894000000004,477.28924000000006,58.2,140.3,90.4,212.4,120.4,292.39432000000005,-117.5,103.38864000010005])
    (rev' @Double @4 conv2dBLaborious128c (FlipR $ Nested.rtoOrthotope $ runFlipR $ rreplicate0N [3, 2, 4, 2] 5))

-- The gradient is the same as above, because one argument is the same
-- and convolution is linear.
testKonstNotBigBLaborious128c :: Assertion
testKonstNotBigBLaborious128c =
  assertEqualUpToEpsilon' 1e-8
    (OR.fromList [3, 2, 4, 2] [54.100300000000004,111.20060000000001,119.09462,270.29492000000005,109.09462000000002,318.19492,174.08894000000004,477.28924000000006,58.2,140.3,90.4,212.4,120.4,292.39432000000005,-117.5,103.38864000010005,54.100300000000004,111.20060000000001,119.09462,270.29492000000005,109.09462000000002,318.19492,174.08894000000004,477.28924000000006,58.2,140.3,90.4,212.4,120.4,292.39432000000005,-117.5,103.38864000010005,54.100300000000004,111.20060000000001,119.09462,270.29492000000005,109.09462000000002,318.19492,174.08894000000004,477.28924000000006,58.2,140.3,90.4,212.4,120.4,292.39432000000005,-117.5,103.38864000010005])
    (rev' @Double @4 conv2dBLaborious128c
          (FlipR $ Nested.rtoOrthotope $ runFlipR $ rfromList0N [3, 2, 4, 2] (map rscalar [37, 36 .. -10])))

testKonst5BigCLaborious128c :: Assertion
testKonst5BigCLaborious128c =
  assertEqualUpToEpsilon' 1e-8
    (OR.fromList [3, 2, 4, 2] [2640.8154000007976,1836.3264600007988,2412.414800000798,1662.026160000799,2121.6375200006987,1436.2432000006995,1953.5375200006988,1258.1432000006998,1712.044990000598,1566.644690000599,1445.5506800005985,1358.3503800005992,1279.150680000599,1224.1503800005996,987.1677200004992,962.1674200005002,2640.8154000007976,1836.3264600007988,2412.414800000798,1662.026160000799,2121.6375200006987,1436.2432000006995,1953.5375200006988,1258.1432000006998,1712.044990000598,1566.644690000599,1445.5506800005985,1358.3503800005992,1279.150680000599,1224.1503800005996,987.1677200004992,962.1674200005002,2640.8154000007976,1836.3264600007988,2412.414800000798,1662.026160000799,2121.6375200006987,1436.2432000006995,1953.5375200006988,1258.1432000006998,1712.044990000598,1566.644690000599,1445.5506800005985,1358.3503800005992,1279.150680000599,1224.1503800005996,987.1677200004992,962.1674200005002])
    (rev' @Double @4 conv2dCLaborious128c (FlipR $ Nested.rtoOrthotope $ runFlipR $ rreplicate0N [3, 2, 4, 2] 5))

-- The gradient is the same as above, because one argument is the same
-- and convolution is linear.
testKonstNotBigCLaborious128c :: Assertion
testKonstNotBigCLaborious128c =
  assertEqualUpToEpsilon' 1e-8
    (OR.fromList [3, 2, 4, 2] [2640.8154000007976,1836.3264600007988,2412.414800000798,1662.026160000799,2121.6375200006987,1436.2432000006995,1953.5375200006988,1258.1432000006998,1712.044990000598,1566.644690000599,1445.5506800005985,1358.3503800005992,1279.150680000599,1224.1503800005996,987.1677200004992,962.1674200005002,2640.8154000007976,1836.3264600007988,2412.414800000798,1662.026160000799,2121.6375200006987,1436.2432000006995,1953.5375200006988,1258.1432000006998,1712.044990000598,1566.644690000599,1445.5506800005985,1358.3503800005992,1279.150680000599,1224.1503800005996,987.1677200004992,962.1674200005002,2640.8154000007976,1836.3264600007988,2412.414800000798,1662.026160000799,2121.6375200006987,1436.2432000006995,1953.5375200006988,1258.1432000006998,1712.044990000598,1566.644690000599,1445.5506800005985,1358.3503800005992,1279.150680000599,1224.1503800005996,987.1677200004992,962.1674200005002])
    (rev' @Double @4 conv2dCLaborious128c
          (FlipR $ Nested.rtoOrthotope $ runFlipR $ rfromList0N [3, 2, 4, 2] (map rscalar [37, 36 .. -10])))

-- with data t128b and t128c

testKonst5LittleBLaborious128bc :: Assertion
testKonst5LittleBLaborious128bc =
  assertEqualUpToEpsilonShort 1e-8
    (OR.fromList [2,2,8,4] [112.3003,251.5006,417.79492000000005,494.89491000000015,209.49462,482.69492000000014,778.9778800001002,952.0721900001002,229.49462000000003,610.5892400000002,1113.1722000001,1412.1551500001997,56.58894000000004,580.6778800001001,1234.1494800003,1627.8210700004993,56.58894000000004,580.6778800001001,1234.1494800003,1627.8210700004993,56.58894000000004,580.6778800001001,1234.1494800003,1627.8210700004993,56.58894000000004,580.6778800001001,1234.1494800003,1627.8210700004993,56.58894000000004,580.6778800001001,1234.1494800003,1627.8210700004993,3.000000000000032,65.90000000000003,106.90000000000003,173.90000000000006,164.10000000000002,365.89432000010004,593.1946200001,821.2892400002004,667.2003000000001,1060.8778800002,1500.2781800001994,1870.0614400004986,893.3003,1465.6665200003993,2156.3671200003987,2725.039320000898,893.3003,1465.6665200003993,2156.3671200003987,2725.039320000898,893.3003,1465.6665200003993,2156.3671200003987,2725.039320000898,893.3003,1465.6665200003993,2156.3671200003987,2725.039320000898,893.3003,1465.6665200003993,2156.3671200003987,2725.039320000898,112.3003,251.5006,417.79492000000005,494.89491000000015,209.49462,482.69492000000014,778.9778800001002,952.0721900001002,229.49462000000003,610.5892400000002,1113.1722000001,1412.1551500001997,56.58894000000004,580.6778800001001,1234.1494800003,1627.8210700004993,56.58894000000004,580.6778800001001,1234.1494800003,1627.8210700004993,56.58894000000004,580.6778800001001,1234.1494800003,1627.8210700004993,56.58894000000004,580.6778800001001,1234.1494800003,1627.8210700004993,56.58894000000004,580.6778800001001,1234.1494800003,1627.8210700004993,3.000000000000032,65.90000000000003,106.90000000000003,173.90000000000006,164.10000000000002,365.89432000010004,593.1946200001,821.2892400002004,667.2003000000001,1060.8778800002,1500.2781800001994,1870.0614400004986,893.3003,1465.6665200003993,2156.3671200003987,2725.039320000898,893.3003,1465.6665200003993,2156.3671200003987,2725.039320000898,893.3003,1465.6665200003993,2156.3671200003987,2725.039320000898,893.3003,1465.6665200003993,2156.3671200003987,2725.039320000898,893.3003,1465.6665200003993,2156.3671200003987,2725.039320000898])
    (rev' @Double @4 conv2dBLaborious128b t128c)

testKonst5LittleCLaborious128bc :: Assertion
testKonst5LittleCLaborious128bc =
  assertEqualUpToEpsilonShort 1e-8
    (OR.fromList [2,2,8,4] [1627.8210700004993,1571.2321300004994,1047.1431900004002,393.6715900002,1132.9261600005002,1188.6375200005,803.7488800004002,316.57160000019996,675.7488800003999,828.6545600004001,577.7659200003001,220.57728000019998,215.6659200003,388.5716000003,245.5772800002,94.68864000010001,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,2725.0393200008984,1831.7390200008983,1259.3728000004999,568.6722000005001,2551.139320000898,1660.8390200008987,1151.3728000005,501.6722000005,1903.750080000699,1174.5497800006997,803.9778800004001,340.5775800004001,854.9778800004001,628.8778800004001,450.1892400002,198.8889400002,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1627.8210700004993,1571.2321300004994,1047.1431900004002,393.6715900002,1132.9261600005002,1188.6375200005,803.7488800004002,316.57160000019996,675.7488800003999,828.6545600004001,577.7659200003001,220.57728000019998,215.6659200003,388.5716000003,245.5772800002,94.68864000010001,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,2725.0393200008984,1831.7390200008983,1259.3728000004999,568.6722000005001,2551.139320000898,1660.8390200008987,1151.3728000005,501.6722000005,1903.750080000699,1174.5497800006997,803.9778800004001,340.5775800004001,854.9778800004001,628.8778800004001,450.1892400002,198.8889400002,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0])
    (rev' @Double @4 conv2dCLaborious128b t128c)

testKonst5BigBLaborious128bc :: Assertion
testKonst5BigBLaborious128bc =
  assertEqualUpToEpsilonShort 1e-8
    (OR.fromList [2,2,8,4] [112.3003,251.5006,417.79492000000005,494.89491000000015,209.49462,482.69492000000014,778.9778800001002,952.0721900001002,229.49462000000003,610.5892400000002,1113.1722000001,1412.1551500001997,56.58894000000004,580.6778800001001,1234.1494800003,1627.8210700004993,56.58894000000004,580.6778800001001,1234.1494800003,1627.8210700004993,56.58894000000004,580.6778800001001,1234.1494800003,1627.8210700004993,56.58894000000004,580.6778800001001,1234.1494800003,1627.8210700004993,56.58894000000004,580.6778800001001,1234.1494800003,1627.8210700004993,3.000000000000032,65.90000000000003,106.90000000000003,173.90000000000006,164.10000000000002,365.89432000010004,593.1946200001,821.2892400002004,667.2003000000001,1060.8778800002,1500.2781800001994,1870.0614400004986,893.3003,1465.6665200003993,2156.3671200003987,2725.039320000898,893.3003,1465.6665200003993,2156.3671200003987,2725.039320000898,893.3003,1465.6665200003993,2156.3671200003987,2725.039320000898,893.3003,1465.6665200003993,2156.3671200003987,2725.039320000898,893.3003,1465.6665200003993,2156.3671200003987,2725.039320000898,112.3003,251.5006,417.79492000000005,494.89491000000015,209.49462,482.69492000000014,778.9778800001002,952.0721900001002,229.49462000000003,610.5892400000002,1113.1722000001,1412.1551500001997,56.58894000000004,580.6778800001001,1234.1494800003,1627.8210700004993,56.58894000000004,580.6778800001001,1234.1494800003,1627.8210700004993,56.58894000000004,580.6778800001001,1234.1494800003,1627.8210700004993,56.58894000000004,580.6778800001001,1234.1494800003,1627.8210700004993,56.58894000000004,580.6778800001001,1234.1494800003,1627.8210700004993,3.000000000000032,65.90000000000003,106.90000000000003,173.90000000000006,164.10000000000002,365.89432000010004,593.1946200001,821.2892400002004,667.2003000000001,1060.8778800002,1500.2781800001994,1870.0614400004986,893.3003,1465.6665200003993,2156.3671200003987,2725.039320000898,893.3003,1465.6665200003993,2156.3671200003987,2725.039320000898,893.3003,1465.6665200003993,2156.3671200003987,2725.039320000898,893.3003,1465.6665200003993,2156.3671200003987,2725.039320000898,893.3003,1465.6665200003993,2156.3671200003987,2725.039320000898])
    (rev' @Double @4 conv2dBLaborious128b t128c)

-- The gradient is the same as above, because one argument is the same
-- and convolution is linear.
testKonstNotBigBLaborious128cb :: Assertion
testKonstNotBigBLaborious128cb =
  assertEqualUpToEpsilonShort 1e-8
    (OR.fromList [4,2,4,4] [54.100300000000004,111.20060000000001,191.4006,228.4006,119.09462,270.29492000000005,435.28356000009995,519.1778800001,109.09462000000002,318.19492,563.3835600001,687.2778800001003,174.08894000000004,477.28924000000006,774.2665200002001,931.9551600002003,58.2,140.3,226.39432,266.49431000000004,90.4,212.4,343.69432000000006,432.89431000000013,120.4,292.39432000000005,549.78864,724.8772700001001,-117.5,103.38864000010005,459.88296000009996,695.8659100003002,54.100300000000004,111.20060000000001,191.4006,228.4006,119.09462,270.29492000000005,435.28356000009995,519.1778800001,109.09462000000002,318.19492,563.3835600001,687.2778800001003,174.08894000000004,477.28924000000006,774.2665200002001,931.9551600002003,58.2,140.3,226.39432,266.49431000000004,90.4,212.4,343.69432000000006,432.89431000000013,120.4,292.39432000000005,549.78864,724.8772700001001,-117.5,103.38864000010005,459.88296000009996,695.8659100003002,54.100300000000004,111.20060000000001,191.4006,228.4006,119.09462,270.29492000000005,435.28356000009995,519.1778800001,109.09462000000002,318.19492,563.3835600001,687.2778800001003,174.08894000000004,477.28924000000006,774.2665200002001,931.9551600002003,58.2,140.3,226.39432,266.49431000000004,90.4,212.4,343.69432000000006,432.89431000000013,120.4,292.39432000000005,549.78864,724.8772700001001,-117.5,103.38864000010005,459.88296000009996,695.8659100003002,54.100300000000004,111.20060000000001,191.4006,228.4006,119.09462,270.29492000000005,435.28356000009995,519.1778800001,109.09462000000002,318.19492,563.3835600001,687.2778800001003,174.08894000000004,477.28924000000006,774.2665200002001,931.9551600002003,58.2,140.3,226.39432,266.49431000000004,90.4,212.4,343.69432000000006,432.89431000000013,120.4,292.39432000000005,549.78864,724.8772700001001,-117.5,103.38864000010005,459.88296000009996,695.8659100003002])
    (rev' @Double @4 conv2dBLaborious128c t128b)

testKonst5BigCLaborious128cb :: Assertion
testKonst5BigCLaborious128cb =
  assertEqualUpToEpsilonShort 1e-8
    (OR.fromList [4,2,4,4] [2640.8154000007976,1836.3264600007988,1163.4488800005001,483.7716000003,2412.414800000798,1662.026160000799,1046.2488800005003,446.7716000003,2121.6375200006987,1436.2432000006995,914.5659200004003,399.8772800003,1953.5375200006988,1258.1432000006998,794.3659200004003,359.8772800003,1712.044990000598,1566.644690000599,1143.0671100004001,478.5721900004001,1445.5506800005985,1358.3503800005992,1016.8728000004002,438.47220000040005,1279.150680000599,1224.1503800005996,922.5728000004001,389.3722000004,987.1677200004992,962.1674200005002,710.5841600003,303.48356000030003,2640.8154000007976,1836.3264600007988,1163.4488800005001,483.7716000003,2412.414800000798,1662.026160000799,1046.2488800005003,446.7716000003,2121.6375200006987,1436.2432000006995,914.5659200004003,399.8772800003,1953.5375200006988,1258.1432000006998,794.3659200004003,359.8772800003,1712.044990000598,1566.644690000599,1143.0671100004001,478.5721900004001,1445.5506800005985,1358.3503800005992,1016.8728000004002,438.47220000040005,1279.150680000599,1224.1503800005996,922.5728000004001,389.3722000004,987.1677200004992,962.1674200005002,710.5841600003,303.48356000030003,2640.8154000007976,1836.3264600007988,1163.4488800005001,483.7716000003,2412.414800000798,1662.026160000799,1046.2488800005003,446.7716000003,2121.6375200006987,1436.2432000006995,914.5659200004003,399.8772800003,1953.5375200006988,1258.1432000006998,794.3659200004003,359.8772800003,1712.044990000598,1566.644690000599,1143.0671100004001,478.5721900004001,1445.5506800005985,1358.3503800005992,1016.8728000004002,438.47220000040005,1279.150680000599,1224.1503800005996,922.5728000004001,389.3722000004,987.1677200004992,962.1674200005002,710.5841600003,303.48356000030003,2640.8154000007976,1836.3264600007988,1163.4488800005001,483.7716000003,2412.414800000798,1662.026160000799,1046.2488800005003,446.7716000003,2121.6375200006987,1436.2432000006995,914.5659200004003,399.8772800003,1953.5375200006988,1258.1432000006998,794.3659200004003,359.8772800003,1712.044990000598,1566.644690000599,1143.0671100004001,478.5721900004001,1445.5506800005985,1358.3503800005992,1016.8728000004002,438.47220000040005,1279.150680000599,1224.1503800005996,922.5728000004001,389.3722000004,987.1677200004992,962.1674200005002,710.5841600003,303.48356000030003])
    (rev' @Double @4 conv2dCLaborious128c t128b)

-- The gradient is the same as above, because one argument is the same
-- and convolution is linear.
testKonstNotBigCLaborious128cb :: Assertion
testKonstNotBigCLaborious128cb =
  assertEqualUpToEpsilonShort 1e-8
    (OR.fromList [4,2,4,4] [2640.8154000007976,1836.3264600007988,1163.4488800005001,483.7716000003,2412.414800000798,1662.026160000799,1046.2488800005003,446.7716000003,2121.6375200006987,1436.2432000006995,914.5659200004003,399.8772800003,1953.5375200006988,1258.1432000006998,794.3659200004003,359.8772800003,1712.044990000598,1566.644690000599,1143.0671100004001,478.5721900004001,1445.5506800005985,1358.3503800005992,1016.8728000004002,438.47220000040005,1279.150680000599,1224.1503800005996,922.5728000004001,389.3722000004,987.1677200004992,962.1674200005002,710.5841600003,303.48356000030003,2640.8154000007976,1836.3264600007988,1163.4488800005001,483.7716000003,2412.414800000798,1662.026160000799,1046.2488800005003,446.7716000003,2121.6375200006987,1436.2432000006995,914.5659200004003,399.8772800003,1953.5375200006988,1258.1432000006998,794.3659200004003,359.8772800003,1712.044990000598,1566.644690000599,1143.0671100004001,478.5721900004001,1445.5506800005985,1358.3503800005992,1016.8728000004002,438.47220000040005,1279.150680000599,1224.1503800005996,922.5728000004001,389.3722000004,987.1677200004992,962.1674200005002,710.5841600003,303.48356000030003,2640.8154000007976,1836.3264600007988,1163.4488800005001,483.7716000003,2412.414800000798,1662.026160000799,1046.2488800005003,446.7716000003,2121.6375200006987,1436.2432000006995,914.5659200004003,399.8772800003,1953.5375200006988,1258.1432000006998,794.3659200004003,359.8772800003,1712.044990000598,1566.644690000599,1143.0671100004001,478.5721900004001,1445.5506800005985,1358.3503800005992,1016.8728000004002,438.47220000040005,1279.150680000599,1224.1503800005996,922.5728000004001,389.3722000004,987.1677200004992,962.1674200005002,710.5841600003,303.48356000030003,2640.8154000007976,1836.3264600007988,1163.4488800005001,483.7716000003,2412.414800000798,1662.026160000799,1046.2488800005003,446.7716000003,2121.6375200006987,1436.2432000006995,914.5659200004003,399.8772800003,1953.5375200006988,1258.1432000006998,794.3659200004003,359.8772800003,1712.044990000598,1566.644690000599,1143.0671100004001,478.5721900004001,1445.5506800005985,1358.3503800005992,1016.8728000004002,438.47220000040005,1279.150680000599,1224.1503800005996,922.5728000004001,389.3722000004,987.1677200004992,962.1674200005002,710.5841600003,303.48356000030003])
    (rev' @Double @4 conv2dCLaborious128c t128b)


-- * A failed version (all tests had to be removed)

-- That's due to the conditional not being lazy and the indexing
-- (and gather) crashing when out of bounds. Either of these needs to be
-- fixed or, alternatively, the Ast term needs to be simplified after all
-- variables are known, but before interpretation, and all inaccessible
-- subtensor expressions need to be replaced with something safe, like 0,
-- which would likely grow the term a lot.
--
-- The failure would manifest in rev` that uses vectorization
-- and for tensors larger than 1-element, where indexes out of bounds
-- are generated (on purpose) in this code.
-- It would manifest with the older version of rindex that crashed
-- when out of bounds.


-- * Disparity

-- | Disparity cost volume.
--
--   Take two arrays of multi channel 2d images, where the first contains
--   left views of the scene and the second contains right views.
--
--   For each pair of images, slice the right image over the left image,
--   and for each offset produce the L1 distance indicating how well
--   correponding
--   multi-channel image elements in the right image match those in the left.
--
--   Described in:
--    Anytime Stereo Image Depth Estimation on Mobile Devices
--    Wang, Lai et al, ICRA 2019
--    https://arxiv.org/abs/1810.11408
--    Section III b).
--
costVolume
  :: forall r ranked. (ADReady ranked, GoodScalar r)
  => Int -> Int -> ranked r 4 -> ranked r 4 -> ranked r 4
costVolume iStart nCount arrL arrR =
  let [nImgs, nChas, nRows, nCols] = rshape arrL
      shO = [nImgs, nCount, nRows, nCols]
  in rbuild shO $ \[iImg, iDisp, iRow, iCol] ->
       let arrVecL = rbuild (nChas :$: ZSR) $ \[iCha] ->
                       indexz0 arrL [iImg, iCha, iRow, iCol]
           iSrc = iCol - fromIntegral iStart - iDisp
           arrVecR = rbuild [nChas] $ \[iCha] ->
                       indexz0 arrR [iImg, iCha, iRow, iSrc]
       in rsum0 $ rzipWith1 (\xL xR -> abs (xL - xR)) arrVecL arrVecR

test_disparityKonst :: Assertion
test_disparityKonst = do
  let arrL :: (ADReady ranked, GoodScalar r, Differentiable r) => ranked r 4
      arrL = rreplicate0N [1, 2, 4, 6] (rscalar (-0.2))
      arrR :: (ADReady ranked, GoodScalar r, Differentiable r) => ranked r 4
      arrR = rreplicate0N [1, 2, 4, 6] (rscalar 0.3)
      arrO = costVolume @Double 0 4 arrL arrR
      arrDL = revDt (\aL -> costVolume 0 4 aL (rconstant arrR)) arrL arrO
      arrDR = revDt (\aR -> costVolume 0 4 (rconstant arrL) aR) arrR arrO
  assertEqualUpToEpsilon1 1e-7
    (OR.fromList [1,4,4,6] [1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,0.4,1.0,1.0,1.0,1.0,1.0,0.4,1.0,1.0,1.0,1.0,1.0,0.4,1.0,1.0,1.0,1.0,1.0,0.4,1.0,1.0,1.0,1.0,1.0,0.4,0.4,1.0,1.0,1.0,1.0,0.4,0.4,1.0,1.0,1.0,1.0,0.4,0.4,1.0,1.0,1.0,1.0,0.4,0.4,1.0,1.0,1.0,1.0,0.4,0.4,0.4,1.0,1.0,1.0,0.4,0.4,0.4,1.0,1.0,1.0,0.4,0.4,0.4,1.0,1.0,1.0,0.4,0.4,0.4,1.0,1.0,1.0])
    arrO
  assertEqualUpToEpsilon1 1e-7
    (OR.fromList [1,2,4,6] [-2.2,-2.8,-3.4,-4.0,-4.0,-4.0,-2.2,-2.8,-3.4,-4.0,-4.0,-4.0,-2.2,-2.8,-3.4,-4.0,-4.0,-4.0,-2.2,-2.8,-3.4,-4.0,-4.0,-4.0,-2.2,-2.8,-3.4,-4.0,-4.0,-4.0,-2.2,-2.8,-3.4,-4.0,-4.0,-4.0,-2.2,-2.8,-3.4,-4.0,-4.0,-4.0,-2.2,-2.8,-3.4,-4.0,-4.0,-4.0])
    arrDL
  assertEqualUpToEpsilon1 1e-7
    (OR.fromList [1,2,4,6] [4.0,4.0,4.0,3.0,2.0,1.0,4.0,4.0,4.0,3.0,2.0,1.0,4.0,4.0,4.0,3.0,2.0,1.0,4.0,4.0,4.0,3.0,2.0,1.0,4.0,4.0,4.0,3.0,2.0,1.0,4.0,4.0,4.0,3.0,2.0,1.0,4.0,4.0,4.0,3.0,2.0,1.0,4.0,4.0,4.0,3.0,2.0,1.0])
   arrDR
  assertEqualUpToEpsilon' 1e-7
    (OR.fromList [1,2,4,6] [4.0,4.0,4.0,3.0,2.0,1.0,4.0,4.0,4.0,3.0,2.0,1.0,4.0,4.0,4.0,3.0,2.0,1.0,4.0,4.0,4.0,3.0,2.0,1.0,4.0,4.0,4.0,3.0,2.0,1.0,4.0,4.0,4.0,3.0,2.0,1.0,4.0,4.0,4.0,3.0,2.0,1.0,4.0,4.0,4.0,3.0,2.0,1.0])
    (rev' @Double @4 (costVolume 0 4 arrL) (FlipR $ Nested.rtoOrthotope $ runFlipR $ arrR))
  assertEqualUpToEpsilon' 1e-7
    (OR.fromList [1,2,4,6] [-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0])
    (rev' @Double @4 (\aL -> costVolume 0 2 aL arrR) (FlipR $ Nested.rtoOrthotope $ runFlipR $ arrL))
  assertEqualUpToEpsilon' 1e-7
    (OR.fromList [1,2,4,6] [2.0,2.0,2.0,2.0,2.0,1.0,2.0,2.0,2.0,2.0,2.0,1.0,2.0,2.0,2.0,2.0,2.0,1.0,2.0,2.0,2.0,2.0,2.0,1.0,2.0,2.0,2.0,2.0,2.0,1.0,2.0,2.0,2.0,2.0,2.0,1.0,2.0,2.0,2.0,2.0,2.0,1.0,2.0,2.0,2.0,2.0,2.0,1.0])
    (rev' @Double @4 (costVolume 0 2 arrL) (FlipR $ Nested.rtoOrthotope $ runFlipR $ arrR))

test_disparityKonst2 :: Assertion
test_disparityKonst2 = do
  let arrL :: (RankedTensor ranked, GoodScalar r, Differentiable r) => ranked r 4
      arrL = ringestData [1, 2, 4, 6] [0.4,0.4,0.4,1.0,1.0,1.0,0.4,0.4,0.4,1.0,1.0,1.0,0.4,0.4,0.4,1.0,1.0,1.0, 1.7041241452319316,1.21999,0.21355339059327375,0.7867666666666666,0.7331698975466578,0.6964466094067263,1.1,1.1041141452319316,0.42000000000000004,0.3536533905932737,0.78,1.253169897546658,1.1,0.50001,0.42000000000000004,0.2801,0.78,1.3,1.1,0.50001,0.42000000000000004,0.2801,0.78,1.3,2.808238290463863,1.21999,-0.5672067811865474,0.7867666666666666,1.986339795093316,0.6964466094067263]
      arrR :: (RankedTensor ranked, GoodScalar r, Differentiable r) => ranked r 4
      arrR = ringestData [1, 2, 4, 6] [0.2, 0.5, -0.2, 0.0001, 0.44, 0.9, -0.9, 0.00001, -0.22, -0.28, -0.34, -0.40, -0.40,-0.22,-0.28,-0.34, 0.22360679774997896,0.35355339059327373,0.20412414523193154,0.5, -0.35355339059327373,0.16666666666666666,0.17677669529663687,-0.25, -2.808238290463863,-1.21999,-0.5672067811865474,-0.7867666666666666,-1.986339795093316,-0.6964466094067263,2.808238290463863,1.21999,-0.5672067811865474,0.7867666666666666,0.6964466094067263,0.42000000000000004,0.3536533905932737,0.78,1.253169897546658,0.50001,0.42000000000000004,0.2801,0.78,1.1,0.50001,0.42000000000000004,0.2801,0.78]
      arrO = OR.constant [1, 4, 4, 6] (1 :: Double)
      res1 = OR.fromList [1,2,4,6] [4.0,2.0,2.0,4.0,4.0,4.0,4.0,4.0,4.0,4.0,4.0,4.0,4.0,4.0,4.0,4.0,4.0,4.0,4.0,4.0,2.0,4.0,4.0,4.0,4.0,4.0,4.0,4.0,4.0,4.0,2.0,0.0,0.0,-2.0,0.0,4.0,4.0,2.0,0.0,-4.0,1.0,4.0,4.0,4.0,-4.0,2.0,4.0,2.0]
      res2 = OR.fromList [1,2,4,6] [-4.0,0.0,-4.0,-3.0,-2.0,-1.0,-4.0,-4.0,-4.0,-3.0,-2.0,-1.0,-4.0,-4.0,-4.0,-3.0,-2.0,-1.0,-4.0,-2.0,-4.0,-3.0,-2.0,-1.0,-4.0,-4.0,-4.0,-3.0,-2.0,-1.0,4.0,4.0,-4.0,1.0,-2.0,-1.0,-2.0,3.0,2.0,-1.0,-2.0,-1.0,-2.0,0.0,-2.0,-3.0,-2.0,1.0]
      arrDL :: ORArray Double 4
      arrDL = revDt (\aL -> costVolume 0 4 aL (rconstant arrR)) arrL (FlipR $ Nested.rfromOrthotope SNat arrO)
      arrDR :: ORArray Double 4
      arrDR = revDt (costVolume 0 4 (rconstant arrL)) arrR (FlipR $ Nested.rfromOrthotope SNat arrO)
  assertEqualUpToEpsilon1 1e-7
    res1
    arrDL
  assertEqualUpToEpsilon1 1e-7
    res2
    arrDR
  assertEqualUpToEpsilon' 1e-7
    res1
    (rev' @Double @4 (\aL -> costVolume 0 4 aL (rconstant arrR)) (FlipR $ Nested.rtoOrthotope $ runFlipR $ arrL))
  assertEqualUpToEpsilon' 1e-7
    res2
    (rev' @Double @4 (costVolume 0 4 (rconstant arrL)) (FlipR $ Nested.rtoOrthotope $ runFlipR $ arrR))

test_disparitySmall :: Assertion
test_disparitySmall = do
  let arrL :: (ADReady ranked, GoodScalar r, Differentiable r) => ranked r 4
      arrL = ringestData [1, 2, 3, 2] [0.2, 0.5, -0.2, 0.0001, 0.44, 0.9, -0.9, 0.00001, -0.22, -0.28, -0.34, -0.40]
      arrR :: (ADReady ranked, GoodScalar r, Differentiable r) => ranked r 4
      arrR = ringestData [1, 2, 3, 2] [-0.40,-0.22,-0.28,-0.34, 0.22360679774997896,0.35355339059327373,0.20412414523193154,0.5, -0.35355339059327373,0.16666666666666666,0.17677669529663687,-0.25]
      arrO = costVolume @Double 0 4 arrL arrR
      arrDL = revDt (\aL -> costVolume 0 4 aL (rconstant arrR)) arrL arrO
      arrDR = revDt (\aR -> costVolume 0 4 (rconstant arrL) aR) arrR arrO
  assertEqualUpToEpsilon1 1e-7
    (OR.fromList [1,4,3,2] [1.7041241452319316,1.21999,0.21355339059327375,0.7867666666666666,0.7331698975466578,0.6964466094067263,1.1,1.1041141452319316,0.42000000000000004,0.3536533905932737,0.78,1.253169897546658,1.1,0.50001,0.42000000000000004,0.2801,0.78,1.3,1.1,0.50001,0.42000000000000004,0.2801,0.78,1.3])
    arrO
  assertEqualUpToEpsilon' 1e-7
    (OR.fromList [1,2,3,2] [-2.0,-1.0,-2.0,-1.0,-2.0,-1.0,2.0,1.0,-2.0,1.0,2.0,1.0])
    (rev' @Double @4 (costVolume 0 4 arrL) (FlipR $ Nested.rtoOrthotope $ runFlipR $ arrR))
  assertEqualUpToEpsilon1 1e-7
    (OR.fromList [1,2,3,2] [5.004124145231932,3.3241241452319317,-1.0464466094067264,1.7006200572599404,3.0731698975466575,4.5496165069533845,-5.004124145231932,-1.3240841452319316,-1.0464466094067264,-0.9933132760733929,-3.0731698975466575,-4.5496165069533845])
    arrDL
  assertEqualUpToEpsilon1 1e-7
    (OR.fromList [1,2,3,2] [-2.808238290463863,-1.21999,-0.5672067811865474,-0.7867666666666666,-1.986339795093316,-0.6964466094067263,2.808238290463863,1.21999,-0.5672067811865474,0.7867666666666666,1.986339795093316,0.6964466094067263])
   arrDR
  assertEqualUpToEpsilon' 1e-7
    (OR.fromList [1,2,3,2] [-1.0,0.0,-1.0,0.0,-1.0,0.0,1.0,0.0,-1.0,0.0,1.0,0.0])
    (rev' @Double @4 (costVolume 1 4 arrL) (FlipR $ Nested.rtoOrthotope $ runFlipR $ arrR))
  assertEqualUpToEpsilon' 1e-7
    (OR.fromList [1,2,3,2] [2.0,2.0,-2.0,2.0,2.0,2.0,-2.0,2.0,-2.0,-2.0,-2.0,-2.0])
    (rev' @Double @4 (\aL -> costVolume 2 2 aL arrR) (FlipR $ Nested.rtoOrthotope $ runFlipR $ arrL))
  assertEqualUpToEpsilon' 1e-7
    (OR.fromList [1,2,3,2] [-1.0,0.0,-1.0,0.0,-1.0,0.0,1.0,0.0,-1.0,0.0,1.0,0.0])
    (rev' @Double @4 (costVolume 1 2 arrL) (FlipR $ Nested.rtoOrthotope $ runFlipR $ arrR))


-- * PP Tests

unPaddedPPString :: String
unPaddedPPString = "\\h56 u162 u163 -> [rscatter [2,2,2,2] (rscatter [2,2,1,2,2,2] (rsum (rsum (rsum (rgather [2,2,2,2,1,2,2,2] (rtranspose [0,4,1,2,3] (rreplicate 2 (rreshape [2,2,2,8] (rgather [2,2,2,1,2,2,2] (rfromVector (fromList [rgather [2,2,2,1,2,2,2] u163 (\\[i33, i34, i35, i36, i37, i38, i39] -> [i33 + i36, i37, i34 + i38, i35 + i39]), rreplicate 2 (rreplicate 2 (rreplicate 2 (rreplicate 1 (rreplicate 2 (rreplicate 2 (rreplicate 2 0.0))))))])) (\\[i40, i41, i42, i43, i44, i45, i46] -> [ifF ((0 <=. i40 + i43 &&* 2 >. i40 + i43) &&* ((0 <=. i44 &&* 2 >. i44) &&* ((0 <=. i41 + i45 &&* 2 >. i41 + i45) &&* (0 <=. i42 + i46 &&* 2 >. i42 + i46)))) 0 1, i40, i41, i42, i43, i44, i45, i46])))) * rtranspose [2,0,1] (rreplicate 8 (rproject h56 0))) (\\[i139, i140, i141, i142, i143, i144, i145, i146] -> [remF (quotF (i146 + 2 * i145 + 4 * i144 + 8 * i142 + 8 * i143) 8) 2, remF (i146 + 2 * i145 + 4 * i144 + 8 * i142 + 8 * i143) 8, i139, i140, i141]))))) (\\[i57, i58, i59, i60, i61] -> [ifF ((0 <=. i57 + i58 &&* 2 >. i57 + i58) &&* ((0 <=. i59 &&* 2 >. i59) &&* ((0 <=. i60 &&* 2 >. i60) &&* (0 <=. i61 &&* 2 >. i61)))) 0 1, i57, i58, i59, i60, i61]) ! [0]) (\\[i63, i64] -> [i63 + i64]), rscatter [2,2,2,2] (rscatter [2,2,2,2,1,2,2,2] (rsum (rgather [2,2,2,2,1,2,2,2] (rtranspose [0,1,2,4,3] (rreplicate 2 (rreplicate 2 (rreplicate 2 (rreshape [2,8] (rgather [2,1,2,2,2] (rfromVector (fromList [rgather [2,1,2,2,2] u162 (\\[i47, i48] -> [i47 + i48]), rreplicate 2 (rreplicate 1 (rreplicate 2 (rreplicate 2 (rreplicate 2 0.0))))])) (\\[i49, i50, i51, i52, i53] -> [ifF ((0 <=. i49 + i50 &&* 2 >. i49 + i50) &&* ((0 <=. i51 &&* 2 >. i51) &&* ((0 <=. i52 &&* 2 >. i52) &&* (0 <=. i53 &&* 2 >. i53)))) 0 1, i49, i50, i51, i52, i53])))))) * rtranspose [1,3,4,0,2] (rreplicate 8 (rproject h56 0))) (\\[i154, i155, i156, i157, i158, i159, i160, i161] -> [remF (quotF (i161 + 2 * i160 + 4 * i159 + 8 * i158 + 8 * i157 + 32 * i155 + 16 * i156) 32) 2, remF (quotF (i161 + 2 * i160 + 4 * i159 + 8 * i158 + 8 * i157 + 32 * i155 + 16 * i156) 16) 2, remF (quotF (i161 + 2 * i160 + 4 * i159 + 8 * i158 + 8 * i157 + 32 * i155 + 16 * i156) 8) 2, remF (i161 + 2 * i160 + 4 * i159 + 8 * i158 + 8 * i157 + 32 * i155 + 16 * i156) 8, i154]))) (\\[i65, i66, i67, i68, i69, i70, i71] -> [ifF ((0 <=. i65 + i68 &&* 2 >. i65 + i68) &&* ((0 <=. i69 &&* 2 >. i69) &&* ((0 <=. i66 + i70 &&* 2 >. i66 + i70) &&* (0 <=. i67 + i71 &&* 2 >. i67 + i71)))) 0 1, i65, i66, i67, i68, i69, i70, i71]) ! [0]) (\\[i73, i74, i75, i76, i77, i78, i79] -> [i73 + i76, i77, i74 + i78, i75 + i79])]"

unPaddedPPString3 :: String
unPaddedPPString3 = "\\h32 u126 u127 -> [rscatter [2,2,2,2] (rsum (rsum (rsum (rgather [2,2,2,2,1,2,2,2] (rtranspose [0,4,1,2,3] (rreplicate 2 (rreshape [2,2,2,8] (rgather [2,2,2,1,2,2,2] u127 (\\[i21, i22, i23, i24, i25, i26, i27] -> [i21 + i24, i25, i22 + i26, i23 + i27])))) * rtranspose [2,0,1] (rreplicate 8 (rproject h32 0))) (\\[i103, i104, i105, i106, i107, i108, i109, i110] -> [remF (quotF (i110 + 2 * i109 + 4 * i108 + 8 * i106 + 8 * i107) 8) 2, remF (i110 + 2 * i109 + 4 * i108 + 8 * i106 + 8 * i107) 8, i103, i104, i105]))))) (\\[i33, i34] -> [i33 + i34]), rscatter [2,2,2,2] (rsum (rgather [2,2,2,2,1,2,2,2] (rtranspose [0,1,2,4,3] (rreplicate 2 (rreplicate 2 (rreplicate 2 (rreshape [2,8] (rgather [2,1,2,2,2] u126 (\\[i28, i29] -> [i28 + i29])))))) * rtranspose [1,3,4,0,2] (rreplicate 8 (rproject h32 0))) (\\[i118, i119, i120, i121, i122, i123, i124, i125] -> [remF (quotF (i125 + 2 * i124 + 4 * i123 + 8 * i122 + 8 * i121 + 32 * i119 + 16 * i120) 32) 2, remF (quotF (i125 + 2 * i124 + 4 * i123 + 8 * i122 + 8 * i121 + 32 * i119 + 16 * i120) 16) 2, remF (quotF (i125 + 2 * i124 + 4 * i123 + 8 * i122 + 8 * i121 + 32 * i119 + 16 * i120) 8) 2, remF (i125 + 2 * i124 + 4 * i123 + 8 * i122 + 8 * i121 + 32 * i119 + 16 * i120) 8, i118]))) (\\[i35, i36, i37, i38, i39, i40, i41] -> [i35 + i38, i39, i36 + i40, i37 + i41])]"

testConv2dUnpaddedPP :: Assertion
testConv2dUnpaddedPP = do
  resetVarCounter
  let f :: HVector (AstGeneric AstMethodLet FullSpan) -> AstRanked FullSpan Double 4
      f v = conv2dUnpadded (rfromD $ rankedHVector v V.! 0) (rfromD $ rankedHVector v V.! 1)
      g :: Double -> ORArray Double 4
      g x = FlipR $ Nested.rfromOrthotope SNat $ OR.fromList [2,2,2,2] $ replicate 16 x
      (artifactRev, _) =
        revArtifactAdapt
                 True
                 f
                 (V.fromList [ DynamicRanked @Double @4 (g 1.1)
                             , DynamicRanked @Double @4 (g 2.3) ])
  printArtifactPretty IM.empty (simplifyArtifact artifactRev)
    @?= "\\u56 u162 u163 -> [rscatter [2,2,2,2] (rscatter [2,2,1,2,2,2] (rsum (rsum (rsum (rgather [2,2,2,2,1,2,2,2] (rtranspose [0,4,1,2,3] (rreplicate 2 (rreshape [2,2,2,8] (rgather [2,2,2,1,2,2,2] (rfromVector (fromList [rgather [2,2,2,1,2,2,2] u163 (\\[i33, i34, i35, i36, i37, i38, i39] -> [i33 + i36, i37, i34 + i38, i35 + i39]), rreplicate 2 (rreplicate 2 (rreplicate 2 (rreplicate 1 (rreplicate 2 (rreplicate 2 (rreplicate 2 0.0))))))])) (\\[i40, i41, i42, i43, i44, i45, i46] -> [ifF ((0 <=. i40 + i43 &&* 2 >. i40 + i43) &&* ((0 <=. i44 &&* 2 >. i44) &&* ((0 <=. i41 + i45 &&* 2 >. i41 + i45) &&* (0 <=. i42 + i46 &&* 2 >. i42 + i46)))) 0 1, i40, i41, i42, i43, i44, i45, i46])))) * rtranspose [2,0,1] (rreplicate 8 u56)) (\\[i139, i140, i141, i142, i143, i144, i145, i146] -> [remF (quotF (i146 + 2 * i145 + 4 * i144 + 8 * i142 + 8 * i143) 8) 2, remF (i146 + 2 * i145 + 4 * i144 + 8 * i142 + 8 * i143) 8, i139, i140, i141]))))) (\\[i57, i58, i59, i60, i61] -> [ifF ((0 <=. i57 + i58 &&* 2 >. i57 + i58) &&* ((0 <=. i59 &&* 2 >. i59) &&* ((0 <=. i60 &&* 2 >. i60) &&* (0 <=. i61 &&* 2 >. i61)))) 0 1, i57, i58, i59, i60, i61]) ! [0]) (\\[i63, i64] -> [i63 + i64]), rscatter [2,2,2,2] (rscatter [2,2,2,2,1,2,2,2] (rsum (rgather [2,2,2,2,1,2,2,2] (rtranspose [0,1,2,4,3] (rreplicate 2 (rreplicate 2 (rreplicate 2 (rreshape [2,8] (rgather [2,1,2,2,2] (rfromVector (fromList [rgather [2,1,2,2,2] u162 (\\[i47, i48] -> [i47 + i48]), rreplicate 2 (rreplicate 1 (rreplicate 2 (rreplicate 2 (rreplicate 2 0.0))))])) (\\[i49, i50, i51, i52, i53] -> [ifF ((0 <=. i49 + i50 &&* 2 >. i49 + i50) &&* ((0 <=. i51 &&* 2 >. i51) &&* ((0 <=. i52 &&* 2 >. i52) &&* (0 <=. i53 &&* 2 >. i53)))) 0 1, i49, i50, i51, i52, i53])))))) * rtranspose [1,3,4,0,2] (rreplicate 8 u56)) (\\[i154, i155, i156, i157, i158, i159, i160, i161] -> [remF (quotF (i161 + 2 * i160 + 4 * i159 + 8 * i158 + 8 * i157 + 32 * i155 + 16 * i156) 32) 2, remF (quotF (i161 + 2 * i160 + 4 * i159 + 8 * i158 + 8 * i157 + 32 * i155 + 16 * i156) 16) 2, remF (quotF (i161 + 2 * i160 + 4 * i159 + 8 * i158 + 8 * i157 + 32 * i155 + 16 * i156) 8) 2, remF (i161 + 2 * i160 + 4 * i159 + 8 * i158 + 8 * i157 + 32 * i155 + 16 * i156) 8, i154]))) (\\[i65, i66, i67, i68, i69, i70, i71] -> [ifF ((0 <=. i65 + i68 &&* 2 >. i65 + i68) &&* ((0 <=. i69 &&* 2 >. i69) &&* ((0 <=. i66 + i70 &&* 2 >. i66 + i70) &&* (0 <=. i67 + i71 &&* 2 >. i67 + i71)))) 0 1, i65, i66, i67, i68, i69, i70, i71]) ! [0]) (\\[i73, i74, i75, i76, i77, i78, i79] -> [i73 + i76, i77, i74 + i78, i75 + i79])]"

testConv2dUnpadded2PP :: Assertion
testConv2dUnpadded2PP = do
  resetVarCounter
  let f :: InterpretationTarget (AstRanked FullSpan) TKUntyped
        -> HVectorPseudoTensor (AstRanked FullSpan) Float '()
      f hv = let v = dunHVector $ unHVectorPseudoTensor hv
             in HVectorPseudoTensor $ dmkHVector
                $ V.singleton $ DynamicRanked @Double @4
                $ conv2dUnpadded (rfromD $ v V.! 0) (rfromD $ v V.! 1)
      shs = V.fromList [ voidFromSh @Double (2 :$: 2 :$: 2 :$: 2 :$: ZSR)
                       , voidFromSh @Double (2 :$: 2 :$: 2 :$: 2 :$: ZSR) ]
      (artifactRev, _) =
        revArtifactFromForwardPass
          True (forwardPassByInterpretation f emptyEnv) (FTKUntyped shs)
  printArtifactPretty IM.empty (simplifyArtifact artifactRev)
    @?= unPaddedPPString

-- This is fragile due to indexing out of bounds, see above.
testConv2dUnpadded3PP :: Assertion
testConv2dUnpadded3PP = do
  resetVarCounter
  let f :: InterpretationTarget (AstRanked FullSpan) TKUntyped
        -> HVectorPseudoTensor (AstRanked FullSpan) Float '()
      f hv = let v = dunHVector $ unHVectorPseudoTensor hv
             in HVectorPseudoTensor $ dmkHVector
                $ V.singleton $ DynamicRanked @Double @4
                $ conv2d (rfromD $ v V.! 0) (rfromD $ v V.! 1)
      shs = V.fromList [ voidFromSh @Double (2 :$: 2 :$: 2 :$: 2 :$: ZSR)
                       , voidFromSh @Double (2 :$: 2 :$: 2 :$: 2 :$: ZSR) ]
      (artifactRev, _) =
        revArtifactFromForwardPass
          True (forwardPassByInterpretation f emptyEnv) (FTKUntyped shs)
  printArtifactPretty IM.empty artifactRev
    @?= "\\h32 u42 u43 -> let w30 = rtranspose [4,1,0,2,3] (rreplicate 2 (rreshape [2,2,2,8] (rgather [2,2,2,1,2,2,2] u43 (\\[i21, i22, i23, i24, i25, i26, i27] -> [i21 + i24, i25, i22 + i26, i23 + i27])))) ; w31 = rtranspose [4,0,3,1,2] (rreplicate 2 (rreplicate 2 (rreplicate 2 (rreshape [2,8] (rgather [2,1,2,2,2] u42 (\\[i28, i29] -> [i28 + i29])))))) in [rscatter [2,2,2,2] (rreshape [2,1,2,2,2] (rsum (rsum (rsum (rtranspose [1,3,4,2,0] (w30 * rreplicate 8 (rproject h32 0))))))) (\\[i33, i34] -> [i33 + i34]), rscatter [2,2,2,2] (rreshape [2,2,2,1,2,2,2] (rsum (rtranspose [2,1,3,4,0] (w31 * rreplicate 8 (rproject h32 0))))) (\\[i35, i36, i37, i38, i39, i40, i41] -> [i35 + i38, i39, i36 + i40, i37 + i41])]"
  printArtifactPretty IM.empty (simplifyArtifact artifactRev)
    @?= unPaddedPPString3
  printArtifactPrimalPretty IM.empty artifactRev
    @?= "\\u128 u129 -> let w30 = rtranspose [4,1,0,2,3] (rreplicate 2 (rreshape [2,2,2,8] (rgather [2,2,2,1,2,2,2] u129 (\\[i21, i22, i23, i24, i25, i26, i27] -> [i21 + i24, i25, i22 + i26, i23 + i27])))) ; w31 = rtranspose [4,0,3,1,2] (rreplicate 2 (rreplicate 2 (rreplicate 2 (rreshape [2,8] (rgather [2,1,2,2,2] u128 (\\[i28, i29] -> [i28 + i29])))))) in [rsum (w30 * w31)]"
  printArtifactPrimalPretty IM.empty (simplifyArtifact artifactRev)
    @?= "\\u212 u213 -> [rsum (rtranspose [4,1,0,2,3] (rreplicate 2 (rreshape [2,2,2,8] (rgather [2,2,2,1,2,2,2] u213 (\\[i21, i22, i23, i24, i25, i26, i27] -> [i21 + i24, i25, i22 + i26, i23 + i27])))) * rtranspose [4,0,3,1,2] (rreplicate 2 (rreplicate 2 (rreplicate 2 (rreshape [2,8] (rgather [2,1,2,2,2] u212 (\\[i28, i29] -> [i28 + i29])))))))]"
