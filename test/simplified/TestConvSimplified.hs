{-# LANGUAGE OverloadedLists #-}
{-# OPTIONS_GHC -fno-cse #-}
{-# OPTIONS_GHC -Wno-incomplete-uni-patterns #-}
-- | Tests of convolution and disparity cost volume defined using the build
-- operation of ranked tensors.
module TestConvSimplified (testTrees) where

import Prelude

import Control.Exception (assert)
import GHC.Exts (IsList (..))
import GHC.TypeLits (KnownNat)
import Test.Tasty
import Test.Tasty.HUnit hiding (assert)

import Data.Array.Nested qualified as Nested
import Data.Array.Nested.Internal.Shape

import HordeAd
import HordeAd.Core.AstEnv
import HordeAd.Core.AstFreshId (resetVarCounter)
import HordeAd.Core.OpsAst

import CrossTesting
import EqEpsilon

testTrees :: [TestTree]
testTrees =
  [ testCase "KonstG0Rev" testKonstG0Rev
  , testCase "KonstG0Tiny1" testKonstG0Tiny1
  , testCase "KonstG0TinyS" testKonstG0TinyS
  , testCase "KonstG0TinyA" testKonstG0TinyA
  , testCase "KonstG0LittleA" testKonstG0LittleA
  , testCase "Replicate0RevLaborious" testReplicate0RevLaborious
  , testCase "Replicate0Tiny1Laborious" testReplicate0Tiny1Laborious
  , testCase "Replicate0TinySLaborious" testReplicate0TinySLaborious
  , testCase "Replicate0TinyALaborious" testReplicate0TinyALaborious
  , testCase "Replicate0LittleALaborious" testReplicate0LittleALaborious
  , testCase "Konst5LittleBLaborious" testKonst5LittleBLaborious
  , testCase "Konst5LittleCLaborious" testKonst5LittleCLaborious
  , testCase "Konst5BigBLaborious" testKonst5BigBLaborious
  , testCase "KonstNotBigBLaborious" testKonstNotBigBLaborious
  , testCase "Konst5BigCLaborious" testKonst5BigCLaborious
  , testCase "KonstNotBigCLaborious" testKonstNotBigCLaborious
  , testCase "Konst5LittleBLaborious128b" testKonst5LittleBLaborious128b
  , testCase "Konst5LittleCLaborious128b" testKonst5LittleCLaborious128b
  , testCase "Konst5BigBLaborious128b" testKonst5BigBLaborious128b
  , testCase "KonstNotBigBLaborious128b" testKonstNotBigBLaborious128b
  , testCase "Konst5BigCLaborious128b" testKonst5BigCLaborious128b
  , testCase "KonstNotBigCLaborious128b" testKonstNotBigCLaborious128b
  , testCase "Konst5LittleBLaborious128c" testKonst5LittleBLaborious128c
  , testCase "Konst5LittleCLaborious128c" testKonst5LittleCLaborious128c
  , testCase "Konst5BigBLaborious128c" testKonst5BigBLaborious128c
  , testCase "KonstNotBigBLaborious128c" testKonstNotBigBLaborious128c
  , testCase "Konst5BigCLaborious128c" testKonst5BigCLaborious128c
  , testCase "KonstNotBigCLaborious128c" testKonstNotBigCLaborious128c
  , testCase "Konst5LittleBLaborious128bc" testKonst5LittleBLaborious128bc
  , testCase "Konst5LittleCLaborious128bc" testKonst5LittleCLaborious128bc
  , testCase "Konst5BigBLaborious128bc" testKonst5BigBLaborious128bc
  , testCase "KonstNotBigBLaborious128cb" testKonstNotBigBLaborious128cb
  , testCase "Konst5BigCLaborious128cb" testKonst5BigCLaborious128cb
  , testCase "KonstNotBigCLaborious128cb" testKonstNotBigCLaborious128cb
  , testCase "disparityKonst" test_disparityKonst
  , testCase "disparityKonst2" test_disparityKonst2
  , testCase "disparitySmall" test_disparitySmall
  , testCase "minimizedCNNOPP0c" testCNNOPP0c
  , testCase "minimizedCNNOPP0b" testCNNOPP0b
  , testCase "minimizedCNNOPP1e" testCNNOPP1e
  , testCase "minimizedCNNOPP1b" testCNNOPP1b
  , testCase "minimizedCNNOPP2" testCNNOPP2
  , testCase "minimizedCNNOPP2b" testCNNOPP2b
  , testCase "minimizedCNNOPP3" testCNNOPP3
  , testCase "minimizedCNNOPP3b" testCNNOPP3b
  , testCase "minimizedCNNOPP4" testCNNOPP4
  , testCase "minimizedCNNOPP4b" testCNNOPP4b
  , testCase "minimizedCNNOPP5" testCNNOPP5
  , testCase "minimizedCNNOPP5b" testCNNOPP5b
  , testCase "minimizedCNNOPP6" testCNNOPP6
  , testCase "minimizedCNNOPP6b" testCNNOPP6b
  , testCase "minimizedCNNOPP7" testCNNOPP7
  , testCase "minimizedCNNOPP7b" testCNNOPP7b
  , testCase "ConvTomsSliceRev" testTomsSliceRev
  , testCase "ConvTomsSlice" testTomsSlice
  , testCase "ConvTomsSlicePP" testTomsSlicePP
  ]

-- The examples reproduced and transformed in this file are borrowed
-- from https://github.com/benl23x5/adops.
-- Here they are defined using ranked tensors.

-- | Unpadded full convolution,
--   where the output size is the same as the input size.
conv2d
  :: (ADReady target, GoodScalar r)
  => target (TKR 4 r) -> target (TKR 4 r) -> target (TKR 4 r)
conv2d arrK arrA =
  let [nImgs, nCinpA, nAh, nAw] = rshape arrA
      [nCoutK, nCinpK, nKh, nKw] = rshape arrK
      nCinp = assert (nCinpA == nCinpK) nCinpA
      shB = [nImgs, nCoutK, nAh, nAw]
      shK1 = [1, nCinp, nKh, nKw]
  in rbuild shB $ \case
    [iImg, iCout, iBh, iBw] ->
      let arrAt = slicezF shK1 arrA [iImg, 0, iBh, iBw]
          arrKt = slicezF shK1 arrK [iCout, 0, 0, 0]
      in rdot0 arrAt arrKt
    _ -> error "conv2d: impossible pattern needlessly required"

-- | Slice a section out of a tensor,
--   given a base offset and shape of the section.
--
--   If the slice extends out side the source array then the corresponding
--   elements are set to zero.
slicezF :: forall target n r. (ADReady target, GoodScalar r, KnownNat n)
        => IShR n -> target (TKR n r) -> IxROf target n -> target (TKR n r)
slicezF shOut d ixBase =
  rbuild shOut $ \ixResult ->
    rindex @n @0 d (zipWith_Index (+) ixBase ixResult)
      -- rindex0 would not require a single type application here

conv2d1
  :: (ADReady target, GoodScalar r, Differentiable r)
  => target (TKR 4 r) -> target (TKR 4 r)
conv2d1 = conv2d $ rconcrete $ Nested.rfromListPrimLinear (fromList [1, 1, 1, 1]) [-0.2]

conv2dA
  :: (ADReady target, GoodScalar r, Differentiable r)
  => target (TKR 4 r) -> target (TKR 4 r)
conv2dA = conv2d $ rconcrete $ Nested.rfromListPrimLinear (fromList [1, 2, 1, 1]) [-0.2, 25.0003]

conv2dB
  :: (ADReady target, GoodScalar r, Differentiable r)
  => target (TKR 4 r) -> target (TKR 4 r)
conv2dB = conv2d (rconcrete $ unConcrete t16b)

testKonstG0Rev :: Assertion
testKonstG0Rev =
  assertEqualUpToEpsilon 1e-4
    (rconcrete $ Nested.rfromListPrimLinear [2, 2, 2, 2] [18.1,29.1,32.1,40.1,582932.0,582934.99432,582597.1,582625.8943200001,18.1,29.1,32.1,40.1,582932.0,582934.99432,582597.1,582625.8943200001])
    (grad (kfromR . rsum0 @4 @(TKScalar Double) . conv2dB) (rrepl [2, 2, 2, 2] 0))

testKonstG0Tiny1 :: Assertion
testKonstG0Tiny1 =
  assertEqualUpToEpsilon' 1e-10
    (ringestData [1, 1, 1, 1] [-0.2])
    (rev' @Double @4 conv2d1 (rrepl [1, 1, 1, 1] 0))

testKonstG0TinyS :: Assertion
testKonstG0TinyS =
  assertEqualUpToEpsilon' 1e-10
    (ringestData [1, 1, 1, 1] [582665.99432])
    (rev' @Double @4
          (conv2d $ rreplicate0N [1, 1, 1, 1] (rsum0 (rconcrete $ unConcrete t16b)))
          (ringestData [1, 1, 1, 1] [0]))

testKonstG0TinyA :: Assertion
testKonstG0TinyA =
  assertEqualUpToEpsilon' 1e-10
    (ringestData [1, 2, 1, 1] [-0.2,25.0003])
    (rev' @Double @4 conv2dA (rrepl [1, 2, 1, 1] 0))

testKonstG0LittleA :: Assertion
testKonstG0LittleA =
  assertEqualUpToEpsilon' 1e-10
    (ringestData [2, 2, 2, 2] [-0.2,-0.2,-0.2,-0.2,25.0003,25.0003,25.0003,25.0003,-0.2,-0.2,-0.2,-0.2,25.0003,25.0003,25.0003,25.0003])
    (rev' @Double @4 conv2dA (rrepl [2, 2, 2, 2] 0))


-- * A laborious version (meaning, out of bounds indexing is handled explicitly)

-- The implementation is in HordeAd.External.CommonRankedOps.
--
-- Some tests are copied from above and the required test results are
-- the same.

conv2d1Laborious
  :: (ADReady target, GoodScalar r, Differentiable r)
  => target (TKR 4 r) -> target (TKR 4 r)
conv2d1Laborious = conv2dUnpadded $ rconcrete $ Nested.rfromListPrimLinear (fromList [1, 1, 1, 1]) [-0.2]

conv2dALaborious
  :: (ADReady target, GoodScalar r, Differentiable r)
  => target (TKR 4 r) -> target (TKR 4 r)
conv2dALaborious =
  conv2dUnpadded $ rconcrete $ Nested.rfromListPrimLinear (fromList [1, 2, 1, 1]) [-0.2, 25.0003]

conv2dBLaborious
  :: (ADReady target, GoodScalar r, Differentiable r)
  => target (TKR 4 r) -> target (TKR 4 r)
conv2dBLaborious = conv2dUnpadded (rconcrete $ unConcrete t16b)

conv2dCLaborious
  :: (ADReady target, GoodScalar r, Differentiable r)
  => target (TKR 4 r) -> target (TKR 4 r)
conv2dCLaborious = flip conv2dUnpadded (rconcrete $ unConcrete t16b)

conv2dBLaborious128b
  :: (ADReady target, GoodScalar r, Differentiable r)
  => target (TKR 4 r) -> target (TKR 4 r)
conv2dBLaborious128b = conv2dUnpadded (rconcrete $ unConcrete t128b)

conv2dCLaborious128b
  :: (ADReady target, GoodScalar r, Differentiable r)
  => target (TKR 4 r) -> target (TKR 4 r)
conv2dCLaborious128b = flip conv2dUnpadded (rconcrete $ unConcrete t128b)

conv2dBLaborious128c
  :: (ADReady target, GoodScalar r, Differentiable r)
  => target (TKR 4 r) -> target (TKR 4 r)
conv2dBLaborious128c = conv2dUnpadded (rconcrete $ unConcrete t128c)

conv2dCLaborious128c
  :: (ADReady target, GoodScalar r, Differentiable r)
  => target (TKR 4 r) -> target (TKR 4 r)
conv2dCLaborious128c = flip conv2dUnpadded (rconcrete $ unConcrete t128c)

testReplicate0RevLaborious :: Assertion
testReplicate0RevLaborious =
  assertEqualUpToEpsilon 1e-4
    (rconcrete $ Nested.rfromListPrimLinear [2, 2, 2, 2] [18.1,29.1,32.1,40.1,582932.0,582934.99432,582597.1,582625.8943200001,18.1,29.1,32.1,40.1,582932.0,582934.99432,582597.1,582625.8943200001])
    (grad (kfromR . rsum0 @4 @(TKScalar Double) . conv2dBLaborious) (rrepl [2, 2, 2, 2] 0))

testReplicate0Tiny1Laborious :: Assertion
testReplicate0Tiny1Laborious =
  assertEqualUpToEpsilon' 1e-10
    (ringestData [1, 1, 1, 1] [-0.2])
    (rev' @Double @4 conv2d1Laborious (rrepl [1, 1, 1, 1] 0))

testReplicate0TinySLaborious :: Assertion
testReplicate0TinySLaborious =
  assertEqualUpToEpsilon' 1e-10
    (ringestData [1, 1, 1, 1] [582665.99432])
    (rev' @Double @4
          (conv2dUnpadded $ rreplicate0N [1, 1, 1, 1] (rsum0 (rconcrete $ unConcrete t16b)))
          (ringestData [1, 1, 1, 1] [0]))

testReplicate0TinyALaborious :: Assertion
testReplicate0TinyALaborious =
  assertEqualUpToEpsilon' 1e-10
    (ringestData [1, 2, 1, 1] [-0.2,25.0003])
    (rev' @Double @4 conv2dALaborious (rrepl [1, 2, 1, 1] 0))

testReplicate0LittleALaborious :: Assertion
testReplicate0LittleALaborious =
  assertEqualUpToEpsilon' 1e-10
    (ringestData [2, 2, 2, 2] [-0.2,-0.2,-0.2,-0.2,25.0003,25.0003,25.0003,25.0003,-0.2,-0.2,-0.2,-0.2,25.0003,25.0003,25.0003,25.0003])
    (rev' @Double @4 conv2dALaborious (rrepl [2, 2, 2, 2] 0))

-- with data t16

testKonst5LittleBLaborious :: Assertion
testKonst5LittleBLaborious =
  assertEqualUpToEpsilon' 1e-8
    (ringestData [2, 2, 2, 2] [18.1,29.1,32.1,40.1,582932.0,582934.99432,582597.1,582625.8943200001,18.1,29.1,32.1,40.1,582932.0,582934.99432,582597.1,582625.8943200001])
    (rev' @Double @4 conv2dBLaborious (rreplicate0N [2, 2, 2, 2] (rscalar 5)))

testKonst5LittleCLaborious :: Assertion
testKonst5LittleCLaborious =
  assertEqualUpToEpsilon' 1e-8
    (ringestData [2, 2, 2, 2] [40.1,8.0,11.0,-3.0,582625.89432,28.79432,-309.09999999999997,25.8,40.1,8.0,11.0,-3.0,582625.89432,28.79432,-309.09999999999997,25.8])
    (rev' @Double @4 conv2dCLaborious (rreplicate0N [2, 2, 2, 2] (rscalar 5)))

testKonst5BigBLaborious :: Assertion
testKonst5BigBLaborious =
  assertEqualUpToEpsilon' 1e-8
    (ringestData [3, 2, 4, 2] [18.1,29.1,32.1,40.1,32.1,40.1,32.1,40.1,582932.0,582934.99432,582597.1,582625.8943200001,582597.1,582625.8943200001,582597.1,582625.8943200001,18.1,29.1,32.1,40.1,32.1,40.1,32.1,40.1,582932.0,582934.99432,582597.1,582625.8943200001,582597.1,582625.8943200001,582597.1,582625.8943200001,18.1,29.1,32.1,40.1,32.1,40.1,32.1,40.1,582932.0,582934.99432,582597.1,582625.8943200001,582597.1,582625.8943200001,582597.1,582625.8943200001])
    (rev' @Double @4 conv2dBLaborious (rreplicate0N [3, 2, 4, 2] (rscalar 5)))

-- The gradient is the same as above, because one argument is the same
-- and convolution is linear.
testKonstNotBigBLaborious :: Assertion
testKonstNotBigBLaborious =
  assertEqualUpToEpsilon' 1e-8
    (ringestData [3, 2, 4, 2] [18.1,29.1,32.1,40.1,32.1,40.1,32.1,40.1,582932.0,582934.99432,582597.1,582625.8943200001,582597.1,582625.8943200001,582597.1,582625.8943200001,18.1,29.1,32.1,40.1,32.1,40.1,32.1,40.1,582932.0,582934.99432,582597.1,582625.8943200001,582597.1,582625.8943200001,582597.1,582625.8943200001,18.1,29.1,32.1,40.1,32.1,40.1,32.1,40.1,582932.0,582934.99432,582597.1,582625.8943200001,582597.1,582625.8943200001,582597.1,582625.8943200001])
    (rev' @Double @4 conv2dBLaborious
          (rfromList0N [3, 2, 4, 2] (map rscalar [37, 36 .. -10])))

testKonst5BigCLaborious :: Assertion
testKonst5BigCLaborious =
  assertEqualUpToEpsilon' 1e-8
    (ringestData [3, 2, 4, 2] [40.1,8.0,11.0,-3.0,0.0,0.0,0.0,0.0,582625.8943200001,28.794320000000003,-309.09999999999997,25.8,0.0,0.0,0.0,0.0,40.1,8.0,11.0,-3.0,0.0,0.0,0.0,0.0,582625.8943200001,28.794320000000003,-309.09999999999997,25.8,0.0,0.0,0.0,0.0,40.1,8.0,11.0,-3.0,0.0,0.0,0.0,0.0,582625.8943200001,28.794320000000003,-309.09999999999997,25.8,0.0,0.0,0.0,0.0])
    (rev' @Double @4 conv2dCLaborious (rreplicate0N [3, 2, 4, 2] (rscalar 5)))

-- The gradient is the same as above, because one argument is the same
-- and convolution is linear.
testKonstNotBigCLaborious :: Assertion
testKonstNotBigCLaborious =
  assertEqualUpToEpsilon' 1e-8
    (ringestData [3, 2, 4, 2] [40.1,8.0,11.0,-3.0,0.0,0.0,0.0,0.0,582625.8943200001,28.794320000000003,-309.09999999999997,25.8,0.0,0.0,0.0,0.0,40.1,8.0,11.0,-3.0,0.0,0.0,0.0,0.0,582625.8943200001,28.794320000000003,-309.09999999999997,25.8,0.0,0.0,0.0,0.0,40.1,8.0,11.0,-3.0,0.0,0.0,0.0,0.0,582625.8943200001,28.794320000000003,-309.09999999999997,25.8,0.0,0.0,0.0,0.0])
    (rev' @Double @4 conv2dCLaborious
          (rfromList0N [3, 2, 4, 2] (map rscalar [37, 36 .. -10])))

-- with data t128b

testKonst5LittleBLaborious128b :: Assertion
testKonst5LittleBLaborious128b =
  assertEqualUpToEpsilon' 1e-8
    (ringestData [2, 2, 2, 2] [112.3003,251.5006,209.49462,482.69492000000014,3.000000000000032,65.90000000000003,164.10000000000002,365.89432000010004,112.3003,251.5006,209.49462,482.69492000000014,3.000000000000032,65.90000000000003,164.10000000000002,365.89432000010004])
    (rev' @Double @4 conv2dBLaborious128b (rreplicate0N [2, 2, 2, 2] (rscalar 5)))

testKonst5LittleCLaborious128b :: Assertion
testKonst5LittleCLaborious128b =
  assertEqualUpToEpsilon' 1e-8
    (ringestData [2, 2, 2, 2] [1627.8210700004993,1571.2321300004994,1132.9261600005002,1188.6375200005,2725.0393200008984,1831.7390200008983,2551.139320000898,1660.8390200008987,1627.8210700004993,1571.2321300004994,1132.9261600005002,1188.6375200005,2725.0393200008984,1831.7390200008983,2551.139320000898,1660.8390200008987])
    (rev' @Double @4 conv2dCLaborious128b (rreplicate0N [2, 2, 2, 2] (rscalar 5)))

testKonst5BigBLaborious128b :: Assertion
testKonst5BigBLaborious128b =
  assertEqualUpToEpsilon' 1e-8
    (ringestData [3, 2, 4, 2] [112.3003,251.5006,209.49462,482.69492000000014,229.49462000000003,610.5892400000002,56.58894000000004,580.6778800001001,3.000000000000032,65.90000000000003,164.10000000000002,365.89432000010004,667.2003000000001,1060.8778800002,893.3003,1465.6665200003993,112.3003,251.5006,209.49462,482.69492000000014,229.49462000000003,610.5892400000002,56.58894000000004,580.6778800001001,3.000000000000032,65.90000000000003,164.10000000000002,365.89432000010004,667.2003000000001,1060.8778800002,893.3003,1465.6665200003993,112.3003,251.5006,209.49462,482.69492000000014,229.49462000000003,610.5892400000002,56.58894000000004,580.6778800001001,3.000000000000032,65.90000000000003,164.10000000000002,365.89432000010004,667.2003000000001,1060.8778800002,893.3003,1465.6665200003993])
    (rev' @Double @4 conv2dBLaborious128b (rreplicate0N [3, 2, 4, 2] (rscalar 5)))

-- The gradient is the same as above, because one argument is the same
-- and convolution is linear.
testKonstNotBigBLaborious128b :: Assertion
testKonstNotBigBLaborious128b =
  assertEqualUpToEpsilon' 1e-8
    (ringestData [3, 2, 4, 2] [112.3003,251.5006,209.49462,482.69492000000014,229.49462000000003,610.5892400000002,56.58894000000004,580.6778800001001,3.000000000000032,65.90000000000003,164.10000000000002,365.89432000010004,667.2003000000001,1060.8778800002,893.3003,1465.6665200003993,112.3003,251.5006,209.49462,482.69492000000014,229.49462000000003,610.5892400000002,56.58894000000004,580.6778800001001,3.000000000000032,65.90000000000003,164.10000000000002,365.89432000010004,667.2003000000001,1060.8778800002,893.3003,1465.6665200003993,112.3003,251.5006,209.49462,482.69492000000014,229.49462000000003,610.5892400000002,56.58894000000004,580.6778800001001,3.000000000000032,65.90000000000003,164.10000000000002,365.89432000010004,667.2003000000001,1060.8778800002,893.3003,1465.6665200003993])
    (rev' @Double @4 conv2dBLaborious128b
          (rfromList0N [3, 2, 4, 2] (map rscalar [37, 36 .. -10])))

testKonst5BigCLaborious128b :: Assertion
testKonst5BigCLaborious128b =
  assertEqualUpToEpsilon' 1e-8
    (ringestData [3, 2, 4, 2] [1627.8210700004993,1571.2321300004994,1132.9261600005002,1188.6375200005,675.7488800003999,828.6545600004001,215.6659200003,388.5716000003,2725.0393200008984,1831.7390200008983,2551.139320000898,1660.8390200008987,1903.750080000699,1174.5497800006997,854.9778800004001,628.8778800004001,1627.8210700004993,1571.2321300004994,1132.9261600005002,1188.6375200005,675.7488800003999,828.6545600004001,215.6659200003,388.5716000003,2725.0393200008984,1831.7390200008983,2551.139320000898,1660.8390200008987,1903.750080000699,1174.5497800006997,854.9778800004001,628.8778800004001,1627.8210700004993,1571.2321300004994,1132.9261600005002,1188.6375200005,675.7488800003999,828.6545600004001,215.6659200003,388.5716000003,2725.0393200008984,1831.7390200008983,2551.139320000898,1660.8390200008987,1903.750080000699,1174.5497800006997,854.9778800004001,628.8778800004001])
    (rev' @Double @4 conv2dCLaborious128b (rreplicate0N [3, 2, 4, 2] (rscalar 5)))

-- The gradient is the same as above, because one argument is the same
-- and convolution is linear.
testKonstNotBigCLaborious128b :: Assertion
testKonstNotBigCLaborious128b =
  assertEqualUpToEpsilon' 1e-8
    (ringestData [3, 2, 4, 2] [1627.8210700004993,1571.2321300004994,1132.9261600005002,1188.6375200005,675.7488800003999,828.6545600004001,215.6659200003,388.5716000003,2725.0393200008984,1831.7390200008983,2551.139320000898,1660.8390200008987,1903.750080000699,1174.5497800006997,854.9778800004001,628.8778800004001,1627.8210700004993,1571.2321300004994,1132.9261600005002,1188.6375200005,675.7488800003999,828.6545600004001,215.6659200003,388.5716000003,2725.0393200008984,1831.7390200008983,2551.139320000898,1660.8390200008987,1903.750080000699,1174.5497800006997,854.9778800004001,628.8778800004001,1627.8210700004993,1571.2321300004994,1132.9261600005002,1188.6375200005,675.7488800003999,828.6545600004001,215.6659200003,388.5716000003,2725.0393200008984,1831.7390200008983,2551.139320000898,1660.8390200008987,1903.750080000699,1174.5497800006997,854.9778800004001,628.8778800004001])
    (rev' @Double @4 conv2dCLaborious128b
          (rfromList0N [3, 2, 4, 2] (map rscalar [37, 36 .. -10])))

-- with data t128c

testKonst5LittleBLaborious128c :: Assertion
testKonst5LittleBLaborious128c =
  assertEqualUpToEpsilon' 1e-8
    (ringestData [2, 2, 2, 2] [54.100300000000004,111.20060000000001,119.09462,270.29492000000005,58.2,140.3,90.4,212.4,54.100300000000004,111.20060000000001,119.09462,270.29492000000005,58.2,140.3,90.4,212.4])
    (rev' @Double @4 conv2dBLaborious128c (rreplicate0N [2, 2, 2, 2] (rscalar 5)))

testKonst5LittleCLaborious128c :: Assertion
testKonst5LittleCLaborious128c =
  assertEqualUpToEpsilon' 1e-8
    (ringestData [2, 2, 2, 2] [2640.8154000007976,1836.3264600007988,2412.414800000798,1662.026160000799,1712.044990000598,1566.644690000599,1445.5506800005985,1358.3503800005992,2640.8154000007976,1836.3264600007988,2412.414800000798,1662.026160000799,1712.044990000598,1566.644690000599,1445.5506800005985,1358.3503800005992])
    (rev' @Double @4 conv2dCLaborious128c (rreplicate0N [2, 2, 2, 2] (rscalar 5)))

testKonst5BigBLaborious128c :: Assertion
testKonst5BigBLaborious128c =
  assertEqualUpToEpsilon' 1e-8
    (ringestData [3, 2, 4, 2] [54.100300000000004,111.20060000000001,119.09462,270.29492000000005,109.09462000000002,318.19492,174.08894000000004,477.28924000000006,58.2,140.3,90.4,212.4,120.4,292.39432000000005,-117.5,103.38864000010005,54.100300000000004,111.20060000000001,119.09462,270.29492000000005,109.09462000000002,318.19492,174.08894000000004,477.28924000000006,58.2,140.3,90.4,212.4,120.4,292.39432000000005,-117.5,103.38864000010005,54.100300000000004,111.20060000000001,119.09462,270.29492000000005,109.09462000000002,318.19492,174.08894000000004,477.28924000000006,58.2,140.3,90.4,212.4,120.4,292.39432000000005,-117.5,103.38864000010005])
    (rev' @Double @4 conv2dBLaborious128c (rreplicate0N [3, 2, 4, 2] (rscalar 5)))

-- The gradient is the same as above, because one argument is the same
-- and convolution is linear.
testKonstNotBigBLaborious128c :: Assertion
testKonstNotBigBLaborious128c =
  assertEqualUpToEpsilon' 1e-8
    (ringestData [3, 2, 4, 2] [54.100300000000004,111.20060000000001,119.09462,270.29492000000005,109.09462000000002,318.19492,174.08894000000004,477.28924000000006,58.2,140.3,90.4,212.4,120.4,292.39432000000005,-117.5,103.38864000010005,54.100300000000004,111.20060000000001,119.09462,270.29492000000005,109.09462000000002,318.19492,174.08894000000004,477.28924000000006,58.2,140.3,90.4,212.4,120.4,292.39432000000005,-117.5,103.38864000010005,54.100300000000004,111.20060000000001,119.09462,270.29492000000005,109.09462000000002,318.19492,174.08894000000004,477.28924000000006,58.2,140.3,90.4,212.4,120.4,292.39432000000005,-117.5,103.38864000010005])
    (rev' @Double @4 conv2dBLaborious128c
          (rfromList0N [3, 2, 4, 2] (map rscalar [37, 36 .. -10])))

testKonst5BigCLaborious128c :: Assertion
testKonst5BigCLaborious128c =
  assertEqualUpToEpsilon' 1e-8
    (ringestData [3, 2, 4, 2] [2640.8154000007976,1836.3264600007988,2412.414800000798,1662.026160000799,2121.6375200006987,1436.2432000006995,1953.5375200006988,1258.1432000006998,1712.044990000598,1566.644690000599,1445.5506800005985,1358.3503800005992,1279.150680000599,1224.1503800005996,987.1677200004992,962.1674200005002,2640.8154000007976,1836.3264600007988,2412.414800000798,1662.026160000799,2121.6375200006987,1436.2432000006995,1953.5375200006988,1258.1432000006998,1712.044990000598,1566.644690000599,1445.5506800005985,1358.3503800005992,1279.150680000599,1224.1503800005996,987.1677200004992,962.1674200005002,2640.8154000007976,1836.3264600007988,2412.414800000798,1662.026160000799,2121.6375200006987,1436.2432000006995,1953.5375200006988,1258.1432000006998,1712.044990000598,1566.644690000599,1445.5506800005985,1358.3503800005992,1279.150680000599,1224.1503800005996,987.1677200004992,962.1674200005002])
    (rev' @Double @4 conv2dCLaborious128c (rreplicate0N [3, 2, 4, 2] (rscalar 5)))

-- The gradient is the same as above, because one argument is the same
-- and convolution is linear.
testKonstNotBigCLaborious128c :: Assertion
testKonstNotBigCLaborious128c =
  assertEqualUpToEpsilon' 1e-8
    (ringestData [3, 2, 4, 2] [2640.8154000007976,1836.3264600007988,2412.414800000798,1662.026160000799,2121.6375200006987,1436.2432000006995,1953.5375200006988,1258.1432000006998,1712.044990000598,1566.644690000599,1445.5506800005985,1358.3503800005992,1279.150680000599,1224.1503800005996,987.1677200004992,962.1674200005002,2640.8154000007976,1836.3264600007988,2412.414800000798,1662.026160000799,2121.6375200006987,1436.2432000006995,1953.5375200006988,1258.1432000006998,1712.044990000598,1566.644690000599,1445.5506800005985,1358.3503800005992,1279.150680000599,1224.1503800005996,987.1677200004992,962.1674200005002,2640.8154000007976,1836.3264600007988,2412.414800000798,1662.026160000799,2121.6375200006987,1436.2432000006995,1953.5375200006988,1258.1432000006998,1712.044990000598,1566.644690000599,1445.5506800005985,1358.3503800005992,1279.150680000599,1224.1503800005996,987.1677200004992,962.1674200005002])
    (rev' @Double @4 conv2dCLaborious128c
          (rfromList0N [3, 2, 4, 2] (map rscalar [37, 36 .. -10])))

-- with data t128b and t128c

testKonst5LittleBLaborious128bc :: Assertion
testKonst5LittleBLaborious128bc =
  assertEqualUpToEpsilonShort 1e-8
    (ringestData [2,2,8,4] [112.3003,251.5006,417.79492000000005,494.89491000000015,209.49462,482.69492000000014,778.9778800001002,952.0721900001002,229.49462000000003,610.5892400000002,1113.1722000001,1412.1551500001997,56.58894000000004,580.6778800001001,1234.1494800003,1627.8210700004993,56.58894000000004,580.6778800001001,1234.1494800003,1627.8210700004993,56.58894000000004,580.6778800001001,1234.1494800003,1627.8210700004993,56.58894000000004,580.6778800001001,1234.1494800003,1627.8210700004993,56.58894000000004,580.6778800001001,1234.1494800003,1627.8210700004993,3.000000000000032,65.90000000000003,106.90000000000003,173.90000000000006,164.10000000000002,365.89432000010004,593.1946200001,821.2892400002004,667.2003000000001,1060.8778800002,1500.2781800001994,1870.0614400004986,893.3003,1465.6665200003993,2156.3671200003987,2725.039320000898,893.3003,1465.6665200003993,2156.3671200003987,2725.039320000898,893.3003,1465.6665200003993,2156.3671200003987,2725.039320000898,893.3003,1465.6665200003993,2156.3671200003987,2725.039320000898,893.3003,1465.6665200003993,2156.3671200003987,2725.039320000898,112.3003,251.5006,417.79492000000005,494.89491000000015,209.49462,482.69492000000014,778.9778800001002,952.0721900001002,229.49462000000003,610.5892400000002,1113.1722000001,1412.1551500001997,56.58894000000004,580.6778800001001,1234.1494800003,1627.8210700004993,56.58894000000004,580.6778800001001,1234.1494800003,1627.8210700004993,56.58894000000004,580.6778800001001,1234.1494800003,1627.8210700004993,56.58894000000004,580.6778800001001,1234.1494800003,1627.8210700004993,56.58894000000004,580.6778800001001,1234.1494800003,1627.8210700004993,3.000000000000032,65.90000000000003,106.90000000000003,173.90000000000006,164.10000000000002,365.89432000010004,593.1946200001,821.2892400002004,667.2003000000001,1060.8778800002,1500.2781800001994,1870.0614400004986,893.3003,1465.6665200003993,2156.3671200003987,2725.039320000898,893.3003,1465.6665200003993,2156.3671200003987,2725.039320000898,893.3003,1465.6665200003993,2156.3671200003987,2725.039320000898,893.3003,1465.6665200003993,2156.3671200003987,2725.039320000898,893.3003,1465.6665200003993,2156.3671200003987,2725.039320000898])
    (rev' @Double @4 conv2dBLaborious128b t128c)

testKonst5LittleCLaborious128bc :: Assertion
testKonst5LittleCLaborious128bc =
  assertEqualUpToEpsilonShort 1e-8
    (ringestData [2,2,8,4] [1627.8210700004993,1571.2321300004994,1047.1431900004002,393.6715900002,1132.9261600005002,1188.6375200005,803.7488800004002,316.57160000019996,675.7488800003999,828.6545600004001,577.7659200003001,220.57728000019998,215.6659200003,388.5716000003,245.5772800002,94.68864000010001,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,2725.0393200008984,1831.7390200008983,1259.3728000004999,568.6722000005001,2551.139320000898,1660.8390200008987,1151.3728000005,501.6722000005,1903.750080000699,1174.5497800006997,803.9778800004001,340.5775800004001,854.9778800004001,628.8778800004001,450.1892400002,198.8889400002,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1627.8210700004993,1571.2321300004994,1047.1431900004002,393.6715900002,1132.9261600005002,1188.6375200005,803.7488800004002,316.57160000019996,675.7488800003999,828.6545600004001,577.7659200003001,220.57728000019998,215.6659200003,388.5716000003,245.5772800002,94.68864000010001,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,2725.0393200008984,1831.7390200008983,1259.3728000004999,568.6722000005001,2551.139320000898,1660.8390200008987,1151.3728000005,501.6722000005,1903.750080000699,1174.5497800006997,803.9778800004001,340.5775800004001,854.9778800004001,628.8778800004001,450.1892400002,198.8889400002,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0])
    (rev' @Double @4 conv2dCLaborious128b t128c)

testKonst5BigBLaborious128bc :: Assertion
testKonst5BigBLaborious128bc =
  assertEqualUpToEpsilonShort 1e-8
    (ringestData [2,2,8,4] [112.3003,251.5006,417.79492000000005,494.89491000000015,209.49462,482.69492000000014,778.9778800001002,952.0721900001002,229.49462000000003,610.5892400000002,1113.1722000001,1412.1551500001997,56.58894000000004,580.6778800001001,1234.1494800003,1627.8210700004993,56.58894000000004,580.6778800001001,1234.1494800003,1627.8210700004993,56.58894000000004,580.6778800001001,1234.1494800003,1627.8210700004993,56.58894000000004,580.6778800001001,1234.1494800003,1627.8210700004993,56.58894000000004,580.6778800001001,1234.1494800003,1627.8210700004993,3.000000000000032,65.90000000000003,106.90000000000003,173.90000000000006,164.10000000000002,365.89432000010004,593.1946200001,821.2892400002004,667.2003000000001,1060.8778800002,1500.2781800001994,1870.0614400004986,893.3003,1465.6665200003993,2156.3671200003987,2725.039320000898,893.3003,1465.6665200003993,2156.3671200003987,2725.039320000898,893.3003,1465.6665200003993,2156.3671200003987,2725.039320000898,893.3003,1465.6665200003993,2156.3671200003987,2725.039320000898,893.3003,1465.6665200003993,2156.3671200003987,2725.039320000898,112.3003,251.5006,417.79492000000005,494.89491000000015,209.49462,482.69492000000014,778.9778800001002,952.0721900001002,229.49462000000003,610.5892400000002,1113.1722000001,1412.1551500001997,56.58894000000004,580.6778800001001,1234.1494800003,1627.8210700004993,56.58894000000004,580.6778800001001,1234.1494800003,1627.8210700004993,56.58894000000004,580.6778800001001,1234.1494800003,1627.8210700004993,56.58894000000004,580.6778800001001,1234.1494800003,1627.8210700004993,56.58894000000004,580.6778800001001,1234.1494800003,1627.8210700004993,3.000000000000032,65.90000000000003,106.90000000000003,173.90000000000006,164.10000000000002,365.89432000010004,593.1946200001,821.2892400002004,667.2003000000001,1060.8778800002,1500.2781800001994,1870.0614400004986,893.3003,1465.6665200003993,2156.3671200003987,2725.039320000898,893.3003,1465.6665200003993,2156.3671200003987,2725.039320000898,893.3003,1465.6665200003993,2156.3671200003987,2725.039320000898,893.3003,1465.6665200003993,2156.3671200003987,2725.039320000898,893.3003,1465.6665200003993,2156.3671200003987,2725.039320000898])
    (rev' @Double @4 conv2dBLaborious128b t128c)

-- The gradient is the same as above, because one argument is the same
-- and convolution is linear.
testKonstNotBigBLaborious128cb :: Assertion
testKonstNotBigBLaborious128cb =
  assertEqualUpToEpsilonShort 1e-8
    (ringestData [4,2,4,4] [54.100300000000004,111.20060000000001,191.4006,228.4006,119.09462,270.29492000000005,435.28356000009995,519.1778800001,109.09462000000002,318.19492,563.3835600001,687.2778800001003,174.08894000000004,477.28924000000006,774.2665200002001,931.9551600002003,58.2,140.3,226.39432,266.49431000000004,90.4,212.4,343.69432000000006,432.89431000000013,120.4,292.39432000000005,549.78864,724.8772700001001,-117.5,103.38864000010005,459.88296000009996,695.8659100003002,54.100300000000004,111.20060000000001,191.4006,228.4006,119.09462,270.29492000000005,435.28356000009995,519.1778800001,109.09462000000002,318.19492,563.3835600001,687.2778800001003,174.08894000000004,477.28924000000006,774.2665200002001,931.9551600002003,58.2,140.3,226.39432,266.49431000000004,90.4,212.4,343.69432000000006,432.89431000000013,120.4,292.39432000000005,549.78864,724.8772700001001,-117.5,103.38864000010005,459.88296000009996,695.8659100003002,54.100300000000004,111.20060000000001,191.4006,228.4006,119.09462,270.29492000000005,435.28356000009995,519.1778800001,109.09462000000002,318.19492,563.3835600001,687.2778800001003,174.08894000000004,477.28924000000006,774.2665200002001,931.9551600002003,58.2,140.3,226.39432,266.49431000000004,90.4,212.4,343.69432000000006,432.89431000000013,120.4,292.39432000000005,549.78864,724.8772700001001,-117.5,103.38864000010005,459.88296000009996,695.8659100003002,54.100300000000004,111.20060000000001,191.4006,228.4006,119.09462,270.29492000000005,435.28356000009995,519.1778800001,109.09462000000002,318.19492,563.3835600001,687.2778800001003,174.08894000000004,477.28924000000006,774.2665200002001,931.9551600002003,58.2,140.3,226.39432,266.49431000000004,90.4,212.4,343.69432000000006,432.89431000000013,120.4,292.39432000000005,549.78864,724.8772700001001,-117.5,103.38864000010005,459.88296000009996,695.8659100003002])
    (rev' @Double @4 conv2dBLaborious128c t128b)

testKonst5BigCLaborious128cb :: Assertion
testKonst5BigCLaborious128cb =
  assertEqualUpToEpsilonShort 1e-8
    (ringestData [4,2,4,4] [2640.8154000007976,1836.3264600007988,1163.4488800005001,483.7716000003,2412.414800000798,1662.026160000799,1046.2488800005003,446.7716000003,2121.6375200006987,1436.2432000006995,914.5659200004003,399.8772800003,1953.5375200006988,1258.1432000006998,794.3659200004003,359.8772800003,1712.044990000598,1566.644690000599,1143.0671100004001,478.5721900004001,1445.5506800005985,1358.3503800005992,1016.8728000004002,438.47220000040005,1279.150680000599,1224.1503800005996,922.5728000004001,389.3722000004,987.1677200004992,962.1674200005002,710.5841600003,303.48356000030003,2640.8154000007976,1836.3264600007988,1163.4488800005001,483.7716000003,2412.414800000798,1662.026160000799,1046.2488800005003,446.7716000003,2121.6375200006987,1436.2432000006995,914.5659200004003,399.8772800003,1953.5375200006988,1258.1432000006998,794.3659200004003,359.8772800003,1712.044990000598,1566.644690000599,1143.0671100004001,478.5721900004001,1445.5506800005985,1358.3503800005992,1016.8728000004002,438.47220000040005,1279.150680000599,1224.1503800005996,922.5728000004001,389.3722000004,987.1677200004992,962.1674200005002,710.5841600003,303.48356000030003,2640.8154000007976,1836.3264600007988,1163.4488800005001,483.7716000003,2412.414800000798,1662.026160000799,1046.2488800005003,446.7716000003,2121.6375200006987,1436.2432000006995,914.5659200004003,399.8772800003,1953.5375200006988,1258.1432000006998,794.3659200004003,359.8772800003,1712.044990000598,1566.644690000599,1143.0671100004001,478.5721900004001,1445.5506800005985,1358.3503800005992,1016.8728000004002,438.47220000040005,1279.150680000599,1224.1503800005996,922.5728000004001,389.3722000004,987.1677200004992,962.1674200005002,710.5841600003,303.48356000030003,2640.8154000007976,1836.3264600007988,1163.4488800005001,483.7716000003,2412.414800000798,1662.026160000799,1046.2488800005003,446.7716000003,2121.6375200006987,1436.2432000006995,914.5659200004003,399.8772800003,1953.5375200006988,1258.1432000006998,794.3659200004003,359.8772800003,1712.044990000598,1566.644690000599,1143.0671100004001,478.5721900004001,1445.5506800005985,1358.3503800005992,1016.8728000004002,438.47220000040005,1279.150680000599,1224.1503800005996,922.5728000004001,389.3722000004,987.1677200004992,962.1674200005002,710.5841600003,303.48356000030003])
    (rev' @Double @4 conv2dCLaborious128c t128b)

-- The gradient is the same as above, because one argument is the same
-- and convolution is linear.
testKonstNotBigCLaborious128cb :: Assertion
testKonstNotBigCLaborious128cb =
  assertEqualUpToEpsilonShort 1e-8
    (ringestData [4,2,4,4] [2640.8154000007976,1836.3264600007988,1163.4488800005001,483.7716000003,2412.414800000798,1662.026160000799,1046.2488800005003,446.7716000003,2121.6375200006987,1436.2432000006995,914.5659200004003,399.8772800003,1953.5375200006988,1258.1432000006998,794.3659200004003,359.8772800003,1712.044990000598,1566.644690000599,1143.0671100004001,478.5721900004001,1445.5506800005985,1358.3503800005992,1016.8728000004002,438.47220000040005,1279.150680000599,1224.1503800005996,922.5728000004001,389.3722000004,987.1677200004992,962.1674200005002,710.5841600003,303.48356000030003,2640.8154000007976,1836.3264600007988,1163.4488800005001,483.7716000003,2412.414800000798,1662.026160000799,1046.2488800005003,446.7716000003,2121.6375200006987,1436.2432000006995,914.5659200004003,399.8772800003,1953.5375200006988,1258.1432000006998,794.3659200004003,359.8772800003,1712.044990000598,1566.644690000599,1143.0671100004001,478.5721900004001,1445.5506800005985,1358.3503800005992,1016.8728000004002,438.47220000040005,1279.150680000599,1224.1503800005996,922.5728000004001,389.3722000004,987.1677200004992,962.1674200005002,710.5841600003,303.48356000030003,2640.8154000007976,1836.3264600007988,1163.4488800005001,483.7716000003,2412.414800000798,1662.026160000799,1046.2488800005003,446.7716000003,2121.6375200006987,1436.2432000006995,914.5659200004003,399.8772800003,1953.5375200006988,1258.1432000006998,794.3659200004003,359.8772800003,1712.044990000598,1566.644690000599,1143.0671100004001,478.5721900004001,1445.5506800005985,1358.3503800005992,1016.8728000004002,438.47220000040005,1279.150680000599,1224.1503800005996,922.5728000004001,389.3722000004,987.1677200004992,962.1674200005002,710.5841600003,303.48356000030003,2640.8154000007976,1836.3264600007988,1163.4488800005001,483.7716000003,2412.414800000798,1662.026160000799,1046.2488800005003,446.7716000003,2121.6375200006987,1436.2432000006995,914.5659200004003,399.8772800003,1953.5375200006988,1258.1432000006998,794.3659200004003,359.8772800003,1712.044990000598,1566.644690000599,1143.0671100004001,478.5721900004001,1445.5506800005985,1358.3503800005992,1016.8728000004002,438.47220000040005,1279.150680000599,1224.1503800005996,922.5728000004001,389.3722000004,987.1677200004992,962.1674200005002,710.5841600003,303.48356000030003])
    (rev' @Double @4 conv2dCLaborious128c t128b)


-- * Disparity

-- | Disparity cost volume.
--
--   Take two arrays of multi channel 2d images, where the first contains
--   left views of the scene and the second contains right views.
--
--   For each pair of images, slice the right image over the left image,
--   and for each offset produce the L1 distance indicating how well
--   correponding
--   multi-channel image elements in the right image match those in the left.
--
--   Described in:
--    Anytime Stereo Image Depth Estimation on Mobile Devices
--    Wang, Lai et al, ICRA 2019
--    https://arxiv.org/abs/1810.11408
--    Section III b).
--
costVolume
  :: forall r target. (ADReady target, GoodScalar r)
  => Int -> Int -> target (TKR 4 r) -> target (TKR 4 r) -> target (TKR 4 r)
costVolume iStart nCount arrL arrR =
  let [nImgs, nChas, nRows, nCols] = rshape arrL
      shO = [nImgs, nCount, nRows, nCols]
  in rbuild shO $ \[iImg, iDisp, iRow, iCol] ->
       let arrVecL = rbuild (nChas :$: ZSR) $ \[iCha] ->
                       indexz0 arrL [iImg, iCha, iRow, iCol]
           iSrc = iCol - fromIntegral iStart - iDisp
           arrVecR = rbuild [nChas] $ \[iCha] ->
                       indexz0 arrR [iImg, iCha, iRow, iSrc]
       in rsum0 $ rzipWith1 (\xL xR -> abs (xL - xR)) arrVecL arrVecR

test_disparityKonst :: Assertion
test_disparityKonst = do
  let arrL :: ADReady target => target (TKR 4 Double)
      arrL = rreplicate0N [1, 2, 4, 6] (rscalar (-0.2))
      arrR :: ADReady target => target (TKR 4 Double)
      arrR = rreplicate0N [1, 2, 4, 6] (rscalar 0.3)
      arrO = costVolume @Double 0 4 arrL arrR
      arrDL = vjp (\aL -> costVolume 0 4 aL (rfromPrimal arrR)) arrL arrO
      arrDR = vjp (\aR -> costVolume 0 4 (rfromPrimal arrL) aR) arrR arrO
  assertEqualUpToEpsilon 1e-7
    (rconcrete $ Nested.rfromListPrimLinear [1,4,4,6] [1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,0.4,1.0,1.0,1.0,1.0,1.0,0.4,1.0,1.0,1.0,1.0,1.0,0.4,1.0,1.0,1.0,1.0,1.0,0.4,1.0,1.0,1.0,1.0,1.0,0.4,0.4,1.0,1.0,1.0,1.0,0.4,0.4,1.0,1.0,1.0,1.0,0.4,0.4,1.0,1.0,1.0,1.0,0.4,0.4,1.0,1.0,1.0,1.0,0.4,0.4,0.4,1.0,1.0,1.0,0.4,0.4,0.4,1.0,1.0,1.0,0.4,0.4,0.4,1.0,1.0,1.0,0.4,0.4,0.4,1.0,1.0,1.0])
    arrO
  assertEqualUpToEpsilon 1e-7
    (rconcrete $ Nested.rfromListPrimLinear [1,2,4,6] [-2.2,-2.8,-3.4,-4.0,-4.0,-4.0,-2.2,-2.8,-3.4,-4.0,-4.0,-4.0,-2.2,-2.8,-3.4,-4.0,-4.0,-4.0,-2.2,-2.8,-3.4,-4.0,-4.0,-4.0,-2.2,-2.8,-3.4,-4.0,-4.0,-4.0,-2.2,-2.8,-3.4,-4.0,-4.0,-4.0,-2.2,-2.8,-3.4,-4.0,-4.0,-4.0,-2.2,-2.8,-3.4,-4.0,-4.0,-4.0])
    arrDL
  assertEqualUpToEpsilon 1e-7
    (rconcrete $ Nested.rfromListPrimLinear [1,2,4,6] [4.0,4.0,4.0,3.0,2.0,1.0,4.0,4.0,4.0,3.0,2.0,1.0,4.0,4.0,4.0,3.0,2.0,1.0,4.0,4.0,4.0,3.0,2.0,1.0,4.0,4.0,4.0,3.0,2.0,1.0,4.0,4.0,4.0,3.0,2.0,1.0,4.0,4.0,4.0,3.0,2.0,1.0,4.0,4.0,4.0,3.0,2.0,1.0])
   arrDR
  assertEqualUpToEpsilon' 1e-7
    (ringestData [1,2,4,6] [4.0,4.0,4.0,3.0,2.0,1.0,4.0,4.0,4.0,3.0,2.0,1.0,4.0,4.0,4.0,3.0,2.0,1.0,4.0,4.0,4.0,3.0,2.0,1.0,4.0,4.0,4.0,3.0,2.0,1.0,4.0,4.0,4.0,3.0,2.0,1.0,4.0,4.0,4.0,3.0,2.0,1.0,4.0,4.0,4.0,3.0,2.0,1.0])
    (rev' @Double @4 (costVolume 0 4 arrL) arrR)
  assertEqualUpToEpsilon' 1e-7
    (ringestData [1,2,4,6] [-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0,-2.0])
    (rev' @Double @4 (\aL -> costVolume 0 2 aL arrR) arrL)
  assertEqualUpToEpsilon' 1e-7
    (ringestData [1,2,4,6] [2.0,2.0,2.0,2.0,2.0,1.0,2.0,2.0,2.0,2.0,2.0,1.0,2.0,2.0,2.0,2.0,2.0,1.0,2.0,2.0,2.0,2.0,2.0,1.0,2.0,2.0,2.0,2.0,2.0,1.0,2.0,2.0,2.0,2.0,2.0,1.0,2.0,2.0,2.0,2.0,2.0,1.0,2.0,2.0,2.0,2.0,2.0,1.0])
    (rev' @Double @4 (costVolume 0 2 arrL) arrR)

test_disparityKonst2 :: Assertion
test_disparityKonst2 = do
  let arrL :: (BaseTensor target, GoodScalar r, Differentiable r) => target (TKR 4 r)
      arrL = ringestData [1, 2, 4, 6] [0.4,0.4,0.4,1.0,1.0,1.0,0.4,0.4,0.4,1.0,1.0,1.0,0.4,0.4,0.4,1.0,1.0,1.0, 1.7041241452319316,1.21999,0.21355339059327375,0.7867666666666666,0.7331698975466578,0.6964466094067263,1.1,1.1041141452319316,0.42000000000000004,0.3536533905932737,0.78,1.253169897546658,1.1,0.50001,0.42000000000000004,0.2801,0.78,1.3,1.1,0.50001,0.42000000000000004,0.2801,0.78,1.3,2.808238290463863,1.21999,-0.5672067811865474,0.7867666666666666,1.986339795093316,0.6964466094067263]
      arrR :: (BaseTensor target, GoodScalar r, Differentiable r) => target (TKR 4 r)
      arrR = ringestData [1, 2, 4, 6] [0.2, 0.5, -0.2, 0.0001, 0.44, 0.9, -0.9, 0.00001, -0.22, -0.28, -0.34, -0.40, -0.40,-0.22,-0.28,-0.34, 0.22360679774997896,0.35355339059327373,0.20412414523193154,0.5, -0.35355339059327373,0.16666666666666666,0.17677669529663687,-0.25, -2.808238290463863,-1.21999,-0.5672067811865474,-0.7867666666666666,-1.986339795093316,-0.6964466094067263,2.808238290463863,1.21999,-0.5672067811865474,0.7867666666666666,0.6964466094067263,0.42000000000000004,0.3536533905932737,0.78,1.253169897546658,0.50001,0.42000000000000004,0.2801,0.78,1.1,0.50001,0.42000000000000004,0.2801,0.78]
      arrO = rreplicate0N [1, 4, 4, 6] (rscalar (1 :: Double))
      res1 = rconcrete $ Nested.rfromListPrimLinear [1,2,4,6] [4.0,2.0,2.0,4.0,4.0,4.0,4.0,4.0,4.0,4.0,4.0,4.0,4.0,4.0,4.0,4.0,4.0,4.0,4.0,4.0,2.0,4.0,4.0,4.0,4.0,4.0,4.0,4.0,4.0,4.0,2.0,0.0,0.0,-2.0,0.0,4.0,4.0,2.0,0.0,-4.0,1.0,4.0,4.0,4.0,-4.0,2.0,4.0,2.0]
      res2 = rconcrete $ Nested.rfromListPrimLinear [1,2,4,6] [-4.0,0.0,-4.0,-3.0,-2.0,-1.0,-4.0,-4.0,-4.0,-3.0,-2.0,-1.0,-4.0,-4.0,-4.0,-3.0,-2.0,-1.0,-4.0,-2.0,-4.0,-3.0,-2.0,-1.0,-4.0,-4.0,-4.0,-3.0,-2.0,-1.0,4.0,4.0,-4.0,1.0,-2.0,-1.0,-2.0,3.0,2.0,-1.0,-2.0,-1.0,-2.0,0.0,-2.0,-3.0,-2.0,1.0]
      arrDL :: Concrete (TKR 4 Double)
      arrDL = vjp (\aL -> costVolume 0 4 aL (rfromPrimal arrR)) arrL arrO
      arrDR :: Concrete (TKR 4 Double)
      arrDR = vjp (costVolume 0 4 (rfromPrimal arrL)) arrR arrO
  assertEqualUpToEpsilon 1e-7
    res1
    arrDL
  assertEqualUpToEpsilon 1e-7
    res2
    arrDR
  assertEqualUpToEpsilon' 1e-7
    res1
    (rev' @Double @4 (\aL -> costVolume 0 4 aL (rfromPrimal arrR)) arrL)
  assertEqualUpToEpsilon' 1e-7
    res2
    (rev' @Double @4 (costVolume 0 4 (rfromPrimal arrL)) arrR)

test_disparitySmall :: Assertion
test_disparitySmall = do
  let arrL :: ADReady target => target (TKR 4 Double)
      arrL = ringestData [1, 2, 3, 2] [0.2, 0.5, -0.2, 0.0001, 0.44, 0.9, -0.9, 0.00001, -0.22, -0.28, -0.34, -0.40]
      arrR :: ADReady target => target (TKR 4 Double)
      arrR = ringestData [1, 2, 3, 2] [-0.40,-0.22,-0.28,-0.34, 0.22360679774997896,0.35355339059327373,0.20412414523193154,0.5, -0.35355339059327373,0.16666666666666666,0.17677669529663687,-0.25]
      arrO = costVolume @Double 0 4 arrL arrR
      arrDL = vjp (\aL -> costVolume 0 4 aL (rfromPrimal arrR)) arrL arrO
      arrDR = vjp (\aR -> costVolume 0 4 (rfromPrimal arrL) aR) arrR arrO
  assertEqualUpToEpsilon 1e-7
    (rconcrete $ Nested.rfromListPrimLinear [1,4,3,2] [1.7041241452319316,1.21999,0.21355339059327375,0.7867666666666666,0.7331698975466578,0.6964466094067263,1.1,1.1041141452319316,0.42000000000000004,0.3536533905932737,0.78,1.253169897546658,1.1,0.50001,0.42000000000000004,0.2801,0.78,1.3,1.1,0.50001,0.42000000000000004,0.2801,0.78,1.3])
    arrO
  assertEqualUpToEpsilon' 1e-7
    (ringestData [1,2,3,2] [-2.0,-1.0,-2.0,-1.0,-2.0,-1.0,2.0,1.0,-2.0,1.0,2.0,1.0])
    (rev' @Double @4 (costVolume 0 4 arrL) arrR)
  assertEqualUpToEpsilon 1e-7
    (rconcrete $ Nested.rfromListPrimLinear [1,2,3,2] [5.004124145231932,3.3241241452319317,-1.0464466094067264,1.7006200572599404,3.0731698975466575,4.5496165069533845,-5.004124145231932,-1.3240841452319316,-1.0464466094067264,-0.9933132760733929,-3.0731698975466575,-4.5496165069533845])
    arrDL
  assertEqualUpToEpsilon 1e-7
    (rconcrete $ Nested.rfromListPrimLinear [1,2,3,2] [-2.808238290463863,-1.21999,-0.5672067811865474,-0.7867666666666666,-1.986339795093316,-0.6964466094067263,2.808238290463863,1.21999,-0.5672067811865474,0.7867666666666666,1.986339795093316,0.6964466094067263])
   arrDR
  assertEqualUpToEpsilon' 1e-7
    (ringestData [1,2,3,2] [-1.0,0.0,-1.0,0.0,-1.0,0.0,1.0,0.0,-1.0,0.0,1.0,0.0])
    (rev' @Double @4 (costVolume 1 4 arrL) arrR)
  assertEqualUpToEpsilon' 1e-7
    (ringestData [1,2,3,2] [2.0,2.0,-2.0,2.0,2.0,2.0,-2.0,2.0,-2.0,-2.0,-2.0,-2.0])
    (rev' @Double @4 (\aL -> costVolume 2 2 aL arrR) arrL)
  assertEqualUpToEpsilon' 1e-7
    (ringestData [1,2,3,2] [-1.0,0.0,-1.0,0.0,-1.0,0.0,1.0,0.0,-1.0,0.0,1.0,0.0])
    (rev' @Double @4 (costVolume 1 2 arrL) arrR)


-- * PP Tests

testCNNOPP0c :: Assertion
testCNNOPP0c = do
  resetVarCounter
  let artifactRev = revArtifactAdapt UseIncomingCotangent conv2dCLaborious (FTKR [2, 2, 2, 2] (FTKScalar @Double))
  printArtifactPrimalPretty artifactRev
    @?= "\\u1 -> let w51 = str (sreplicate @2 (sgather (sfromVector (fromList [sgather (sconcrete (sfromListLinear [2,2,2,2] [5.0,2.0,6.0,1.0,-2.0,0.0,0.1,-0.2,13.1,9.0,8.0,-4.0,582934.0,2.99432,-335.0,26.0])) (\\[i33, i34, i35, i36, i37, i38, i39] -> [i33 + i36, i37, i34 + i38, i35 + i39]), sreplicate @2 (sreplicate @2 (sreplicate @2 (sreplicate @1 (sreplicate @2 (sreplicate @2 (sreplicate @2 (sscalar 0.0)))))))])) (\\[i40, i41, i42, i43, i44, i45, i46] -> [ifH (notB (2 <=. i40 + i43) &&* (notB (2 <=. i41 + i45) &&* notB (2 <=. i42 + i46))) 0 1, i40, i41, i42, i43, i44, i45, i46]))) ; w52 = sreplicate @2 (str (sreplicate @2 (str (sreplicate @2 (sgather (sfromVector (fromList [sgather (sfromR u1) (\\[i47, i48] -> [i47 + i48]), sreplicate @2 (sreplicate @1 (sreplicate @2 (sreplicate @2 (sreplicate @2 (sscalar 0.0)))))])) (\\[i49, i50] -> [ifH (2 <=. i49 + i50) 1 0, i49, i50])))))) in rfromS (ssum @8 (stranspose @[4,0,1,2,3] (sreshape @[2,2,2,2,8] (w51 * w52))))"
  printArtifactPrimalPretty (simplifyArtifact artifactRev)
    @?= "\\u1 -> rfromS (ssum @8 (stranspose @[4,0,1,2,3] (sreshape @[2,2,2,2,8] (str (sreplicate @2 (stranspose @[0,1,2,3,6,4,5] (sgather (stranspose @[4,3,2,1,0,6,7,5] (sfromVector (fromList [stranspose @[0,1,2,3,6,4,5] (sgather (sconcrete (sfromListLinear [2,2,2,2] [5.0,-2.0,2.0,0.0,6.0,0.1,1.0,-0.2,13.1,582934.0,9.0,2.99432,8.0,-335.0,-4.0,26.0])) (\\[i33, i34, i35, i36, i38, i39] -> [i33 + i36, i34 + i38, i35 + i39])), sconcrete (sfromListLinear [2,2,2,1,2,2,2] [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0])]))) (\\[i40, i41, i42, i43, i45, i46] -> [i43, i42, i41, i40, ifH (notB (2 <=. i40 + i43) &&* (notB (2 <=. i41 + i45) &&* notB (2 <=. i42 + i46))) 0 1, i45, i46])))) * sreplicate @2 (str (sreplicate @2 (str (sreplicate @2 (sgather (sfromVector (fromList [sgather (sfromR u1) (\\[i47, i48] -> [i47 + i48]), sconcrete (sfromListLinear [2,1,2,2,2] [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0])])) (\\[i49, i50] -> [ifH (2 <=. i49 + i50) 1 0, i49, i50]))))))))))"
  printArtifactPretty artifactRev
    @?= "\\dret u1 -> let w51 = str (sreplicate @2 (sgather (sfromVector (fromList [sgather (sconcrete (sfromListLinear [2,2,2,2] [5.0,2.0,6.0,1.0,-2.0,0.0,0.1,-0.2,13.1,9.0,8.0,-4.0,582934.0,2.99432,-335.0,26.0])) (\\[i33, i34, i35, i36, i37, i38, i39] -> [i33 + i36, i37, i34 + i38, i35 + i39]), sreplicate @2 (sreplicate @2 (sreplicate @2 (sreplicate @1 (sreplicate @2 (sreplicate @2 (sreplicate @2 (sscalar 0.0)))))))])) (\\[i40, i41, i42, i43, i44, i45, i46] -> [ifH (notB (2 <=. i40 + i43) &&* (notB (2 <=. i41 + i45) &&* notB (2 <=. i42 + i46))) 0 1, i40, i41, i42, i43, i44, i45, i46]))) ; w56 = sscatter (ssum @2 (str (ssum @2 (str (ssum @2 (w51 * sreshape @[2,2,2,2,1,2,2,2] (stranspose @[1,2,3,4,0] (sreplicate @8 (sfromR dret))))))))) (\\[i54, i55] -> [ifH (2 <=. i54 + i55) 1 0, i54, i55]) in rfromS (sscatter (w56 !$ [0]) (\\[i57, i58] -> [i57 + i58]))"
  printArtifactPretty (simplifyArtifact artifactRev)
    @?= "\\dret u1 -> rfromS (sscatter (sscatter (ssum @2 (ssum @2 (ssdot1In (stranspose @[2,3,0,4,5,6,7,1] (sreplicate @2 (stranspose @[0,1,2,3,6,4,5] (sgather (stranspose @[4,3,2,1,0,6,7,5] (sfromVector (fromList [stranspose @[0,1,2,3,6,4,5] (sgather (sconcrete (sfromListLinear [2,2,2,2] [5.0,-2.0,2.0,0.0,6.0,0.1,1.0,-0.2,13.1,582934.0,9.0,2.99432,8.0,-335.0,-4.0,26.0])) (\\[i33, i34, i35, i36, i38, i39] -> [i33 + i36, i34 + i38, i35 + i39])), sconcrete (sfromListLinear [2,2,2,1,2,2,2] [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0])]))) (\\[i40, i41, i42, i43, i45, i46] -> [i43, i42, i41, i40, ifH (notB (2 <=. i40 + i43) &&* (notB (2 <=. i41 + i45) &&* notB (2 <=. i42 + i46))) 0 1, i45, i46]))))) (stranspose @[2,3,1,4,5,6,7,0] (sreshape @[2,2,2,2,1,2,2,2] (stranspose @[1,2,3,4,0] (sreplicate @8 (sfromR dret)))))))) (\\[i54, i55] -> [ifH (2 <=. i54 + i55) 1 0, i54, i55]) !$ [0]) (\\[i57, i58] -> [i57 + i58]))"

testCNNOPP0b :: Assertion
testCNNOPP0b = do
  resetVarCounter
  let artifactRev = revArtifactAdapt UseIncomingCotangent conv2dBLaborious (FTKR [2, 2, 2, 2] (FTKScalar @Double))
  printArtifactPrimalPretty artifactRev
    @?= "\\u1 -> let w51 = str (sreplicate @2 (sgather (sfromVector (fromList [sgather (sfromR u1) (\\[i33, i34, i35, i36, i37, i38, i39] -> [i33 + i36, i37, i34 + i38, i35 + i39]), sreplicate @2 (sreplicate @2 (sreplicate @2 (sreplicate @1 (sreplicate @2 (sreplicate @2 (sreplicate @2 (sscalar 0.0)))))))])) (\\[i40, i41, i42, i43, i44, i45, i46] -> [ifH (notB (2 <=. i40 + i43) &&* (notB (2 <=. i41 + i45) &&* notB (2 <=. i42 + i46))) 0 1, i40, i41, i42, i43, i44, i45, i46]))) ; w52 = sreplicate @2 (str (sreplicate @2 (str (sreplicate @2 (sgather (sfromVector (fromList [sgather (sconcrete (sfromListLinear [2,2,2,2] [5.0,2.0,6.0,1.0,-2.0,0.0,0.1,-0.2,13.1,9.0,8.0,-4.0,582934.0,2.99432,-335.0,26.0])) (\\[i47, i48] -> [i47 + i48]), sreplicate @2 (sreplicate @1 (sreplicate @2 (sreplicate @2 (sreplicate @2 (sscalar 0.0)))))])) (\\[i49, i50] -> [ifH (2 <=. i49 + i50) 1 0, i49, i50])))))) in rfromS (ssum @8 (stranspose @[4,0,1,2,3] (sreshape @[2,2,2,2,8] (w51 * w52))))"
  printArtifactPrimalPretty (simplifyArtifact artifactRev)
    @?= "\\u1 -> rfromS (ssum @8 (stranspose @[4,0,1,2,3] (sreshape @[2,2,2,2,8] (str (sreplicate @2 (stranspose @[0,1,2,3,6,4,5] (sgather (stranspose @[4,3,2,1,0,6,7,5] (sfromVector (fromList [stranspose @[0,1,2,3,6,4,5] (sgather (stranspose @[0,2,3,1] (sfromR u1)) (\\[i33, i34, i35, i36, i38, i39] -> [i33 + i36, i34 + i38, i35 + i39])), sconcrete (sfromListLinear [2,2,2,1,2,2,2] [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0])]))) (\\[i40, i41, i42, i43, i45, i46] -> [i43, i42, i41, i40, ifH (notB (2 <=. i40 + i43) &&* (notB (2 <=. i41 + i45) &&* notB (2 <=. i42 + i46))) 0 1, i45, i46])))) * sreplicate @2 (str (sreplicate @2 (str (sreplicate @2 (sgather (sfromVector (fromList [sgather (sconcrete (sfromListLinear [2,2,2,2] [5.0,2.0,6.0,1.0,-2.0,0.0,0.1,-0.2,13.1,9.0,8.0,-4.0,582934.0,2.99432,-335.0,26.0])) (\\[i47, i48] -> [i47 + i48]), sconcrete (sfromListLinear [2,1,2,2,2] [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0])])) (\\[i49, i50] -> [ifH (2 <=. i49 + i50) 1 0, i49, i50]))))))))))"
  printArtifactPretty artifactRev
    @?= "\\dret u1 -> let w52 = sreplicate @2 (str (sreplicate @2 (str (sreplicate @2 (sgather (sfromVector (fromList [sgather (sconcrete (sfromListLinear [2,2,2,2] [5.0,2.0,6.0,1.0,-2.0,0.0,0.1,-0.2,13.1,9.0,8.0,-4.0,582934.0,2.99432,-335.0,26.0])) (\\[i47, i48] -> [i47 + i48]), sreplicate @2 (sreplicate @1 (sreplicate @2 (sreplicate @2 (sreplicate @2 (sscalar 0.0)))))])) (\\[i49, i50] -> [ifH (2 <=. i49 + i50) 1 0, i49, i50])))))) ; w61 = sscatter (ssum @2 (str (w52 * sreshape @[2,2,2,2,1,2,2,2] (stranspose @[1,2,3,4,0] (sreplicate @8 (sfromR dret)))))) (\\[i54, i55, i56, i57, i58, i59, i60] -> [ifH (notB (2 <=. i54 + i57) &&* (notB (2 <=. i55 + i59) &&* notB (2 <=. i56 + i60))) 0 1, i54, i55, i56, i57, i58, i59, i60]) in rfromS (sscatter (w61 !$ [0]) (\\[i62, i63, i64, i65, i66, i67, i68] -> [i62 + i65, i66, i63 + i67, i64 + i68]))"
  printArtifactPretty (simplifyArtifact artifactRev)
    @?= "\\dret u1 -> rfromS (sscatter (sscatter (ssdot1In (stranspose @[0,2,3,4,5,6,7,1] (sreplicate @2 (str (sreplicate @2 (str (sreplicate @2 (sgather (sfromVector (fromList [sgather (sconcrete (sfromListLinear [2,2,2,2] [5.0,2.0,6.0,1.0,-2.0,0.0,0.1,-0.2,13.1,9.0,8.0,-4.0,582934.0,2.99432,-335.0,26.0])) (\\[i47, i48] -> [i47 + i48]), sconcrete (sfromListLinear [2,1,2,2,2] [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0])])) (\\[i49, i50] -> [ifH (2 <=. i49 + i50) 1 0, i49, i50])))))))) (stranspose @[0,2,3,4,5,6,7,1] (sreshape @[2,2,2,2,1,2,2,2] (stranspose @[1,2,3,4,0] (sreplicate @8 (sfromR dret)))))) (\\[i54, i55, i56, i57, i58, i59, i60] -> [ifH (notB (2 <=. i54 + i57) &&* (notB (2 <=. i55 + i59) &&* notB (2 <=. i56 + i60))) 0 1, i54, i55, i56, i57, i58, i59, i60]) !$ [0]) (\\[i62, i63, i64, i65, i66, i67, i68] -> [i62 + i65, i66, i63 + i67, i64 + i68]))"

testCNNOPP1e :: Assertion
testCNNOPP1e = do
  resetVarCounter
  let f :: AstTensor AstMethodLet FullSpan
                     (TKProduct (TKR 4 Double) (TKR 4 Double))
        -> AstTensor AstMethodLet FullSpan
                     (TKR 4 Double)
      f v = conv2dUnpadded (tproject1 v) (tproject2 v)
      ftk = FTKProduct (FTKR (2 :$: 2 :$: 2 :$: 2 :$: ZSR) FTKScalar)
                       (FTKR (2 :$: 2 :$: 2 :$: 2 :$: ZSR) FTKScalar)
      (artifactRev, _) =
        revArtifactFromForwardPass
          UseIncomingCotangent (forwardPassByInterpretation f emptyEnv) ftk
  printAstPretty (simplifyInline $ artPrimalRev artifactRev)
    @?= "rfromS (ssum @8 (stranspose @[4,0,1,2,3] (sreshape @[2,2,2,2,8] (str (sreplicate @2 (stranspose @[0,1,2,3,6,4,5] (sgather (stranspose @[4,3,2,1,0,6,7,5] (sfromVector (fromList [stranspose @[0,1,2,3,6,4,5] (sgather (stranspose @[0,2,3,1] (sfromR (tproject2 u1))) (\\[i33, i34, i35, i36, i38, i39] -> [i33 + i36, i34 + i38, i35 + i39])), sreplicate @2 (sreplicate @2 (sreplicate @2 (sreplicate @1 (sreplicate @2 (sreplicate @2 (sreplicate @2 (sscalar 0.0)))))))]))) (\\[i40, i41, i42, i43, i45, i46] -> [i43, i42, i41, i40, ifH (notB (2 <=. i40 + i43) &&* (notB (2 <=. i41 + i45) &&* notB (2 <=. i42 + i46))) 0 1, i45, i46])))) * sreplicate @2 (str (sreplicate @2 (str (sreplicate @2 (sgather (sfromVector (fromList [sgather (sfromR (tproject1 u1)) (\\[i47, i48] -> [i47 + i48]), sreplicate @2 (sreplicate @1 (sreplicate @2 (sreplicate @2 (sreplicate @2 (sscalar 0.0)))))])) (\\[i49, i50] -> [ifH (2 <=. i49 + i50) 1 0, i49, i50]))))))))))"
  printArtifactPretty (simplifyArtifact artifactRev)
    @?= "\\dret u1 -> tfromS (STKProduct (STKR (SNat @4) STKScalar) (STKR (SNat @4) STKScalar)) (let w54 = sreshape @[2,2,2,2,1,2,2,2] (stranspose @[1,2,3,4,0] (sreplicate @8 (sfromR dret))) in tpair (sscatter (sscatter (ssum @2 (ssum @2 (ssdot1In (stranspose @[2,3,0,4,5,6,7,1] (sreplicate @2 (stranspose @[0,1,2,3,6,4,5] (sgather (stranspose @[4,3,2,1,0,6,7,5] (sfromVector (fromList [stranspose @[0,1,2,3,6,4,5] (sgather (stranspose @[0,2,3,1] (sfromR (tproject2 u1))) (\\[i33, i34, i35, i36, i38, i39] -> [i33 + i36, i34 + i38, i35 + i39])), sconcrete (sfromListLinear [2,2,2,1,2,2,2] [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0])]))) (\\[i40, i41, i42, i43, i45, i46] -> [i43, i42, i41, i40, ifH (notB (2 <=. i40 + i43) &&* (notB (2 <=. i41 + i45) &&* notB (2 <=. i42 + i46))) 0 1, i45, i46]))))) (stranspose @[2,3,1,4,5,6,7,0] w54)))) (\\[i55, i56] -> [ifH (2 <=. i55 + i56) 1 0, i55, i56]) !$ [0]) (\\[i58, i59] -> [i58 + i59])) (sscatter (sscatter (ssdot1In (stranspose @[0,2,3,4,5,6,7,1] (sreplicate @2 (str (sreplicate @2 (str (sreplicate @2 (sgather (sfromVector (fromList [sgather (sfromR (tproject1 u1)) (\\[i47, i48] -> [i47 + i48]), sconcrete (sfromListLinear [2,1,2,2,2] [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0])])) (\\[i49, i50] -> [ifH (2 <=. i49 + i50) 1 0, i49, i50])))))))) (stranspose @[0,2,3,4,5,6,7,1] w54)) (\\[i60, i61, i62, i63, i64, i65, i66] -> [ifH (notB (2 <=. i60 + i63) &&* (notB (2 <=. i61 + i65) &&* notB (2 <=. i62 + i66))) 0 1, i60, i61, i62, i63, i64, i65, i66]) !$ [0]) (\\[i68, i69, i70, i71, i72, i73, i74] -> [i68 + i71, i72, i69 + i73, i70 + i74])))"

-- This is fragile due to indexing out of bounds, see above.
testCNNOPP1b :: Assertion
testCNNOPP1b = do
  resetVarCounter
  let f :: AstTensor AstMethodLet FullSpan
                     (TKProduct (TKR 4 Double) (TKR 4 Double))
        -> AstTensor AstMethodLet FullSpan
                     (TKR 4 Double)
      f v = conv2d (tproject1 v) (tproject2 v)
      ftk = FTKProduct (FTKR (2 :$: 2 :$: 2 :$: 2 :$: ZSR) FTKScalar)
                       (FTKR (2 :$: 2 :$: 2 :$: 2 :$: ZSR) FTKScalar)
      (artifactRev, _) =
        revArtifactFromForwardPass
          UseIncomingCotangent (forwardPassByInterpretation f emptyEnv) ftk
  printArtifactPrimalPretty artifactRev
    @?= "\\u1 -> let w30 = str (sreplicate @2 (sgather (sfromR (tproject2 u1)) (\\[i21, i22, i23, i24, i25, i26, i27] -> [i21 + i24, i25, i22 + i26, i23 + i27]))) ; w31 = sreplicate @2 (str (sreplicate @2 (str (sreplicate @2 (sgather (sfromR (tproject1 u1)) (\\[i28, i29] -> [i28 + i29])))))) in rfromS (ssum @8 (stranspose @[4,0,1,2,3] (sreshape @[2,2,2,2,8] (w30 * w31))))"
  printArtifactPrimalPretty (simplifyArtifact artifactRev)
    @?= "\\u1 -> rfromS (ssum @8 (stranspose @[4,0,1,2,3] (sreshape @[2,2,2,2,8] (str (sreplicate @2 (stranspose @[0,1,2,3,6,4,5] (sgather (stranspose @[0,2,3,1] (sfromR (tproject2 u1))) (\\[i21, i22, i23, i24, i26, i27] -> [i21 + i24, i22 + i26, i23 + i27])))) * sreplicate @2 (str (sreplicate @2 (str (sreplicate @2 (sgather (sfromR (tproject1 u1)) (\\[i28, i29] -> [i28 + i29]))))))))))"
  printArtifactPretty artifactRev
    @?= "\\dret u1 -> let w30 = str (sreplicate @2 (sgather (sfromR (tproject2 u1)) (\\[i21, i22, i23, i24, i25, i26, i27] -> [i21 + i24, i25, i22 + i26, i23 + i27]))) ; w31 = sreplicate @2 (str (sreplicate @2 (str (sreplicate @2 (sgather (sfromR (tproject1 u1)) (\\[i28, i29] -> [i28 + i29])))))) ; w33 = sreshape @[2,2,2,2,1,2,2,2] (stranspose @[1,2,3,4,0] (sreplicate @8 (sfromR dret))) in tpair (rfromS (sscatter (ssum @2 (str (ssum @2 (str (ssum @2 (w30 * w33)))))) (\\[i34, i35] -> [i34 + i35]))) (rfromS (sscatter (ssum @2 (str (w31 * w33))) (\\[i36, i37, i38, i39, i40, i41, i42] -> [i36 + i39, i40, i37 + i41, i38 + i42])))"
  printArtifactPretty (simplifyArtifact artifactRev)
    @?= "\\dret u1 -> tfromS (STKProduct (STKR (SNat @4) STKScalar) (STKR (SNat @4) STKScalar)) (let w33 = sreshape @[2,2,2,2,1,2,2,2] (stranspose @[1,2,3,4,0] (sreplicate @8 (sfromR dret))) in tpair (sscatter (ssum @2 (ssum @2 (ssdot1In (stranspose @[2,3,0,4,5,6,7,1] (sreplicate @2 (stranspose @[0,1,2,3,6,4,5] (sgather (stranspose @[0,2,3,1] (sfromR (tproject2 u1))) (\\[i21, i22, i23, i24, i26, i27] -> [i21 + i24, i22 + i26, i23 + i27]))))) (stranspose @[2,3,1,4,5,6,7,0] w33)))) (\\[i34, i35] -> [i34 + i35])) (sscatter (ssdot1In (stranspose @[0,2,3,4,5,6,7,1] (sreplicate @2 (str (sreplicate @2 (str (sreplicate @2 (sgather (sfromR (tproject1 u1)) (\\[i28, i29] -> [i28 + i29])))))))) (stranspose @[0,2,3,4,5,6,7,1] w33)) (\\[i36, i37, i38, i39, i40, i41, i42] -> [i36 + i39, i40, i37 + i41, i38 + i42])))"

testCNNOPP2 :: Assertion
testCNNOPP2 = do
  resetVarCounter
  let t = maxPool2dUnpadded2
            (rconcrete $ Nested.rreplicateScal (1 :$: 1 :$: 2 :$: 2 :$: ZSR) 1)
  printAstPretty t
    @?= "rfromS (sreplicate @2 (sreplicate @2 (let w42 = stranspose @[1,2,3,0] (sreplicate @1 (sgather (sfromVector (fromList [sreplicate @2 (sreplicate @2 (sreplicate @1 (sreplicate @2 (sreplicate @2 (sscalar 0.0))))), let w30 = sreplicate @2 (sreplicate @2 (sreplicate @1 (sreplicate @2 (sreplicate @2 (stranspose @[1,2,0] (sappend (sgather (sappend (sconcrete (sfromListLinear [1,1,2,2] [1.0,1.0,1.0,1.0])) (sconcrete (sfromListLinear [2,1,2,2] [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0]))) (\\[i12, i28, i26] -> [i28, i12, i26 + i12, i12])) (str (sreplicate @3 (str (sreplicate @2 (sconcrete (sfromListLinear [1] [0.0])))))))))))) in sgather (sfromVector (fromList [sreplicate @2 (sreplicate @2 (sreplicate @1 (sreplicate @2 (sreplicate @2 (sscalar 0.0))))), sgather w30 (\\[i53, i47, i41, i37, i32] -> [i53, i47, i41, i37, i32, 0, 2 * i53 + i37, 2 * i47 + i32])])) (\\[i52, i46, i40] -> [ifH (1 <=. i46 + i40) 0 1, i52, i46, i40])])) (\\[i50, i44, i38] -> [ifH (1 <=. i44 + i38) 0 1, i50, i44, i38]))) in sgather w42 (\\[i49, i43] -> [i49, i43, 0, 0, 0, 0]))))"
  printAstPretty (simplifyInlineContract t)
    @?= "rfromS (sreplicate @2 (sreplicate @2 (str (sappend (stranspose @[1,2,3,0] (sreplicate @1 (stranspose @[0,1,3,4,2] (sgather (stranspose @[0,2,3,1] (sfromVector (fromList [sconcrete (sfromListLinear [2,2,1,2,2] [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0]), sgather (str (sappend (stranspose @[0,2,1] (sgather (sconcrete (sfromListLinear [1,2,2,3] [1.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0])) (\\[i12, i26] -> [i12, i26 + i12, i12]))) (sconcrete (sfromListLinear [1,3,2] [0.0,0.0,0.0,0.0,0.0,0.0]))) !$ [0]) (\\[i53, i47, i61, i37, i32] -> [2 * i47 + i32, 2 * i53 + i37])]))) (\\[i46, i40] -> [ifH (1 <=. i46 + i40) 0 1, i46, i40])) !$ [0])) !$ [0, 0, 0]) (sconcrete (sfromListLinear [1,2] [0.0,0.0]))))))"

testCNNOPP2b :: Assertion
testCNNOPP2b = do
  resetVarCounter
  let artifactRev = revArtifactAdapt UseIncomingCotangent maxPool2dUnpadded2 (FTKR [1, 1, 2, 2] (FTKScalar @Double))
  printArtifactPrimalPretty artifactRev
    @?= "\\u1 -> let w58 = sreplicate @2 (sreplicate @2 (sreplicate @1 (sreplicate @2 (sreplicate @2 (stranspose @[1,2,0] (sappend (sgather (sappend (sfromR u1) (sconcrete (sfromListLinear [2,1,2,2] [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0]))) (\\[i55, i56, i57] -> [i56, i55, i57 + i55, i55])) (str (sreplicate @3 (str (sreplicate @2 (sconcrete (sfromListLinear [1] [0.0])))))))))))) ; w70 = stranspose @[1,2,3,0] (sreplicate @1 (sgather (sfromVector (fromList [sreplicate @2 (sreplicate @2 (sreplicate @1 (sreplicate @2 (sreplicate @2 (sscalar 0.0))))), sgather (sfromVector (fromList [sreplicate @2 (sreplicate @2 (sreplicate @1 (sreplicate @2 (sreplicate @2 (sscalar 0.0))))), sgather w58 (\\[i59, i60, i61, i62, i63] -> [i59, i60, i61, i62, i63, 0, 2 * i59 + i62, 2 * i60 + i63])])) (\\[i64, i65, i66] -> [ifH (1 <=. i65 + i66) 0 1, i64, i65, i66])])) (\\[i67, i68, i69] -> [ifH (1 <=. i68 + i69) 0 1, i67, i68, i69]))) in rfromS (sreplicate @2 (sreplicate @2 (sgather w70 (\\[i71, i72] -> [i71, i72, 0, 0, 0, 0]))))"
  printArtifactPrimalPretty (simplifyArtifact artifactRev)
    @?= "\\u1 -> rfromS (sreplicate @2 (sreplicate @2 (str (sappend (stranspose @[1,2,3,0] (sreplicate @1 (stranspose @[0,1,3,4,2] (sgather (stranspose @[0,2,3,1] (sfromVector (fromList [sconcrete (sfromListLinear [2,2,1,2,2] [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0]), sgather (str (sappend (stranspose @[0,2,1] (sgather (stranspose @[1,2,3,0] (sappend (sfromR u1) (sconcrete (sfromListLinear [2,1,2,2] [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0])))) (\\[i55, i57] -> [i55, i57 + i55, i55]))) (sconcrete (sfromListLinear [1,3,2] [0.0,0.0,0.0,0.0,0.0,0.0]))) !$ [0]) (\\[i59, i60, i108, i62, i63] -> [2 * i60 + i63, 2 * i59 + i62])]))) (\\[i65, i66] -> [ifH (1 <=. i65 + i66) 0 1, i65, i66])) !$ [0])) !$ [0, 0, 0]) (sconcrete (sfromListLinear [1,2] [0.0,0.0]))))))"
  printArtifactPretty artifactRev
    @?= "\\dret u1 -> let w79 = sscatter (ssum @1 (stranspose @[3,0,1,2] (sscatter (ssum @2 (ssum @2 (sfromR dret))) (\\[i74, i75] -> [i74, i75, 0, 0, 0, 0])))) (\\[i76, i77, i78] -> [ifH (1 <=. i77 + i78) 0 1, i76, i77, i78]) ; w83 = sscatter (w79 !$ [1]) (\\[i80, i81, i82] -> [ifH (1 <=. i81 + i82) 0 1, i80, i81, i82]) ; t89 = stranspose @[2,0,1] (ssum @2 (ssum @2 (ssum @1 (ssum @2 (ssum @2 (sscatter (w83 !$ [1]) (\\[i84, i85, i86, i87, i88] -> [i84, i85, i86, i87, i88, 0, 2 * i84 + i87, 2 * i85 + i88]))))))) ; u93 = sscatter (sslice (SNat @0) (SNat @1) t89) (\\[i90, i91, i92] -> [i91, i90, i92 + i90, i90]) in rfromS (sslice (SNat @0) (SNat @1) u93)"
  printArtifactPretty (simplifyArtifact artifactRev)
    @?= "\\dret u1 -> rfromS (sreplicate @1 (sscatter (sreplicate @1 (ssum @2 (ssum @2 (ssum @2 (ssum @2 (stranspose @[5,4,3,2,1,0] (stranspose @[6,5,4,3,2,1,0] (sscatter (sscatter (sscatter (sscatter (ssum @2 (ssum @2 (sfromR dret))) (\\[i74, i75] -> [i74, i75, 0, 0, 0])) (\\[i76, i77, i78] -> [ifH (1 <=. i77 + i78) 0 1, i76, i77, i78]) !$ [1]) (\\[i80, i81, i82] -> [ifH (1 <=. i81 + i82) 0 1, i80, i81, i82]) !$ [1]) (\\[i84, i85, i86, i87, i88] -> [i86, i84, i85, i87, i88, 0, 2 * i84 + i87, 2 * i85 + i88]) !$ [0]) !$ [0]))))))) (\\[i90, i91, i92] -> [i91, i90, i92 + i90, i90]) !$ [0]))"

maxPool2dUnpadded2
  :: (target ~ AstTensor AstMethodLet FullSpan, r ~ Double)
  => target (TKR 4 r) -> target (TKR 4 r)
maxPool2dUnpadded2 a =
  rbuild [2, 2, 2, 2] $ \case
    [_, _, iBh, iBw] ->
      let arrt = slicez2 (conv2dUnpadded2 a) [iBw, 3, 2 * iBh, 2 * iBw]
      in rmaximum2 arrt
    _ -> error "maxPool2dUnpadded: impossible pattern needlessly required"

conv2dUnpadded2
  :: (target ~ AstTensor AstMethodLet FullSpan, r ~ Double)
  => target (TKR 4 r) -> target (TKR 4 r)
conv2dUnpadded2 a =
  rbuild [3, 3, 2, 2] $ \case
    [iImg, _, iBh, iBw] ->
      let arrAt = slicez2 a [iImg, 0, iBh, iBw]
      in rindex0 arrAt [0, iBw, iBw, 0]
    _ -> error "conv2dUnpadded: impossible pattern needlessly required"

slicez2
  :: (target ~ AstTensor AstMethodLet FullSpan, r ~ Double, n ~ 4)
  => target (TKR n r) -> IxROf target n -> target (TKR n r)
slicez2 d ixBase =
  rbuild [1, 1, 2, 2] $ \ixResult -> indexz02 d (zipWith_Index (+) ixBase ixResult)

indexz02
  :: forall target r n.
     (target ~ AstTensor AstMethodLet FullSpan, r ~ Double, n ~ 4)
  => target (TKR n r) -> IxROf target n -> target (TKR 0 r)
indexz02 d ix = ifH (1 >. (toList ix !! 0)) (d ! ix) (rscalar 0)

rmaximum2 :: (target ~ AstTensor AstMethodLet FullSpan, r ~ Double)
         => target (TKR 4 r) -> target (TKR 0 r)
rmaximum2 t0 = tlet t0 $ \t -> rindex0 t [0, 0, 0, 0]

testCNNOPP3 :: Assertion
testCNNOPP3 = do
  resetVarCounter
  let blackGlyph :: AstTensor AstMethodLet FullSpan (TKR 4 Double)
      blackGlyph = AstFromPrimal $ AstReplicate (SNat @2) knownSTK
                   $ AstReplicate (SNat @2) knownSTK
                   $ AstReplicate (SNat @2) knownSTK
                   $ AstReplicate (SNat @2) knownSTK
                       (rconcrete $ Nested.rscalar 7
                        :: AstTensor AstMethodLet PrimalSpan (TKR 0 Double))
      afcnn2T :: AstTensor AstMethodLet FullSpan (TKR 4 Double)
      afcnn2T = maxPool2dUnpadded3 $ conv2dUnpadded3 blackGlyph
  printAstPretty afcnn2T
    @?= "rfromS (sappend (str (sappend (sreplicate @1 (stranspose @[1,2,0] (sappend (sreplicate @1 (sreplicate @1 (sgather (sconcrete (sfromListLinear [2] [0.0,0.0])) (\\[i17] -> [ifH (1 <=. quotH i17 2) 1 0])))) (sreplicate @1 (sreplicate @1 (sreplicate @2 (sscalar 0.0))))))) (sreplicate @1 (sreplicate @1 (sreplicate @2 (sreplicate @2 (sscalar 0.0))))))) (sreplicate @1 (sreplicate @2 (sreplicate @2 (sreplicate @2 (sscalar 0.0))))))"
  printAstPretty (simplifyInlineContract afcnn2T)
    @?= "rfromS (sappend (str (sappend (sreplicate @1 (stranspose @[1,2,0] (sappend (sreplicate @1 (sreplicate @1 (sgather (sconcrete (sfromListLinear [2] [0.0,0.0])) (\\[i17] -> [ifH (1 <=. quotH i17 2) 1 0])))) (sconcrete (sfromListLinear [1,1,2] [0.0,0.0]))))) (sconcrete (sfromListLinear [1,1,2,2] [0.0,0.0,0.0,0.0])))) (sconcrete (sfromListLinear [1,2,2,2] [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0])))"

testCNNOPP3b :: Assertion
testCNNOPP3b = do
  resetVarCounter
  let artifactRev = revArtifactAdapt UseIncomingCotangent (maxPool2dUnpadded3 . conv2dUnpadded3) (FTKR [2, 2, 2, 2] (FTKScalar @Double))
  printArtifactPrimalPretty artifactRev
    @?= "\\u1 -> rfromS (sappend (str (sappend (sreplicate @1 (stranspose @[1,2,0] (sappend (sreplicate @1 (sreplicate @1 (sgather (sconcrete (sfromListLinear [2] [0.0,0.0])) (\\[i27] -> [ifH (1 <=. quotH i27 2) 1 0])))) (sreplicate @1 (sreplicate @1 (sreplicate @2 (sscalar 0.0))))))) (sreplicate @1 (sreplicate @1 (sreplicate @2 (sreplicate @2 (sscalar 0.0))))))) (sreplicate @1 (sreplicate @2 (sreplicate @2 (sreplicate @2 (sscalar 0.0))))))"
  printArtifactPrimalPretty (simplifyArtifact artifactRev)
    @?= "\\u1 -> rfromS (sappend (str (sappend (sreplicate @1 (stranspose @[1,2,0] (sappend (sreplicate @1 (sreplicate @1 (sgather (sconcrete (sfromListLinear [2] [0.0,0.0])) (\\[i27] -> [ifH (1 <=. quotH i27 2) 1 0])))) (sconcrete (sfromListLinear [1,1,2] [0.0,0.0]))))) (sconcrete (sfromListLinear [1,1,2,2] [0.0,0.0,0.0,0.0])))) (sconcrete (sfromListLinear [1,2,2,2] [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0])))"
  printArtifactPretty artifactRev
    @?= "\\dret u1 -> rfromS (sconcrete (sfromListLinear [2,2,2,2] [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0]))"
  printArtifactPretty (simplifyArtifact artifactRev)
    @?= "\\dret u1 -> rfromS (sconcrete (sfromListLinear [2,2,2,2] [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0]))"

maxPool2dUnpadded3
  :: (ADReady target, GoodScalar r)
  => target (TKR 4 r) -> target (TKR 4 r)
maxPool2dUnpadded3 arr =
  rbuild [2, 2, 2, 2] $ \case
    [aa, bb, iBh, iBw] ->
      let arrt = slicez3 [2, 2, 2, 2] arr [iBh `quotH` 2, aa, bb, iBw]
      in rmaximum3 arrt
    _ -> error "maxPool2dUnpadded: impossible pattern needlessly required"

conv2dUnpadded3
  :: (ADReady target, GoodScalar r)
  => target (TKR 4 r) -> target (TKR 4 r)
conv2dUnpadded3 arrA =
  let shB = [2, 2, 2, 2]
  in rbuild shB $ \case
    [iImg, _, iBh, iBw] ->
      let arrAt = slicez3 shB arrA [iImg `remH` 2, iImg, iImg, 2]
      in rindex0 arrAt [iBh, iBw, iImg, iBh]
    _ -> error "conv2dUnpadded: impossible pattern needlessly required"

slicez3
  :: (ADReady target, GoodScalar r, KnownNat n)
  => IShR n -> target (TKR n r) -> IxROf target n -> target (TKR n r)
slicez3 shOut d ixBase =
  rbuild shOut $ \_ixResult -> indexz03 d (zipWith_Index (+) ixBase ixBase) -- ixResult)

indexz03
  :: forall target r n. (ADReady target, GoodScalar r, KnownNat n)
  => target (TKR n r) -> IxROf target n -> target (TKR 0 r)
indexz03 d ix = ifH (within0 @target (rshape @target d) ix) (d ! ix) (rscalar 0)

rmaximum3 :: (BaseTensor target, LetTensor target, KnownNat n, GoodScalar r)
         => target (TKR n r) -> target (TKR 0 r)
rmaximum3 t0 = tlet t0 $ \t -> rindex0 t [0, 0, 0, 0]

testCNNOPP4 :: Assertion
testCNNOPP4 = do
  resetVarCounter
  let blackGlyph :: AstTensor AstMethodLet FullSpan (TKR 4 Double)
      blackGlyph = AstFromPrimal $ AstReplicate (SNat @3) knownSTK
                   $ AstReplicate (SNat @3) knownSTK
                   $ AstReplicate (SNat @3) knownSTK
                   $ AstReplicate (SNat @3) knownSTK
                       (rconcrete $ Nested.rscalar 7
                        :: AstTensor AstMethodLet PrimalSpan (TKR 0 Double))
      afcnn2T :: AstTensor AstMethodLet FullSpan (TKR 4 Double)
      afcnn2T = maxPool2dUnpadded4 blackGlyph
  printAstPretty afcnn2T
    @?= "rfromS (let w12 = sgather (sconcrete (sfromListLinear [2] [7.0,0.0])) (\\[i23, i20, i17, i14, i11, i10, i9, i8] -> [ifH (notB (2 <=. i20 + i11) &&* (notB (0 <=. negate i20 + i10) &&* (notB (3 <=. i23 * i17 + i9) &&* notB (3 <=. 2 * i14 + i8)))) 0 1]) in sgather w12 (\\[i22, i19, i16, i13] -> [i22, i19, i16, i13, 0, 0, 0, 0]))"
  printAstPretty (simplifyInlineContract afcnn2T)
    @?= "rfromS (stranspose @[3,2,1,0] (sreplicate @2 (str (sappend (sconcrete (sfromListLinear [1,2,2] [0.0,0.0,0.0,0.0])) (sreplicate @1 (sgather (sconcrete (sfromListLinear [2] [7.0,0.0])) (\\[i17, i23] -> [ifH (3 <=. i23 * i17) 1 0])))))))"

testCNNOPP4b :: Assertion
testCNNOPP4b = do
  resetVarCounter
  let artifactRev = revArtifactAdapt UseIncomingCotangent maxPool2dUnpadded4 (FTKR [3, 3, 3, 3] (FTKScalar @Double))
  printArtifactPrimalPretty artifactRev
    @?= "\\u1 -> let w52 = sgather (sfromVector (fromList [sgather (sslice (SNat @3) (SNat @0) (stranspose @[2,0,1] (sgather (sslice (SNat @1) (SNat @2) (sfromR u1)) (\\[i34, i35] -> [i34 + i35])))) (\\[i36, i37, i38, i39, i40, i41, i42, i43] -> [negate i37 + i41, i37, i40, i36 * i38 + i42, 2 * i39 + i43]), sreplicate @2 (sreplicate @2 (sreplicate @2 (sreplicate @2 (sreplicate @2 (sreplicate @2 (sreplicate @2 (sreplicate @2 (sscalar 0.0))))))))])) (\\[i44, i45, i46, i47, i48, i49, i50, i51] -> [ifH (notB (2 <=. i45 + i48) &&* (notB (0 <=. negate i45 + i49) &&* (notB (3 <=. i44 * i46 + i50) &&* notB (3 <=. 2 * i47 + i51)))) 0 1, i44, i45, i46, i47, i48, i49, i50, i51]) in rfromS (sgather w52 (\\[i53, i54, i55, i56] -> [i53, i54, i55, i56, 0, 0, 0, 0]))"
  printArtifactPrimalPretty (simplifyArtifact artifactRev)
    @?= "\\u1 -> rfromS (stranspose @[3,0,2,1] (sappend (sconcrete (sfromListLinear [1,2,2,2] [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0])) (sreplicate @1 (stranspose @[2,0,1] (sgather (stranspose @[3,2,1,0] (stranspose @[3,2,1,0] (stranspose @[3,2,1,0] (stranspose @[4,0,1,2,5,6,7,3] (stranspose @[2,1,0] (sfromVector (fromList [stranspose @[0,1,2,3,7,4,5,6] (sgather (stranspose @[1,0,3,4,2] (sslice (SNat @3) (SNat @0) (stranspose @[2,0,1] (sgather (sslice (SNat @1) (SNat @2) (sfromR u1)) (\\[i34, i35] -> [i34 + i35]))))) (\\[i36, i37, i38, i39, i41, i42, i43] -> [i37, negate i37 + i41, i36 * i38 + i42, 2 * i39 + i43])), sconcrete (sfromListLinear [2,2,2,2,2,2,2,2] [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0])])) !$ [1]) !$ [0]) !$ [0]) !$ [0]) !$ [0]) (\\[i46, i44] -> [i46, ifH (3 <=. i44 * i46) 1 0, i44]))))))"
  printArtifactPretty artifactRev
    @?= "\\dret u1 -> let w70 = sscatter (sscatter (sfromR dret) (\\[i58, i59, i60, i61] -> [i58, i59, i60, i61, 0, 0, 0, 0])) (\\[i62, i63, i64, i65, i66, i67, i68, i69] -> [ifH (notB (2 <=. i63 + i66) &&* (notB (0 <=. negate i63 + i67) &&* (notB (3 <=. i62 * i64 + i68) &&* notB (3 <=. 2 * i65 + i69)))) 0 1, i62, i63, i64, i65, i66, i67, i68, i69]) in rfromS (sappend (sconcrete (sfromListLinear [1,3,3,3] [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0])) (sappend (sscatter (stranspose @[1,2,0] (sappend (sconcrete (sfromListLinear [3,2,2,3,3] [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0])) (sappend (sscatter (w70 !$ [0]) (\\[i71, i72, i73, i74, i75, i76, i77, i78] -> [negate i72 + i76, i72, i75, i71 * i73 + i77, 2 * i74 + i78])) (sconcrete (sfromListLinear [0,2,2,3,3] []))))) (\\[i79, i80] -> [i79 + i80])) (sconcrete (sfromListLinear [0,3,3,3] []))))"
  printArtifactPretty (simplifyArtifact artifactRev)
    @?= "\\dret u1 -> rfromS (sappend (sconcrete (sfromListLinear [1,3,3,3] [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0])) (sscatter (sconcrete (sfromListLinear [2,2,3,3,3] [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0])) (\\[i79, i80] -> [i79 + i80])))"

testCNNOPP5 :: Assertion
testCNNOPP5 = do
  resetVarCounter
  let blackGlyph :: AstTensor AstMethodLet FullSpan (TKR 4 Double)
      blackGlyph = AstFromPrimal $ AstReplicate (SNat @6) knownSTK
                   $ AstReplicate (SNat @6) knownSTK
                   $ AstReplicate (SNat @6) knownSTK
                   $ AstReplicate (SNat @6) knownSTK
                       (rconcrete $ Nested.rscalar 7
                        :: AstTensor AstMethodLet PrimalSpan (TKR 0 Double))
      afcnn2T :: AstTensor AstMethodLet FullSpan (TKR 4 Double)
      afcnn2T = conv2dUnpadded4 blackGlyph
  printAstPretty afcnn2T
    @?= "rfromS (sreplicate @1 (sreplicate @1 (sreplicate @2 (sreplicate @2 (sscalar 7.0)))))"
  printAstPretty (simplifyInlineContract afcnn2T)
    @?= "rfromS (sconcrete (sfromListLinear [1,1,2,2] [7.0,7.0,7.0,7.0]))"

testCNNOPP5b :: Assertion
testCNNOPP5b = do
  resetVarCounter
  let artifactRev = revArtifactAdapt UseIncomingCotangent conv2dUnpadded4 (FTKR [5, 5, 5, 5] (FTKScalar @Double))
  printArtifactPrimalPretty artifactRev
    @?= "\\u1 -> rfromS (str (sreplicate @1 (stranspose @[1,2,0] (sslice (SNat @0) (SNat @2) (stranspose @[2,1,0] (sslice (SNat @0) (SNat @2) (str (sreplicate @1 (sfromR u1 !$ [0, 0])))))))))"
  printArtifactPrimalPretty (simplifyArtifact artifactRev)
    @?= "\\u1 -> rfromS (str (sreplicate @1 (stranspose @[1,2,0] (sslice (SNat @0) (SNat @2) (stranspose @[2,1,0] (sslice (SNat @0) (SNat @2) (str (sreplicate @1 (sfromR u1 !$ [0, 0])))))))))"
  printArtifactPretty artifactRev
    @?= "\\dret u1 -> rfromS (soneHot (ssum @1 (str (sappend (sconcrete (sfromListLinear [0,1,5] [])) (sappend (stranspose @[2,1,0] (sappend (sconcrete (sfromListLinear [0,1,2] [])) (sappend (stranspose @[2,0,1] (ssum @1 (str (sfromR dret)))) (sconcrete (sfromListLinear [3,1,2] [0.0,0.0,0.0,0.0,0.0,0.0]))))) (sconcrete (sfromListLinear [3,1,5] [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0])))))) [0, 0])"
  printArtifactPretty (simplifyArtifact artifactRev)
    @?= "\\dret u1 -> rfromS (soneHot (str (sappend (stranspose @[2,1,0] (sappend (stranspose @[2,0,1] (str (sfromR dret) !$ [0])) (sconcrete (sfromListLinear [3,1,2] [0.0,0.0,0.0,0.0,0.0,0.0])))) (sconcrete (sfromListLinear [3,1,5] [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0]))) !$ [0]) [0, 0])"

maxPool2dUnpadded4
  :: (ADReady target, GoodScalar r)
  => target (TKR 4 r) -> target (TKR 4 r)
maxPool2dUnpadded4 arr =
  rbuild [2, 2, 2, 2] $ \case
    [aa, bb, iBh, iBw] ->
      let arrt = slicez4 [2, 2, 2, 2] arr [bb + 1, 3 - bb, aa * iBh, 2 * iBw]
      in rmaximum3 arrt
    _ -> error "maxPool2dUnpadded: impossible pattern needlessly required"

conv2dUnpadded4
  :: (ADReady target, GoodScalar r)
  => target (TKR 4 r) -> target (TKR 4 r)
conv2dUnpadded4 arrA =
  let shB = [1, 1, 2, 2]
  in rbuild shB $ \case
    [iImg, _, iBh, iBw] ->
      let arrAt = slicez4 shB arrA [iImg, 0, iBh, iBw]
      in rindex0 arrAt [0, 0, 0, 0]
    _ -> error "conv2dUnpadded: impossible pattern needlessly required"

slicez4
  :: (ADReady target, GoodScalar r, KnownNat n)
  => IShR n -> target (TKR n r) -> IxROf target n -> target (TKR n r)
slicez4 shOut d ixBase =
  rbuild shOut $ \ixResult -> indexz03 d (zipWith_Index (+) ixBase ixResult)

testCNNOPP6 :: Assertion
testCNNOPP6 = do
  resetVarCounter
  let blackGlyph :: AstTensor AstMethodLet FullSpan (TKR 4 Double)
      blackGlyph = AstFromPrimal $ AstReplicate (SNat @2) knownSTK
                   $ AstReplicate (SNat @2) knownSTK
                   $ AstReplicate (SNat @2) knownSTK
                   $ AstReplicate (SNat @2) knownSTK
                       (rconcrete $ Nested.rscalar 7
                        :: AstTensor AstMethodLet PrimalSpan (TKR 0 Double))
      afcnn2T :: AstTensor AstMethodLet FullSpan (TKR 4 Double)
      afcnn2T = maxPool2dUnpadded3 $ conv2dUnpadded3z blackGlyph
  printAstPretty afcnn2T
    @?= "rfromS (let w24 = stranspose @[1,2,3,4,0] (sreplicate @2 (stranspose @[1,2,3,4,0] (sreplicate @2 (stranspose @[1,2,3,4,0] (sreplicate @2 (stranspose @[1,2,3,4,0] (sreplicate @2 (let u41 = str (sreplicate @2 (sfromVector (fromList [sgather (sfromVector (fromList [sreplicate @2 (sreplicate @2 (sscalar 0.0)), sgather (sappend (sreplicate @1 (sreplicate @1 (sscalar 7.0))) (sreplicate @1 (sreplicate @1 (sscalar 0.0)))) (\\[i34, i4] -> [2 * i4, 2 * quotH i34 2])])) (\\[i33] -> [ifH (1 <=. quotH i33 2) 0 1, i33]), sreplicate @2 (sreplicate @2 (sscalar 0.0))]))) in sappend (str (sappend (sreplicate @1 (stranspose @[1,2,0] (sappend (sgather u41 (\\[i26, i40, i32] -> [ifH (1 <=. quotH i32 2) 1 0, i40, i32, i26])) (sreplicate @1 (sgather (stranspose @[2,1,0] (u41 !$ [1]) !$ [1]) (\\[i40, i32] -> [i32, i40])))))) (sreplicate @1 (sreplicate @1 (u41 !$ [1, 0]))))) (sreplicate @1 (sreplicate @2 (u41 !$ [1, 1]))))))))))) in sgather w24 (\\[i39, i36, i31, i25] -> [i39, i36, i31, i25, 0, 0, 0, 0]))"
  printAstPretty (simplifyInlineContract afcnn2T)
    @?= "rfromS (let u41 = str (sreplicate @2 (sfromVector (fromList [sgather (sfromVector (fromList [sconcrete (sfromListLinear [2,2] [0.0,0.0,0.0,0.0]), sgather (sconcrete (sfromListLinear [2,1] [7.0,0.0])) (\\[i34, i4] -> [2 * i4, 2 * quotH i34 2])])) (\\[i33] -> [ifH (1 <=. quotH i33 2) 0 1, i33]), sconcrete (sfromListLinear [2,2] [0.0,0.0,0.0,0.0])]))) in sappend (str (sappend (sreplicate @1 (stranspose @[1,2,0] (sappend (stranspose @[1,2,0] (sgather (stranspose @[1,2,0] (sreplicate @1 (stranspose @[1,2,0] (sreplicate @1 (str (stranspose @[1,2,3,0] u41 !$ [0]) !$ [0]))))) (\\[i32] -> [i32, ifH (1 <=. quotH i32 2) 1 0]))) (sreplicate @1 (sreplicate @1 (str (u41 !$ [1, 0]) !$ [1])))))) (sreplicate @1 (sreplicate @1 (u41 !$ [1, 0]))))) (sreplicate @1 (sreplicate @2 (u41 !$ [1, 1]))))"

testCNNOPP6b :: Assertion
testCNNOPP6b = do
  resetVarCounter
  let artifactRev = revArtifactAdapt UseIncomingCotangent (maxPool2dUnpadded3 . conv2dUnpadded3z) (FTKR [2, 2, 2, 2] (FTKScalar @Double))
  printArtifactPrimalPretty artifactRev
    @?= "\\u1 -> let u47 = sreplicate @2 (sreplicate @2 (sgather (sfromR u1) (\\[i45, i46] -> [2 * i45, 2 * i45, 2 * i45, 2 * i46]))) ; m50 = sgather u47 (\\[i48, i49] -> [i48, i49, 0, 2 * i49]) ; u53 = str (sreplicate @2 (sfromVector (fromList [sgather (sfromVector (fromList [sreplicate @2 (sreplicate @2 (sscalar 0.0)), str (sappend (sreplicate @1 (sgather m50 (\\[i51] -> [i51, 0]))) (sreplicate @1 (sreplicate @2 (sscalar 0.0))))])) (\\[i52] -> [ifH (1 <=. quotH i52 2) 0 1, i52]), sreplicate @2 (sreplicate @2 (sscalar 0.0))]))) ; w59 = stranspose @[1,2,3,4,0] (sreplicate @2 (stranspose @[1,2,3,4,0] (sreplicate @2 (stranspose @[1,2,3,4,0] (sreplicate @2 (stranspose @[1,2,3,4,0] (sreplicate @2 (sappend (str (sappend (sreplicate @1 (stranspose @[1,2,0] (sappend (sgather u53 (\\[i54, i55, i56] -> [ifH (1 <=. quotH i56 2) 1 0, i55, i56, i54])) (sreplicate @1 (sgather (stranspose @[2,1,0] (u53 !$ [1]) !$ [1]) (\\[i57, i58] -> [i58, i57])))))) (sreplicate @1 (sreplicate @1 (u53 !$ [1, 0]))))) (sreplicate @1 (sreplicate @2 (u53 !$ [1, 1]))))))))))) in rfromS (sgather w59 (\\[i60, i61, i62, i63] -> [i60, i61, i62, i63, 0, 0, 0, 0]))"
  printArtifactPrimalPretty (simplifyArtifact artifactRev)
    @?= "\\u1 -> rfromS (let u53 = str (sreplicate @2 (sfromVector (fromList [sgather (sfromVector (fromList [sconcrete (sfromListLinear [2,2] [0.0,0.0,0.0,0.0]), str (sappend (sreplicate @1 (sreplicate @2 (sfromR u1 !$ [0, 0, 0, 0]))) (sconcrete (sfromListLinear [1,2] [0.0,0.0])))])) (\\[i52] -> [ifH (1 <=. quotH i52 2) 0 1, i52]), sconcrete (sfromListLinear [2,2] [0.0,0.0,0.0,0.0])]))) in sappend (str (sappend (sreplicate @1 (stranspose @[1,2,0] (sappend (stranspose @[1,2,0] (sgather (stranspose @[1,2,0] (sreplicate @1 (stranspose @[1,2,0] (sreplicate @1 (str (stranspose @[1,2,3,0] u53 !$ [0]) !$ [0]))))) (\\[i56] -> [i56, ifH (1 <=. quotH i56 2) 1 0]))) (sreplicate @1 (sreplicate @1 (str (u53 !$ [1, 0]) !$ [1])))))) (sreplicate @1 (sreplicate @1 (u53 !$ [1, 0]))))) (sreplicate @1 (sreplicate @2 (u53 !$ [1, 1]))))"
  printArtifactPretty artifactRev
    @?= "\\dret u1 -> let u69 = ssum @2 (stranspose @[4,0,1,2,3] (ssum @2 (stranspose @[4,0,1,2,3] (ssum @2 (stranspose @[4,0,1,2,3] (ssum @2 (stranspose @[4,0,1,2,3] (sscatter (sfromR dret) (\\[i65, i66, i67, i68] -> [i65, i66, i67, i68, 0, 0, 0, 0]))))))))) ; u70 = str (sslice (SNat @0) (SNat @1) u69) ; t71 = stranspose @[2,0,1] (ssum @1 (sslice (SNat @0) (SNat @1) u70)) ; t77 = ssum @2 (str (sscatter (sslice (SNat @0) (SNat @1) t71) (\\[i74, i75, i76] -> [ifH (1 <=. quotH i76 2) 1 0, i75, i76, i74]) + (soneHot (stranspose @[2,1,0] (soneHot (sscatter (ssum @1 (sslice (SNat @1) (SNat @1) t71)) (\\[i72, i73] -> [i73, i72])) [1])) [1] + (soneHot (ssum @1 (ssum @1 (sslice (SNat @1) (SNat @1) u70))) [1, 0] + soneHot (ssum @2 (ssum @1 (sslice (SNat @1) (SNat @1) u69))) [1, 1])))) ; t79 = sscatter (t77 !$ [0]) (\\[i78] -> [ifH (1 <=. quotH i78 2) 0 1, i78]) ; m80 = str (t79 !$ [1]) in rfromS (sscatter (ssum @2 (ssum @2 (sscatter (sscatter (ssum @1 (sslice (SNat @0) (SNat @1) m80)) (\\[i81] -> [i81, 0])) (\\[i82, i83] -> [i82, i83, 0, 2 * i83])))) (\\[i84, i85] -> [2 * i84, 2 * i84, 2 * i84, 2 * i85]))"
  printArtifactPretty (simplifyArtifact artifactRev)
    @?= "\\dret u1 -> rfromS (sscatter (ssum @2 (ssum @2 (sscatter (sscatter (str (sscatter (ssum @2 (sconcrete (sfromListLinear [2,2,2] [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0]) + sscatter (sreplicate @1 (stranspose @[2,0,1] (str (sreplicate @1 (ssum @2 (ssum @2 (ssum @2 (ssum @2 (sscatter (sfromR dret) (\\[i65, i66, i67, i68] -> [i65, 0, 0, 0, 0, i66, i67, i68]) !$ [0])))))) !$ [0]) !$ [0])) (\\[i74, i75, i76] -> [ifH (1 <=. quotH i76 2) 1 0, i75, i76, i74]) !$ [0])) (\\[i78] -> [ifH (1 <=. quotH i78 2) 0 1, i78]) !$ [1]) !$ [0]) (\\[i81] -> [i81, 0])) (\\[i82, i83] -> [i82, i83, 0, 2 * i83])))) (\\[i84, i85] -> [2 * i84, 2 * i84, 2 * i84, 2 * i85]))"

conv2dUnpadded3z
  :: (ADReady target, GoodScalar r)
  => target (TKR 4 r) -> target (TKR 4 r)
conv2dUnpadded3z arrA =
  let shB = [2, 2, 2, 2]
  in rbuild shB $ \case
    [iImg, _, iBh, iBw] ->
      let arrAt = slicez3 shB arrA [iImg, iImg, iImg, iBw]
      in rindex0 arrAt [iBh, iBw, iImg, iBh]
    _ -> error "conv2dUnpadded: impossible pattern needlessly required"

testCNNOPP7 :: Assertion
testCNNOPP7 = do
  resetVarCounter
  let blackGlyph :: AstTensor AstMethodLet FullSpan (TKR 4 Double)
      blackGlyph = AstFromPrimal $ AstReplicate (SNat @2) knownSTK
                   $ AstReplicate (SNat @2) knownSTK
                   $ AstReplicate (SNat @2) knownSTK
                   $ AstReplicate (SNat @2) knownSTK
                       (rconcrete $ Nested.rscalar 7
                        :: AstTensor AstMethodLet PrimalSpan (TKR 0 Double))
      afcnn2T :: AstTensor AstMethodLet FullSpan (TKR 4 Double)
      afcnn2T = maxPool2dUnpadded3y $ conv2dUnpadded3y blackGlyph
  printAstPretty afcnn2T
    @?= "rfromS (let w24 = stranspose @[1,2,3,4,0] (sreplicate @2 (stranspose @[1,2,3,4,0] (sreplicate @2 (stranspose @[1,2,3,4,0] (sreplicate @2 (stranspose @[1,2,3,4,0] (sreplicate @2 (let t34 = sreplicate @2 (let m31 = sgather (sappend (sconcrete (sfromListLinear [1,2] [0.0,0.0])) (sreplicate @1 (sreplicate @2 (sscalar 0.0)))) (\\[i40, i3] -> [2 * i3, 2 * i40]) in str (sappend (sreplicate @1 (sappend (sreplicate @1 (sscalar 7.0)) (sreplicate @1 (sscalar 0.0)))) (sreplicate @1 (sgather m31 (\\[i39] -> [i39, 1]))))) in stranspose @[1,2,0] (sappend (str (sappend (stranspose @[1,2,0] (sappend (stranspose @[1,2,3,0] (sappend (sreplicate @1 (sgather t34 (\\[i38, i44, i28] -> [i44, i38, i28]))) (sreplicate @1 (sreplicate @1 (sreplicate @1 (sreplicate @1 (sscalar 0.0))))))) (sreplicate @1 (sreplicate @1 (sreplicate @1 (sreplicate @2 (sscalar 0.0))))))) (sreplicate @1 (sreplicate @1 (sreplicate @2 (sreplicate @2 (sscalar 0.0))))))) (sreplicate @1 (sreplicate @2 (sreplicate @2 (sreplicate @2 (sscalar 0.0)))))))))))))) in sgather w24 (\\[i42, i36, i27, i25] -> [i42, i36, i27, i25, 0, 0, 0, 0]))"
  printAstPretty (simplifyInlineContract afcnn2T)
    @?= "rfromS (sconcrete (sfromListLinear [2,2,2,2] [7.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0]))"

testCNNOPP7b :: Assertion
testCNNOPP7b = do
  resetVarCounter
  let artifactRev = revArtifactAdapt UseIncomingCotangent (maxPool2dUnpadded3y . conv2dUnpadded3y) (FTKR [2, 2, 2, 2] (FTKScalar @Double))
  printArtifactPrimalPretty artifactRev
    @?= "\\u1 -> let u52 = sreplicate @2 (sreplicate @2 (sgather (sfromR u1) (\\[i50, i51] -> [2 * i50, 2 * i50, 2 * i50, 2 * i51]))) ; m55 = sgather u52 (\\[i53, i54] -> [i53, i54, 0, 2 * i53]) ; m56 = sappend (sreplicate @1 (m55 !$ [0])) (sreplicate @1 (sreplicate @2 (sscalar 0.0))) ; t58 = sreplicate @2 (str (sappend (sreplicate @1 (sgather m56 (\\[i57] -> [i57, 0]))) (sreplicate @1 (sreplicate @2 (sscalar 0.0))))) ; w62 = stranspose @[1,2,3,4,0] (sreplicate @2 (stranspose @[1,2,3,4,0] (sreplicate @2 (stranspose @[1,2,3,4,0] (sreplicate @2 (stranspose @[1,2,3,4,0] (sreplicate @2 (stranspose @[1,2,0] (sappend (str (sappend (stranspose @[1,2,0] (sappend (stranspose @[1,2,3,0] (sappend (sreplicate @1 (sgather t58 (\\[i59, i60, i61] -> [i60, i59, i61]))) (sreplicate @1 (sreplicate @1 (sreplicate @1 (sreplicate @1 (sscalar 0.0))))))) (sreplicate @1 (sreplicate @1 (sreplicate @1 (sreplicate @2 (sscalar 0.0))))))) (sreplicate @1 (sreplicate @1 (sreplicate @2 (sreplicate @2 (sscalar 0.0))))))) (sreplicate @1 (sreplicate @2 (sreplicate @2 (sreplicate @2 (sscalar 0.0)))))))))))))) in rfromS (sgather w62 (\\[i63, i64, i65, i66] -> [i63, i64, i65, i66, 0, 0, 0, 0]))"
  printArtifactPrimalPretty (simplifyArtifact artifactRev)
    @?= "\\u1 -> rfromS (stranspose @[1,2,0] (sappend (str (sappend (stranspose @[1,2,0] (sappend (stranspose @[1,2,3,0] (sappend (sreplicate @1 (sreplicate @1 (sreplicate @1 (sreplicate @1 (sfromR u1 !$ [0, 0, 0, 0]))))) (sconcrete (sfromListLinear [1,1,1,1] [0.0])))) (sconcrete (sfromListLinear [1,1,1,2] [0.0,0.0])))) (sconcrete (sfromListLinear [1,1,2,2] [0.0,0.0,0.0,0.0])))) (sconcrete (sfromListLinear [1,2,2,2] [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0]))))"
  printArtifactPretty artifactRev
    @?= "\\dret u1 -> let u72 = stranspose @[2,0,1] (ssum @2 (stranspose @[4,0,1,2,3] (ssum @2 (stranspose @[4,0,1,2,3] (ssum @2 (stranspose @[4,0,1,2,3] (ssum @2 (stranspose @[4,0,1,2,3] (sscatter (sfromR dret) (\\[i68, i69, i70, i71] -> [i68, i69, i70, i71, 0, 0, 0, 0])))))))))) ; u73 = str (sslice (SNat @0) (SNat @1) u72) ; u74 = stranspose @[2,0,1] (sslice (SNat @0) (SNat @1) u73) ; u75 = stranspose @[3,0,1,2] (sslice (SNat @0) (SNat @1) u74) ; m79 = str (ssum @2 (sscatter (ssum @1 (sslice (SNat @0) (SNat @1) u75)) (\\[i76, i77, i78] -> [i77, i76, i78]))) ; m81 = sscatter (ssum @1 (sslice (SNat @0) (SNat @1) m79)) (\\[i80] -> [i80, 0]) in rfromS (sscatter (ssum @2 (ssum @2 (sscatter (soneHot (ssum @1 (sslice (SNat @0) (SNat @1) m81)) [0]) (\\[i82, i83] -> [i82, i83, 0, 2 * i82])))) (\\[i84, i85] -> [2 * i84, 2 * i84, 2 * i84, 2 * i85]))"
  printArtifactPretty (simplifyArtifact artifactRev)
    @?= "\\dret u1 -> rfromS (sscatter (ssum @2 (ssum @2 (sscatter (soneHot (sscatter (ssum @2 (sscatter (ssum @2 (ssum @2 (ssum @2 (ssum @2 (stranspose @[6,5,4,3,0,1,2] (sreplicate @1 (sreplicate @1 (sreplicate @1 (stranspose @[4,5,6,3,2,1,0] (sscatter (sfromR dret) (\\[i68, i69, i70, i71] -> [i70, 0, 0, 0, 0, i68, i69, i71]) !$ [0]) !$ [0, 0, 0]))))))))) (\\[i76, i77, i78] -> [i78, i77, i76]) !$ [0])) (\\[i80] -> [i80, 0]) !$ [0]) [0]) (\\[i82, i83] -> [i82, i83, 0, 2 * i82])))) (\\[i84, i85] -> [2 * i84, 2 * i84, 2 * i84, 2 * i85]))"

maxPool2dUnpadded3y
  :: (ADReady target, GoodScalar r)
  => target (TKR 4 r) -> target (TKR 4 r)
maxPool2dUnpadded3y arr =
  rbuild [2, 2, 2, 2] $ \case
    [aa, bb, iBh, iBw] ->
      let arrt = slicez3 [2, 2, 2, 2] arr [iBh, aa, bb, iBw]
      in rmaximum3 arrt
    _ -> error "maxPool2dUnpadded: impossible pattern needlessly required"

conv2dUnpadded3y
  :: (ADReady target, GoodScalar r)
  => target (TKR 4 r) -> target (TKR 4 r)
conv2dUnpadded3y arrA =
  let shB = [2, 2, 2, 2]
  in rbuild shB $ \case
    [iImg, _, iBh, iBw] ->
      let arrAt = slicez3 shB arrA [iImg, iImg, iImg, iBh]
      in rindex0 arrAt [iBh, iBw, iImg, iBh]
    _ -> error "conv2dUnpadded: impossible pattern needlessly required"

codeTomsSlice :: ADReady target
              => target (TKR 2 Double) -> target (TKR 0 Double)
codeTomsSlice a =
  let (n, m) = case rshape a of
        [n', m'] -> (n', m')
        _ -> error "codeTomsSlice"
      a1 = rbuild @2 @0 [n,m-1] (\[i',j'] -> rindex0 a [i',j'])
      a2 = rbuild [n,m-1] (\[i',j'] -> rindex0 a [i',j' + 1])
  in rsum0 @2 $ rbuild [n,m] $ \[i, _j] ->
       rfromIndex0 i * rsum0 (a1 * a2)

testTomsSliceRev :: Assertion
testTomsSliceRev = do
  assertEqualUpToEpsilon 1e-5
    (ringestData [32,4] [63686.39999999999,137292.80000000002,121222.4,79558.40000000002,192646.40000000005,223971.0617601984,228556.80000000005,116846.33088019838,63686.39999999999,137292.80000000002,127174.4,79558.40000000002,192646.40000000005,158499.06176019844,202566.40000000005,51374.330880198424,11904.0,5952.0,7936.0,1984.0,116846.33088019838,385292.8000000001,227740.66176039676,192646.40000000005,116846.33088019838,228556.80000000005,174580.73088019836,35910.399999999994,79558.40000000002,127372.79999999997,143244.80000000002,63686.39999999999,105152.0,186683.13088000007,105151.98016,107124.73088000003,-396.79999999999995,26188.8,17459.2,25990.399999999998,-7936.0,73408.0,-1995.2691200000017,57536.0,51584.0,-660672.0,55552.0,3968.0,3968.0,3571.2,3571.2,-396.79999999999995,-396.79999999999995,49203.79519999998,49203.79519999998,49600.59519999998,49600.59519999998,49203.79519999998,49203.79519999998,-396.79999999999995,-396.79999999999995,49203.79519999998,49203.79519999998,49600.59519999998,49600.59519999998,129158.9952,65472.59519999998,79558.40000000002,-5952.0,73198.33087999995,51175.930880000036,51374.33087999995,51187.20000000001,1984.0000000000146,67059.20000000001,79558.40000000002,-5952.0,73198.33087999995,51175.930880000036,51374.33087999995,51187.20000000001,-21823.99999999993,108921.6,16070.400000000005,79558.40000000002,127372.79999999997,159116.80000000005,63686.39999999999,107124.73088000003,771974.4,218019.0617601984,192646.40000000005,170414.3308801984,385292.8000000001,340828.6617603968,192646.40000000005,57734.399999999994,99596.79999999999,137292.80000000002,63686.39999999999,79558.40000000002,127372.79999999997,159116.80000000005,63686.39999999999,107124.73088000003,236294.40000000005,271587.0617601984,192646.40000000005,45422.33088019842,385292.8000000001,162268.6617603968,192646.40000000005,57734.399999999994,99596.79999999999,137292.80000000002,63686.39999999999,79558.40000000002,127372.79999999997,159116.80000000005,63686.39999999999,107124.73088000003,369222.4,220003.0617601984,192646.40000000005,104942.33088019838,385292.8000000001,215836.66176039676,192646.40000000005])
    (grad (kfromR . codeTomsSlice) (rreshape [32, 4] t128))

testTomsSlice :: Assertion
testTomsSlice = do
  assertEqualUpToEpsilon' 1e-5
    (ringestData [32,4] [63686.39999999999,137292.80000000002,121222.4,79558.40000000002,192646.40000000005,223971.0617601984,228556.80000000005,116846.33088019838,63686.39999999999,137292.80000000002,127174.4,79558.40000000002,192646.40000000005,158499.06176019844,202566.40000000005,51374.330880198424,11904.0,5952.0,7936.0,1984.0,116846.33088019838,385292.8000000001,227740.66176039676,192646.40000000005,116846.33088019838,228556.80000000005,174580.73088019836,35910.399999999994,79558.40000000002,127372.79999999997,143244.80000000002,63686.39999999999,105152.0,186683.13088000007,105151.98016,107124.73088000003,-396.79999999999995,26188.8,17459.2,25990.399999999998,-7936.0,73408.0,-1995.2691200000017,57536.0,51584.0,-660672.0,55552.0,3968.0,3968.0,3571.2,3571.2,-396.79999999999995,-396.79999999999995,49203.79519999998,49203.79519999998,49600.59519999998,49600.59519999998,49203.79519999998,49203.79519999998,-396.79999999999995,-396.79999999999995,49203.79519999998,49203.79519999998,49600.59519999998,49600.59519999998,129158.9952,65472.59519999998,79558.40000000002,-5952.0,73198.33087999995,51175.930880000036,51374.33087999995,51187.20000000001,1984.0000000000146,67059.20000000001,79558.40000000002,-5952.0,73198.33087999995,51175.930880000036,51374.33087999995,51187.20000000001,-21823.99999999993,108921.6,16070.400000000005,79558.40000000002,127372.79999999997,159116.80000000005,63686.39999999999,107124.73088000003,771974.4,218019.0617601984,192646.40000000005,170414.3308801984,385292.8000000001,340828.6617603968,192646.40000000005,57734.399999999994,99596.79999999999,137292.80000000002,63686.39999999999,79558.40000000002,127372.79999999997,159116.80000000005,63686.39999999999,107124.73088000003,236294.40000000005,271587.0617601984,192646.40000000005,45422.33088019842,385292.8000000001,162268.6617603968,192646.40000000005,57734.399999999994,99596.79999999999,137292.80000000002,63686.39999999999,79558.40000000002,127372.79999999997,159116.80000000005,63686.39999999999,107124.73088000003,369222.4,220003.0617601984,192646.40000000005,104942.33088019838,385292.8000000001,215836.66176039676,192646.40000000005])
    (rev' codeTomsSlice (rreshape [32, 4] t128))

testTomsSlicePP :: Assertion
testTomsSlicePP = do
  resetVarCounter
  let artifactRev = revArtifactAdapt UseIncomingCotangent codeTomsSlice (FTKR [32, 4] FTKScalar)
  printArtifactPrimalPretty artifactRev
    @?= "\\m1 -> let v8 = sreplicate @32 (ssum @96 (sreshape @[96] (str (sslice (SNat @0) (SNat @3) (str (sfromR m1))) * str (sslice (SNat @1) (SNat @3) (str (sfromR m1)))))) in rfromS (ssum @128 (sreshape @[128] (str (sreplicate @4 (siota (SNat @32) * v8)))))"
  printArtifactPrimalPretty (simplifyArtifact artifactRev)
    @?= "\\m1 -> rfromS (sscalar 4.0 * sdot0 (sconcrete (sfromListLinear [32] [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0,11.0,12.0,13.0,14.0,15.0,16.0,17.0,18.0,19.0,20.0,21.0,22.0,23.0,24.0,25.0,26.0,27.0,28.0,29.0,30.0,31.0])) (sreplicate @32 (sdot0 (sslice (SNat @0) (SNat @3) (str (sfromR m1))) (sslice (SNat @1) (SNat @3) (str (sfromR m1))))))"
  printArtifactPretty artifactRev
    @?= "\\dret m1 -> let m10 = sreshape @[32,3] (sreplicate @96 (ssum @32 (siota (SNat @32) * ssum @4 (str (sreshape @[32,4] (sreplicate @128 (sfromR dret))))))) in rfromS (str (sappend (sconcrete (sfromListLinear [0,32] [])) (sappend (str (str (sslice (SNat @1) (SNat @3) (str (sfromR m1))) * m10)) (sconcrete (sfromListLinear [1,32] [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0])))) + str (sappend (sconcrete (sfromListLinear [1,32] [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0])) (sappend (str (str (sslice (SNat @0) (SNat @3) (str (sfromR m1))) * m10)) (sconcrete (sfromListLinear [0,32] [])))))"
  printArtifactPretty (simplifyArtifact artifactRev)
    @?= "\\dret m1 -> rfromS (let m10 = sreplicate @32 (sreplicate @3 (sdot0 (sconcrete (sfromListLinear [32] [0.0,4.0,8.0,12.0,16.0,20.0,24.0,28.0,32.0,36.0,40.0,44.0,48.0,52.0,56.0,60.0,64.0,68.0,72.0,76.0,80.0,84.0,88.0,92.0,96.0,100.0,104.0,108.0,112.0,116.0,120.0,124.0])) (sreplicate @32 (sfromR dret)))) in str (sappend (sslice (SNat @1) (SNat @3) (str (sfromR m1)) * str m10) (sconcrete (sfromListLinear [1,32] [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0]))) + str (sappend (sconcrete (sfromListLinear [1,32] [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0])) (sslice (SNat @0) (SNat @3) (str (sfromR m1)) * str m10)))"
