{-# LANGUAGE ImpredicativeTypes, OverloadedLists #-}
{-# OPTIONS_GHC -fplugin GHC.TypeLits.KnownNat.Solver #-}
{-# OPTIONS_GHC -fplugin GHC.TypeLits.Normalise #-}
module TestHighRankSimplified (testTrees) where

import Prelude

import qualified Data.Array.RankedS as OR
import qualified Data.Array.ShapedS as OS
import           Data.Bifunctor.Flip
import qualified Data.Strict.IntMap as IM
import           GHC.TypeLits (KnownNat, type (+), type (-), type (<=))
import           Test.Tasty
import           Test.Tasty.HUnit hiding (assert)

import HordeAd.Core.Ast
import HordeAd.Core.AstFreshId
import HordeAd.Core.AstPrettyPrint
import HordeAd.Core.AstSimplify
import HordeAd.Core.DualNumber
import HordeAd.Core.Engine
import HordeAd.Core.SizedIndex
import HordeAd.Core.TensorClass
import HordeAd.Core.Types
import HordeAd.External.CommonRankedOps

import CrossTesting
import EqEpsilon

testTrees :: [TestTree]
testTrees =
  [ testCase "3foo" testFoo
  , testCase "3bar" testBar
  , testCase "3barS" testBarS
  , testCase "3fooD T Double [1.1, 2.2, 3.3]" testFooD
  , testCase "3fooBuild0" testFooBuild0
  , testCase "3fooBuildOut" testFooBuildOut
  , testCase "3fooBuild91" testFooBuild91
  , testCase "3fooBuild92" testFooBuild92
  , testCase "3fooBuild21" testFooBuild21
  , testCase "3fooBuild25" testFooBuild25
  , testCase "3fooBuild3" testFooBuild3
  , testCase "3fooBuildDt" testFooBuildDt
  , testCase "3fooBuild5" testFooBuild5
  , testCase "3fooBuild1" testFooBuild1
  , testCase "3fooMap" testFooMap
  , testCase "3fooMap1" testFooMap1
  , testCase "3fooNoGo" testFooNoGo
  , testCase "3fooNoGo10" testFooNoGo10
  , testCase "3nestedBuildMap1" testNestedBuildMap1
  , testCase "3nestedBuildMap10" testNestedBuildMap10
  , testCase "3nestedBuildMap11" testNestedBuildMap11
  , testCase "3nestedBuildMap7" testNestedBuildMap7
  , testCase "3nestedSumBuild1" testNestedSumBuild1
  , testCase "3nestedSumBuild5" testNestedSumBuild5
  , testCase "3nestedSumBuildB" testNestedSumBuildB
  , testCase "3nestedBuildIndex" testNestedBuildIndex
  , testCase "3barReluADValDt" testBarReluADValDt
  , testCase "3barReluADVal" testBarReluADVal
  , testCase "3barReluADVal3" testBarReluADVal3
  , testCase "3reluSimp" testReluSimp
  , testCase "3barReluADVal320" testBarReluADVal320
  , testCase "3braidedBuilds" testBraidedBuilds
  , testCase "3braidedBuilds1" testBraidedBuilds1
  , testCase "3recycled" testRecycled
  , testCase "3recycled1" testRecycled1
  , testCase "3concatBuild0" testConcatBuild0
  , testCase "3concatBuild1" testConcatBuild1
  , testCase "3concatBuild2" testConcatBuild2
  , testCase "3concatBuild22" testConcatBuild22
  , testCase "3concatBuild3" testConcatBuild3
  , testCase "3concatBuild3PP" testConcatBuild3PP
  ]

foo :: RealFloat a => (a,a,a) -> a
foo (x,y,z) =
  let w = x * sin y
  in atan2 z w + z * w

testFoo :: Assertion
testFoo =
  assertEqualUpToEpsilon 1e-3
    (Flip $ OR.fromList [2,2,1, 2,2] [-4.6947093,1.5697206,-1.6332961,0.34882763,1.5697206,-1.0,-0.9784988,-0.9158946,6.6326222,3.6699238,7.85237,-2.9069107,17.976654,0.3914159,32.98194,19.807974],Flip $ OR.fromList [2,2,1, 2,2] [6.943779,-1.436789,33.67549,0.22397964,-1.436789,-1.0,-0.975235,-0.90365005,147.06645,-73.022705,-9.238474,-10.042692,-980.2843,-7.900571,-14.451739,436.9084],Flip $ OR.fromList [2,2,1, 2,2] [-4.8945336,2.067469,-1.7196897,1.3341143,2.067469,1.0,0.99846554,0.99536234,6.6943173,3.7482092,7.977362,-3.1475093,18.000969,0.48736274,33.01224,19.845064])
    (rev @Float @5 @(Flip OR.Array) foo (t16, t16, t16))

bar :: forall a. RealFloat a => (a, a) -> a
bar (x, y) =
  let w = foo (x, y, x) * sin y
  in atan2 x w + y * w

testBar :: Assertion
testBar =
  assertEqualUpToEpsilon 1e-5
    (Flip $ OR.fromList [3, 1, 2, 2, 1, 2, 2] [304.13867,914.9335,823.0187,1464.4688,5264.3306,1790.0055,1535.4309,3541.6572,304.13867,914.9335,823.0187,1464.4688,6632.4355,6047.113,1535.4309,1346.6815,45.92141,6.4903135,5.5406737,1.4242969,6.4903135,1.1458766,4.6446533,2.3550234,88.783676,27.467598,125.27507,18.177452,647.1917,0.3878851,2177.6152,786.1792,6.4903135,6.4903135,6.4903135,6.4903135,2.3550234,2.3550234,2.3550234,2.3550234,21.783596,2.3550234,2.3550234,2.3550234,21.783596,21.783596,21.783596,21.783596],Flip $ OR.fromList [3, 1, 2, 2, 1, 2, 2] [-5728.7617,24965.113,32825.07,-63505.953,-42592.203,145994.88,-500082.5,-202480.06,-5728.7617,24965.113,32825.07,-63505.953,49494.473,-2446.7632,-500082.5,-125885.58,-43.092484,-1.9601002,-98.97709,2.1931143,-1.9601002,1.8243169,-4.0434446,-1.5266153,2020.9731,-538.0603,-84.28137,62.963814,-34987.0,-9.917454,135.30023,17741.998,-1.9601002,-1.9601002,-1.9601002,-1.9601002,-1.5266153,-1.5266153,-1.5266153,-1.5266153,-4029.1775,-1.5266153,-1.5266153,-1.5266153,-4029.1775,-4029.1775,-4029.1775,-4029.1775])
    (crev (bar @(ADVal (Flip OR.Array) Float 7)) (t48, t48))

testBarS :: Assertion
testBarS =
  assertEqualUpToEpsilon 1e-5
    (Flip $ OS.fromList @'[3, 1, 2, 2, 1, 2, 2] [304.13867,914.9335,823.0187,1464.4688,5264.3306,1790.0055,1535.4309,3541.6572,304.13867,914.9335,823.0187,1464.4688,6632.4355,6047.113,1535.4309,1346.6815,45.92141,6.4903135,5.5406737,1.4242969,6.4903135,1.1458766,4.6446533,2.3550234,88.783676,27.467598,125.27507,18.177452,647.1917,0.3878851,2177.6152,786.1792,6.4903135,6.4903135,6.4903135,6.4903135,2.3550234,2.3550234,2.3550234,2.3550234,21.783596,2.3550234,2.3550234,2.3550234,21.783596,21.783596,21.783596,21.783596], Flip $ OS.fromList @'[3, 1, 2, 2, 1, 2, 2] [-5728.7617,24965.113,32825.07,-63505.953,-42592.203,145994.88,-500082.5,-202480.06,-5728.7617,24965.113,32825.07,-63505.953,49494.473,-2446.7632,-500082.5,-125885.58,-43.092484,-1.9601002,-98.97709,2.1931143,-1.9601002,1.8243169,-4.0434446,-1.5266153,2020.9731,-538.0603,-84.28137,62.963814,-34987.0,-9.917454,135.30023,17741.998,-1.9601002,-1.9601002,-1.9601002,-1.9601002,-1.5266153,-1.5266153,-1.5266153,-1.5266153,-4029.1775,-1.5266153,-1.5266153,-1.5266153,-4029.1775,-4029.1775,-4029.1775,-4029.1775])
    (crev (bar @(ADVal (Flip OS.Array) Float '[3, 1, 2, 2, 1, 2, 2])) (sfromR t48, sfromR t48))

-- A dual-number and list-based version of a function that goes
-- from `R^3` to `R`.
fooD :: forall r n. (RealFloat (ADVal (Flip OR.Array) r n))
     => [ADVal (Flip OR.Array) r n] -> ADVal (Flip OR.Array) r n
fooD [x, y, z] =
  let w = x * sin y
  in atan2 z w + z * w
fooD _ = error "wrong number of arguments"

testFooD :: Assertion
testFooD =
  assertEqualUpToEpsilon 1e-10
    [Flip $ OR.fromList [1,2,2,1,2,2,2,2,2,1] [18.73108960474591,20.665204824764675,25.821775835995922,18.666613887422585,34.775664100213014,62.54884873632415,37.93303229694526,11.635186977032971,18.73108960474591,20.665204824764675,25.821775835995922,20.600738734367262,34.775664100213014,62.54884873632415,16.663997008808924,3.1300339898598155,1.060799258653783,3.78942741815228,0.1889454555944933,-1.060799258653783,62.54884873632415,37.93303229694526,62.54884873632415,35.99996432769119,62.54884873632415,37.93303229694526,11.635186977032971,18.73108960474591,20.665204824764675,25.821775835995922,20.665204824764675,20.665204824764675,25.821775835995922,34.134947381491145,34.775664100213014,45527.22315787758,-4.488300547708207,2.1475176207684497,8.404498097344806,5.747373381623309,5.096832468946128,-2.4630526910399646,18.666613887422585,1.7769486222994448,-215.8115662030395,16.73214939773215,1.060799258653783,1.060799258653783,1.060799258653783,1.060799258653783,2.1475176207684497,2.1475176207684497,2.1475176207684497,2.1475176207684497,16.08742477551077,16.08742477551077,16.08742477551077,16.08742477551077,2.1475176207684497,2.1475176207684497,2.1475176207684497,2.1475176207684497,16.08742477551077,16.08742477551077,16.08742477551077,16.08742477551077,25.821775835995922,5.096832468946128,7.045006174919766,-1.7808956511653404,16.663997008744435,18.533999054066836,-25.177267779903083,16.60317012020362,25.821775835995922,5.096832468946128,7.045006174919766,-1.7808956511653404,16.663997008744435,18.533999054066836,-12.280721583745471,16.60317012020362,5.161956818274285,18.73108960474591,20.665204824764675,25.821775835995922,20.665204824764675,25.821775835995922,188.11000552192755,34.775664100213014,62.54884873632415,35.99996432769119,62.54884873632415,55.32933980086011,62.54884873632415,55.32933980086011,11.635186977032971,18.73108960474591,20.665204824764675,25.821775835995922,20.665204824764675,25.821775835995922,20.665204824764675,25.821775835995922,14.152094926881784,34.775664100213014,62.54884873632415,53.39649491503442,62.54884873632415,14.72904006548922,62.54884873632415,37.93303229694526,11.635186977032971,18.73108960474591,20.665204824764675,25.821775835995922,20.665204824764675,25.821775835995922,20.665204824764675,25.821775835995922,57.33025874582143,34.775664100213014,62.54884873632415,36.64432517917614,62.54884873632415,34.06684929392724,62.54884873632415,35.99996432769119],Flip $ OR.fromList [1,2,2,1,2,2,2,2,2,1] [647.1354943759653,787.5605199613974,1229.333367336918,642.6917612678424,2229.2701397674327,7210.705208776531,2652.3459120285806,250.02943073785886,647.1354943759653,787.5605199613974,1229.333367336918,782.6578815409038,2229.2701397674327,7210.705208776531,512.2982591657892,18.580536443699742,2.518850510725482,26.993800503829114,0.2243239488720164,2.518850510725482,7210.705208776531,2652.3459120285806,7210.705208776531,2388.9603285490866,7210.705208776531,2652.3459120285806,250.02943073785886,647.1354943759653,787.5605199613974,1229.333367336918,787.5605199613974,787.5605199613974,1229.333367336918,2147.9011858437157,2229.2701397674327,-0.5405182383359878,-0.5328698165396271,-0.5099245509210925,130.7140495214786,61.4116989316311,48.40938174779479,11.696956758139343,642.6917612678424,6.317020301049852,85833.87394976329,516.4928003659018,2.518850510725482,2.518850510725482,2.518850510725482,2.518850510725482,-0.5099245509210925,-0.5099245509210925,-0.5099245509210925,-0.5099245509210925,477.4973215160379,477.4973215160379,477.4973215160379,477.4973215160379,-0.5099245509210925,-0.5099245509210925,-0.5099245509210925,-0.5099245509210925,477.4973215160379,477.4973215160379,477.4973215160379,477.4973215160379,1229.333367336918,48.40938174779479,92.00538642301063,6.3430614471479245,512.2982591618282,633.5999783697488,1168.7578661039847,508.56903530563443,1229.333367336918,48.40938174779479,92.00538642301063,6.3430614471479245,512.2982591618282,633.5999783697488,278.48156010484087,508.56903530563443,49.64077766932281,647.1354943759653,787.5605199613974,1229.333367336918,787.5605199613974,1229.333367336918,65212.963738386214,2229.2701397674327,7210.705208776531,2388.9603285490866,7210.705208776531,5642.338335044463,7210.705208776531,5642.338335044463,250.02943073785886,647.1354943759653,787.5605199613974,1229.333367336918,787.5605199613974,1229.333367336918,787.5605199613974,1229.333367336918,369.6431004072799,2229.2701397674327,7210.705208776531,5255.048317224881,7210.705208776531,400.3514287686239,7210.705208776531,2652.3459120285806,250.02943073785886,647.1354943759653,787.5605199613974,1229.333367336918,787.5605199613974,1229.333367336918,787.5605199613974,1229.333367336918,6057.774447242021,2229.2701397674327,7210.705208776531,2475.225838667682,7210.705208776531,2139.3419044407133,7210.705208776531,2388.9603285490866],Flip $ OR.fromList [1,2,2,1,2,2,2,2,2,1] [18.76237979248771,20.69357069589509,25.8444826804669,18.698011972363496,34.7925278085306,62.558226125235436,37.948492946856575,11.685493300971446,18.76237979248771,20.69357069589509,25.8444826804669,20.629193248844963,34.7925278085306,62.558226125235436,16.699160877305292,3.3121428825170947,1.516071490296981,3.9411848287000124,1.0994899188808887,-1.516071490296981,62.558226125235436,37.948492946856575,62.558226125235436,36.01625479268449,62.558226125235436,37.948492946856575,11.685493300971446,18.76237979248771,20.69357069589509,25.8444826804669,20.69357069589509,20.69357069589509,25.8444826804669,34.1521274657041,34.7925278085306,-45527.22317076194,4.617144085155745,-2.4052046956635262,8.474005308282699,5.84854498865513,5.210650526856928,-2.6906888068615635,18.698011972363496,2.0810391881996813,-215.8142842462135,16.767170338627782,1.516071490296981,1.516071490296981,1.516071490296981,1.516071490296981,-2.4052046956635262,-2.4052046956635262,-2.4052046956635262,-2.4052046956635262,16.123846116986126,16.123846116986126,16.123846116986126,16.123846116986126,-2.4052046956635262,-2.4052046956635262,-2.4052046956635262,-2.4052046956635262,16.123846116986126,16.123846116986126,16.123846116986126,16.123846116986126,25.8444826804669,5.210650526856928,7.127782944309438,-2.0844104722608057,16.69916087724094,18.565621417897145,-25.200555362084323,16.638462541261234,25.8444826804669,5.210650526856928,7.127782944309438,-2.0844104722608057,16.69916087724094,18.565621417897145,-12.328394068734287,16.638462541261234,5.2743697149763085,18.76237979248771,20.69357069589509,25.8444826804669,20.69357069589509,25.8444826804669,188.113123824884,34.7925278085306,62.558226125235436,36.01625479268449,62.558226125235436,55.33994055377702,62.558226125235436,55.33994055377702,11.685493300971446,18.76237979248771,20.69357069589509,25.8444826804669,20.69357069589509,25.8444826804669,20.69357069589509,25.8444826804669,14.193483311576621,34.7925278085306,62.558226125235436,53.40747931617656,62.558226125235436,14.768811697198851,62.558226125235436,37.948492946856575,11.685493300971446,18.76237979248771,20.69357069589509,25.8444826804669,20.69357069589509,25.8444826804669,20.69357069589509,25.8444826804669,57.34048958248757,34.7925278085306,62.558226125235436,36.660329315674915,62.558226125235436,34.08406370302229,62.558226125235436,36.01625479268449]]
    (crev fooD [ t128
               , Flip
                 $ OR.constant [1, 2, 2, 1, 2, 2, 2, 2, 2, 1] (0.7 :: Double)
               , t128 ])

fooBuild0 :: forall ranked r n. (ADReady ranked r, KnownNat n)
          => ranked r (1 + n) -> ranked r (1 + n)
fooBuild0 v =
  let r = tsum v
  in tbuild1 2 $ const r

testFooBuild0 :: Assertion
testFooBuild0 =
  assertEqualUpToEpsilon' 1e-10
    (OR.fromList [2,2,1,2,2] [2.0,2.0,2.0,2.0,2.0,2.0,2.0,2.0,2.0,2.0,2.0,2.0,2.0,2.0,2.0,2.0])
    (rev' @Double @5 fooBuild0 t16)

fooBuildOut
  :: forall ranked r n. (ADReady ranked r, KnownNat n)
  => ranked r (1 + n) -> ranked r (1 + n)
fooBuildOut v =
  tbuild1 2 $ \ix -> ifF (ix ==. 0)
                         (tindex v [ix + 1])  -- index out of bounds; guarded
                         (tsum v)

testFooBuildOut :: Assertion
testFooBuildOut =
  assertEqualUpToEpsilon' 1e-10
    (OR.fromList [2,2,1,2,2] [1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,2.0,2.0,2.0,2.0,2.0,2.0,2.0,2.0])
    (rev' @Double @5 fooBuildOut t16)

fooBuild2
  :: forall ranked r n.
     (ADReady ranked r, KnownNat n, Floating (ranked r n), RealFloat r)
  => ranked r (1 + n) -> ranked r (1 + n)
fooBuild2 v =
  tbuild1 2 $ \ix ->
    ifF (ix - (tprimalPart . tfloor) (tsum0 @ranked @r @5
                      $ treplicate0N [5,12,11,9,4] (tsum0 v)) - 10001 >=. 0
         &&* ix - (tprimalPart . tfloor) (tsum0 @ranked @r @5
                          $ treplicate0N [5,12,11,9,4] (tsum0 v)) - 10001 <=. 1)
        (tindex v [ix - (tprimalPart . tfloor) (tsum0 @ranked @r @5
                                $ treplicate0N [5,12,11,9,4] (tsum0 v)) - 10001])
           -- index out of bounds; also fine
        (sqrt $ abs $ tindex v [let rr = (ix - (tprimalPart . tfloor) (tsum0 v) - 10001) `rem` 2
                                in ifF (signum rr ==. negate (signum 2))
                                   (rr + 2)
                                   rr])

testFooBuild91 :: Assertion
testFooBuild91 =
  assertEqualUpToEpsilon 1e-8
    (map (Flip . OR.fromList [2]) [[1.5811388300841895,1.118033988749895],[1.118033988749895,0.9128709291752769],[0.9128709291752769,0.7905694150420948],[0.7905694150420948,0.7071067811865475],[0.7071067811865475,0.6454972243679028],[0.6454972243679028,0.5976143046671968],[0.5976143046671968,0.5590169943749475],[0.5590169943749475,0.5270462766947299],[0.5270462766947299,1.5811388300841895],[1.5811388300841895,0.5270462766947299],[1.5811388300841895,1.118033988749895],[1.118033988749895,0.9128709291752769],[0.9128709291752769,0.7905694150420948],[0.7905694150420948,0.7071067811865475],[0.7071067811865475,0.6454972243679028],[0.6454972243679028,0.5976143046671968],[0.5976143046671968,0.5590169943749475],[0.5590169943749475,0.5270462766947299],[0.5270462766947299,1.5811388300841895],[1.5811388300841895,0.5270462766947299],[1.5811388300841895,1.118033988749895],[1.118033988749895,0.9128709291752769],[0.9128709291752769,0.7905694150420948],[0.7905694150420948,0.7071067811865475],[0.7071067811865475,0.6454972243679028],[0.6454972243679028,0.5976143046671968],[0.5976143046671968,0.5590169943749475],[0.5590169943749475,0.5270462766947299],[0.5270462766947299,1.5811388300841895],[1.5811388300841895,0.5270462766947299],[1.5811388300841895,1.118033988749895],[1.118033988749895,0.9128709291752769],[0.9128709291752769,0.7905694150420948],[0.7905694150420948,0.7071067811865475],[0.7071067811865475,0.6454972243679028],[0.6454972243679028,0.5976143046671968],[0.5976143046671968,0.5590169943749475],[0.5590169943749475,0.5270462766947299],[0.5270462766947299,1.5811388300841895],[1.5811388300841895,0.5270462766947299],[1.5811388300841895,1.118033988749895],[1.118033988749895,0.9128709291752769],[0.9128709291752769,0.7905694150420948],[0.7905694150420948,0.7071067811865475],[0.7071067811865475,0.6454972243679028],[0.6454972243679028,0.5976143046671968],[0.5976143046671968,0.5590169943749475],[0.5590169943749475,0.5270462766947299],[0.5270462766947299,1.5811388300841895],[1.5811388300841895,0.5270462766947299]])
    (map (crev @Double @1 fooBuild2)
         (map (Flip . OR.fromList [2]) [[0.1, 0.2], [0.2, 0.3], [0.3, 0.4], [0.4, 0.5], [0.5, 0.6], [0.6, 0.7], [0.7, 0.8], [0.8, 0.9], [0.9, 0.1], [0.1, 0.9], [0.1, 0.2], [0.2, 0.3], [0.3, 0.4], [0.4, 0.5], [0.5, 0.6], [0.6, 0.7], [0.7, 0.8], [0.8, 0.9], [0.9, 0.1], [0.1, 0.9], [0.1, 0.2], [0.2, 0.3], [0.3, 0.4], [0.4, 0.5], [0.5, 0.6], [0.6, 0.7], [0.7, 0.8], [0.8, 0.9], [0.9, 0.1], [0.1, 0.9], [0.1, 0.2], [0.2, 0.3], [0.3, 0.4], [0.4, 0.5], [0.5, 0.6], [0.6, 0.7], [0.7, 0.8], [0.8, 0.9], [0.9, 0.1], [0.1, 0.9], [0.1, 0.2], [0.2, 0.3], [0.3, 0.4], [0.4, 0.5], [0.5, 0.6], [0.6, 0.7], [0.7, 0.8], [0.8, 0.9], [0.9, 0.1], [0.1, 0.9]]))

testFooBuild92 :: Assertion
testFooBuild92 =
  assertEqualUpToEpsilon 1e-8
    (map (Flip . OR.fromList [2]) [[1.5811388300841895,1.118033988749895],[1.118033988749895,0.9128709291752769],[0.9128709291752769,0.7905694150420948],[0.7905694150420948,0.7071067811865475],[0.7071067811865475,0.6454972243679028],[0.6454972243679028,0.5976143046671968],[0.5976143046671968,0.5590169943749475],[0.5590169943749475,0.5270462766947299],[0.5270462766947299,1.5811388300841895],[1.5811388300841895,0.5270462766947299],[1.5811388300841895,1.118033988749895],[1.118033988749895,0.9128709291752769],[0.9128709291752769,0.7905694150420948],[0.7905694150420948,0.7071067811865475],[0.7071067811865475,0.6454972243679028],[0.6454972243679028,0.5976143046671968],[0.5976143046671968,0.5590169943749475],[0.5590169943749475,0.5270462766947299],[0.5270462766947299,1.5811388300841895],[1.5811388300841895,0.5270462766947299],[1.5811388300841895,1.118033988749895],[1.118033988749895,0.9128709291752769],[0.9128709291752769,0.7905694150420948],[0.7905694150420948,0.7071067811865475],[0.7071067811865475,0.6454972243679028],[0.6454972243679028,0.5976143046671968],[0.5976143046671968,0.5590169943749475],[0.5590169943749475,0.5270462766947299],[0.5270462766947299,1.5811388300841895],[1.5811388300841895,0.5270462766947299],[1.5811388300841895,1.118033988749895],[1.118033988749895,0.9128709291752769],[0.9128709291752769,0.7905694150420948],[0.7905694150420948,0.7071067811865475],[0.7071067811865475,0.6454972243679028],[0.6454972243679028,0.5976143046671968],[0.5976143046671968,0.5590169943749475],[0.5590169943749475,0.5270462766947299],[0.5270462766947299,1.5811388300841895],[1.5811388300841895,0.5270462766947299],[1.5811388300841895,1.118033988749895],[1.118033988749895,0.9128709291752769],[0.9128709291752769,0.7905694150420948],[0.7905694150420948,0.7071067811865475],[0.7071067811865475,0.6454972243679028],[0.6454972243679028,0.5976143046671968],[0.5976143046671968,0.5590169943749475],[0.5590169943749475,0.5270462766947299],[0.5270462766947299,1.5811388300841895],[1.5811388300841895,0.5270462766947299]])
    (map (rev @Double @1 @(Flip OR.Array) fooBuild2)
         (map (Flip . OR.fromList [2]) [[0.1, 0.2], [0.2, 0.3], [0.3, 0.4], [0.4, 0.5], [0.5, 0.6], [0.6, 0.7], [0.7, 0.8], [0.8, 0.9], [0.9, 0.1], [0.1, 0.9], [0.1, 0.2], [0.2, 0.3], [0.3, 0.4], [0.4, 0.5], [0.5, 0.6], [0.6, 0.7], [0.7, 0.8], [0.8, 0.9], [0.9, 0.1], [0.1, 0.9], [0.1, 0.2], [0.2, 0.3], [0.3, 0.4], [0.4, 0.5], [0.5, 0.6], [0.6, 0.7], [0.7, 0.8], [0.8, 0.9], [0.9, 0.1], [0.1, 0.9], [0.1, 0.2], [0.2, 0.3], [0.3, 0.4], [0.4, 0.5], [0.5, 0.6], [0.6, 0.7], [0.7, 0.8], [0.8, 0.9], [0.9, 0.1], [0.1, 0.9], [0.1, 0.2], [0.2, 0.3], [0.3, 0.4], [0.4, 0.5], [0.5, 0.6], [0.6, 0.7], [0.7, 0.8], [0.8, 0.9], [0.9, 0.1], [0.1, 0.9]]))

testFooBuild21 :: Assertion
testFooBuild21 =
  assertEqualUpToEpsilon' 1e-10
    (OR.fromList [2] [0.2886751345948129,0.35355339059327373])
    (rev' @Double @1 fooBuild2 (Flip $ OR.fromList [2] [3.0,2.0]))

testFooBuild25 :: Assertion
testFooBuild25 =
  assertEqualUpToEpsilon' 1e-10
    (OR.fromList [2,2,1,2,2] [0.22360679774997896,0.35355339059327373,0.20412414523193154,0.5,-0.35355339059327373,500.0,1.5811388300841895,-1.118033988749895,0.1381447409988844,0.16666666666666666,0.17677669529663687,-0.25,8.574929257125441e-2,0.288948802391873,-8.703882797784893e-2,9.805806756909202e-2])
    (rev' @Double @5 fooBuild2 t16)

fooBuild3 :: forall ranked r n.
             ( ADReady ranked r, KnownNat n, RealFloat (ranked r n) )
          => ranked r (1 + n) -> ranked r (1 + n)
fooBuild3 v =
  tbuild1 22 $ \ix ->
    bar ( treplicate0N (tailShape $ tshape v) 1
        , tindex v [minF 1 (ix + 1)] )  -- index not out of bounds

testFooBuild3 :: Assertion
testFooBuild3 =
  assertEqualUpToEpsilon' 1e-10
    (OR.fromList [2,2,1,2,2] [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,423.72976235076516,-260.41676627885636,-17.60047532855961,151.18955028869385,-1059.9668424433578,-65.00898015327623,-21.49245448729951,743.7622427949768])
    (rev' @Double @5 fooBuild3 t16)

fooBuild5 :: forall ranked r n.
             ( ADReady ranked r, KnownNat n, RealFloat (ranked r n) )
          => ranked r (1 + n) -> ranked r (1 + n)
fooBuild5 v =
  let r = tsum v
      v' = treplicate0N (tailShape $ tshape v) $ tminimum $ tflatten v
  in tbuild1 2 $ \ix ->
       r * foo ( treplicate0N (tailShape $ tshape v) 3
               , tscaleByScalar 5 r
               , r * v')
       + bar (r, tindex v [minF 1 (ix + 1)])  -- index not out of bounds

testFooBuildDt :: Assertion
testFooBuildDt =
  assertEqualUpToEpsilon1 1e-8
    (OR.fromList [2,2,1,2,2] [1.1033568028244503e7,74274.22833989389,-5323238.2765011545,253074.03394016018,4.14744804041263e7,242643.98750578283,-1.922371592087736e7,2.730274503834733e7,1.135709425204681e7,6924.195066252549,-5345004.080027547,255679.51406100337,3.8870981856703006e7,241810.92121468345,-1.9380955730171032e7,2.877024321777493e7])
    (revDt @Double @5 fooBuild5 t16 (Flip $ OR.constant [2, 2, 1, 2, 2] 42))

testFooBuild5 :: Assertion
testFooBuild5 =
  assertEqualUpToEpsilon' 1e-8
    (OR.fromList [3,1,2,2,1,2,2] [-613291.6547530327,571164.2201603781,-1338602.6247083102,528876.2566682736,1699442.2143691683,2874891.369778316,-3456754.605470273,3239487.8744244366,554916.1344235454,-775449.1803684114,3072.200583200206,1165767.8436804386,-1.0686356667942494e7,-6606976.194539241,-6457671.748790982,4791868.42112978,-615556.7946425928,569660.3506343022,-1348678.1169100606,534886.9366492515,1696036.143341285,2883992.9672165257,-3456212.5353846983,3240296.690514803,629047.8398075115,-794389.5797803313,-1143.8025173051583,1177448.8083517442,-1.15145721735623e7,-6618648.839812404,-6462386.031613377,5358224.852822481,-613291.6547530327,571164.2201603781,-1338602.6247083102,528876.2566682736,1699442.2143691683,2874891.369778316,-3456754.605470273,3239487.8744244366,554916.1344235454,-775449.1803684114,3072.200583200206,1165767.8436804386,-1.0686356667942494e7,-6606976.194539241,-6457671.748790982,4791868.42112978])
    (rev' @Double @7 fooBuild5 t48)

fooBuild1 :: forall ranked r n.
             ( ADReady ranked r, KnownNat n, RealFloat (ranked r n) )
          => ranked r (1 + n) -> ranked r (1 + n)
fooBuild1 v =
  let r = tsum v
      tk = treplicate0N (tailShape $ tshape v)
      v' = tk $ tminimum $ tflatten v
  in tbuild1 3 $ \ix ->
       r * foo ( tk 3
               , tk 5 * r
               , r * v')
       + bar (r, tindex v [minF 1 (ix + 1)])

testFooBuild1 :: Assertion
testFooBuild1 =
  assertEqualUpToEpsilon' 1e-8
    (OR.fromList [2,2,1,2,2] [394056.00100873224,2652.651012139068,-190115.65273218407,9038.358355005721,1481231.4430045108,8665.8566966351,-686561.2828884773,975098.0370838332,405610.50900167174,247.29268093759174,-190893.00285812665,9131.411216464405,1388249.3520251075,8636.104329095837,-692176.9903632513,1027508.6863491047])
    (rev' @Double @5 fooBuild1 t16)

fooMap1 :: (ADReady ranked r, KnownNat n, Differentiable r)
        => ShapeInt (1 + n) -> ranked r 0 -> ranked r (1 + n)
fooMap1 sh r =
  let v = fooBuild1 $ treplicate0N sh (r * r)
  in tmap0N (\x -> x * r + 5) v

testFooMap :: Assertion
testFooMap =
  assertEqualUpToEpsilon' 1e-3
    2.7518227
    (rev' @Float @1 (fooMap1 [130]) 0.1)

-- Reduced test, because this takes forever with Ast but without vectorization.
-- TODO: investigate why.
testFooMap1 :: Assertion
testFooMap1 =
  assertEqualUpToEpsilonShort 1e-6
    3901.312463734578
    (rev' @Double @7 (fooMap1 [4, 3, 2, 3, 4, 5, 3]) 0.1)

fooNoGo :: forall ranked r n.
           ( ADReady ranked r, KnownNat n, Differentiable r )
        => ranked r (1 + n) -> ranked r (1 + n)
fooNoGo v =
  let r = tsum v
      r0 = tsum0 v
      shTail = tailShape (tshape v)
  in tbuild1 3 (\ix ->
       bar ( treplicate0N shTail 3.14
           , bar ( tconst (OR.constant (shapeToList shTail) 3.14)
                 , tindex v [ix]) )
       + ifF (tindex v (ix * 2 :. ZI) <=. treplicate0N shTail 0 &&* 6 >. abs ix)
               r (treplicate0N shTail 5 * r))
     / tslice 1 3 (tmap0N (\x -> ifF (x >. r0) r0 x) v)
     * tbuild1 3 (const $ tconst $ OR.constant (shapeToList shTail) 1)

testFooNoGo :: Assertion
testFooNoGo =
  assertEqualUpToEpsilon' 1e-6
   (OR.fromList [5] [344.3405885672822,-396.1811403813819,7.735358041386672,-0.8403418295960372,5.037878787878787])
   (rev' @Double @1 fooNoGo
         (Flip $ OR.fromList [5] [1.1 :: Double, 2.2, 3.3, 4, 5]))

testFooNoGo10 :: Assertion
testFooNoGo10 =
  assertEqualUpToEpsilonShort 1e-10
    (OR.fromList [5, 3, 1, 2, 2, 1, 2, 2] [8.096867407436072e-8,9.973025492756426e-8,9.976696178938985e-8,5.614458707681111e-8,-1.8338500573636686e-7,-2.144970334428336e-7,7.354143606421902e-7,-1.8140041785503643e-7,8.096867407436072e-8,9.973025492756426e-8,9.976696178938985e-8,5.614458707681111e-8,-2.01381292700262e-7,-2.221588091014473e-7,7.354143606421902e-7,-1.9951065225263367e-7,1.7230532848112822e-7,4.5426218104870796e-7,1.430886696893587e-7,9.354993295163118e-7,-5.225515010723883e-7,1.019433073376504e-6,9.64067025472343e-6,-4.872227980305747e-6,8.089200625992941e-8,9.924319994964371e-8,1.092480101004153e-7,-2.8478802468285825e-7,9.641049518625974e-8,2.9624147815716037e-7,-1.950868158558337e-7,9.547754822865364e-8,4.5426218104870796e-7,4.5426218104870796e-7,4.5426218104870796e-7,4.5426218104870796e-7,-4.872227980305747e-6,-4.872227980305747e-6,-4.872227980305747e-6,-4.872227980305747e-6,9.361277121832246e-8,-4.872227980305747e-6,-4.872227980305747e-6,-4.872227980305747e-6,9.361277121832246e-8,9.361277121832246e-8,9.361277121832246e-8,9.361277121832246e-8,-5.488572216677945e-7,-1.8496203182958057e-7,-1.4603644180845103e-7,-1.2145268106051633e-7,-2.817402689957553e-7,-2.9913537180597976e-7,6.272804203945257e-7,-2.3697344464172694e-7,-5.488572216677945e-7,-1.8496203182958057e-7,-1.4603644180845103e-7,-1.2145268106051633e-7,-2.613973017956691e-7,-3.0013408634207794e-7,6.272804203945257e-7,-2.916736028401805e-7,-7.0114505846358575e-6,-4.303381366239431e-5,-4.897282418246382e-6,-1.710952247892854e-4,-4.2040039667393255e-5,-2.0204742564752248e-4,-1.7017980671040968e-2,-4.247008401789142e-3,-1.056090348050961e-6,-2.210187184450231e-6,-2.7842041329045203e-6,-1.0402806498987974e-5,-1.2967382896879757e-7,-1.9315601705070884e-5,-2.40087090725031e-7,-2.4419692405172046e-7,-4.303381366239431e-5,-4.303381366239431e-5,-4.303381366239431e-5,-4.303381366239431e-5,-4.247008401789142e-3,-4.247008401789142e-3,-4.247008401789142e-3,-4.247008401789142e-3,-2.683138631810477e-7,-4.247008401789142e-3,-4.247008401789142e-3,-4.247008401789142e-3,-2.683138631810477e-7,-2.683138631810477e-7,-2.683138631810477e-7,-2.683138631810477e-7,-5.488572216677945e-7,-1.8496203182958057e-7,-1.4603644180845103e-7,-1.2145268106051633e-7,-2.817402689957553e-7,-2.9913537180597976e-7,6.272804203945257e-7,-2.3697344464172694e-7,-5.488572216677945e-7,-1.8496203182958057e-7,-1.4603644180845103e-7,-1.2145268106051633e-7,-2.613973017956691e-7,-3.0013408634207794e-7,6.272804203945257e-7,-2.916736028401805e-7,-7.0114505846358575e-6,-4.303381366239431e-5,-4.897282418246382e-6,-1.710952247892854e-4,-4.2040039667393255e-5,-2.0204742564752248e-4,-1.7017980671040968e-2,-4.247008401789142e-3,-1.056090348050961e-6,-2.210187184450231e-6,-2.7842041329045203e-6,-1.0402806498987974e-5,-1.2967382896879757e-7,-1.9315601705070884e-5,-2.40087090725031e-7,-2.4419692405172046e-7,-4.303381366239431e-5,-4.303381366239431e-5,-4.303381366239431e-5,-4.303381366239431e-5,-4.247008401789142e-3,-4.247008401789142e-3,-4.247008401789142e-3,-4.247008401789142e-3,-2.683138631810477e-7,-4.247008401789142e-3,-4.247008401789142e-3,-4.247008401789142e-3,-2.683138631810477e-7,-2.683138631810477e-7,-2.683138631810477e-7,-2.683138631810477e-7,-5.469529675653596e-7,-2.331458950045675e-7,-1.9907443163522408e-7,-1.4019078434680374e-7,-6.95091094132346e-8,-5.685763846730528e-8,-9.268594848659335e-8,-3.010367762029461e-8,-5.469529675653596e-7,-2.331458950045675e-7,-1.9907443163522408e-7,-1.4019078434680374e-7,-3.415394012988984e-8,-5.069973314807702e-8,-9.268594848659335e-8,-6.380451815099858e-8,-6.883755913116986e-6,-4.273807584344302e-5,-4.79037108793574e-6,-1.705307241188017e-4,-4.2267488166320864e-5,-2.0143642393829028e-4,-1.701262134129569e-2,-4.2496361738088365e-3,-1.0224785375169973e-6,-2.1427637177332083e-6,-2.705952143004936e-6,-1.0493018474305117e-5,-1.819666770962338e-7,-1.911089472080586e-5,-9.045482032374276e-8,-2.819821645880664e-7,-4.273807584344302e-5,-4.273807584344302e-5,-4.273807584344302e-5,-4.273807584344302e-5,-4.2496361738088365e-3,-4.2496361738088365e-3,-4.2496361738088365e-3,-4.2496361738088365e-3,-3.019273543907303e-7,-4.2496361738088365e-3,-4.2496361738088365e-3,-4.2496361738088365e-3,-3.019273543907303e-7,-3.019273543907303e-7,-3.019273543907303e-7,-3.019273543907303e-7,8.287292817679557e-8,5.154639175257732e-8,4.672897196261682e-8,3.740648379052369e-8,2.884615384615385e-8,2.7780699895840894e-8,1.5447991761071065e-8,2.546934916639589e-8,8.287292817679557e-8,5.154639175257732e-8,4.672897196261682e-8,3.740648379052369e-8,2.5862068965517245e-8,2.7275544092553562e-8,1.5447991761071065e-8,2.8358432436548274e-8,3.0000000000000004e-7,7.500000000000001e-7,2.5000000000000004e-7,1.5000000000000002e-6,-7.500000000000001e-7,1.6304347826086957e-6,1.5000000000000002e-5,-7.500000000000001e-6,1.1450381679389314e-7,1.6666666666666668e-7,1.8750000000000003e-7,-3.7500000000000006e-7,4.411764705882353e-8,5.00948462422186e-7,-4.545454545454546e-8,5.76923076923077e-8,7.500000000000001e-7,7.500000000000001e-7,7.500000000000001e-7,7.500000000000001e-7,-7.500000000000001e-6,-7.500000000000001e-6,-7.500000000000001e-6,-7.500000000000001e-6,5.999928000863991e-8,-7.500000000000001e-6,-7.500000000000001e-6,-7.500000000000001e-6,5.999928000863991e-8,5.999928000863991e-8,5.999928000863991e-8,5.999928000863991e-8])
   (rev' @Double @8 (tmap0N (* 0.000000001) . fooNoGo) (tmap0N (* 0.01) $ treplicate 5 t48))

nestedBuildMap :: forall ranked n r.
                  (ADReady ranked r, n <= 6, KnownNat n, Differentiable r)
               => ranked r 0 -> ranked r (1 + n)
nestedBuildMap r =
  let w x = treplicate0N [4] x :: ranked r 1
      v' = treplicate0N (177 :$ ZS) r
      nestedMap x = tmap0N (x /) (w x)
      variableLengthBuild iy = tbuild1 7 (\ix ->
        tindex v' (ix + iy :. ZI))
      doublyBuild =
        tbuild1 3 (treplicate0N (takeShape @n @(6 - n)
                             $ 2 :$ 4 :$ 2 :$ 1 :$ 3 :$ 2 :$ ZS)
                   . tminimum . variableLengthBuild)
  in tmap0N (\x -> x * tsum0
                         (tbuild1 3 (\ix -> bar (x, tindex v' [ix]))
                          + fooBuild1 (nestedMap x)
                          / fooMap1 [3] x)
            ) doublyBuild

testNestedBuildMap1 :: Assertion
testNestedBuildMap1 =
  assertEqualUpToEpsilonShort 1e-8
    22.673212907588812
    (rev' @Double @1 nestedBuildMap 0.6)

testNestedBuildMap10 :: Assertion
testNestedBuildMap10 =
  assertEqualUpToEpsilon 1e-8
    [109.62086996459126,106.70290239773645,103.05843225947055,98.11825678264942,67.8014491889543,22.67321290758882,-163.40832575807545,376.4240286600336,-1996.9068313949347,249.28292226561257, 109.62086996459126,106.70290239773645,103.05843225947055,98.11825678264942,67.8014491889543,22.67321290758882,-163.40832575807545,376.4240286600336,-1996.9068313949347,249.28292226561257, 109.62086996459126,106.70290239773645,103.05843225947055,98.11825678264942,67.8014491889543,22.67321290758882,-163.40832575807545,376.4240286600336,-1996.9068313949347,249.28292226561257]
    (map (crev @Double @1 nestedBuildMap)
         (map (Flip . OR.scalar) $ [0.1, 0.2 .. 1] ++ [0.1, 0.2 .. 1] ++ [0.1, 0.2 .. 1]))

testNestedBuildMap11 :: Assertion
testNestedBuildMap11 =
  assertEqualUpToEpsilon 1e-8
    [109.62086996459126,106.70290239773645,103.05843225947055,98.11825678264942,67.8014491889543,22.67321290758882,-163.40832575807545,376.4240286600336,-1996.9068313949347,249.28292226561257, 109.62086996459126,106.70290239773645,103.05843225947055,98.11825678264942,67.8014491889543,22.67321290758882,-163.40832575807545,376.4240286600336,-1996.9068313949347,249.28292226561257, 109.62086996459126,106.70290239773645,103.05843225947055,98.11825678264942,67.8014491889543,22.67321290758882,-163.40832575807545,376.4240286600336,-1996.9068313949347,249.28292226561257]
    (map (rev @Double @1 @(Flip OR.Array) nestedBuildMap)
         (map (Flip . OR.scalar) $ [0.1, 0.2 .. 1] ++ [0.1, 0.2 .. 1] ++ [0.1, 0.2 .. 1]))

testNestedBuildMap7 :: Assertion
testNestedBuildMap7 =
  assertEqualUpToEpsilonShort 1e-8
    2176.628439128524
    (rev' @Double @7 nestedBuildMap 0.6)

-- The n <= 4 is necessary despite what GHC claims. Applying @(2 + n)
-- to nestedBuildMap doesn't help.
nestedSumBuild
  :: forall ranked n r. (ADReady ranked r, n <= 4, KnownNat n, Differentiable r)
  => ranked r n -> ranked r (2 + n)
nestedSumBuild v =
  tbuild1 13 $ \ix1 -> tbuild1 4 $ \ix2 ->
    ifF (ix2 >. ix1)
        (tmap0N ((* (-0.00000003)) . sqrt . abs)
         $ nestedBuildMap (tsum0 v)
           `tindex` (ix2 `rem` 3 :. minF 1 ix1 :. minF ix1 3 :. ZI))
        (nestedBuildMap 0.00042
         `tindex` (ix2 `rem` 3 :. minF 1 ix1 :. minF ix1 3 :. ZI))

testNestedSumBuild1 :: Assertion
testNestedSumBuild1 =
  assertEqualUpToEpsilonShort 1e-6
    (OR.fromList [5] [5.738943380972744e-6,5.738943380972744e-6,5.738943380972744e-6,5.738943380972744e-6,5.738943380972744e-6])
    (rev' @Double @3 nestedSumBuild (Flip $ OR.fromList [5] [1.1, 2.2, 3.3, 4, -5.22]))

testNestedSumBuild5 :: Assertion
testNestedSumBuild5 =
  assertEqualUpToEpsilonShort 1e-6
    (OR.fromList [1,2,2] [3.5330436757054903e-3,3.5330436757054903e-3,3.5330436757054903e-3,3.5330436757054903e-3])
    (rev' @Double @5 nestedSumBuild (tsum $ tsum t16))

nestedSumBuildB :: forall ranked n r. (ADReady ranked r, KnownNat n)
                => ranked r (1 + n) -> ranked r 3
nestedSumBuildB v =
  tbuild @ranked @r @2 [13, 4, 2] $ \case
    [ix, ix2] ->
      flip tindex [ix2]
        (tfromList
             [ tbuild1 2 tfromIndex0
             , tsum $ tbuild [9, 2] $ const $ tfromIndex0 ix
             , tindex v (listToIndex @n
                         $ replicate (trank v - 1)
                             (maxF 0 $ minF 1 $ ix2 `quot` 2 + ix `quot` 4 - 1))
             , tbuild1 2 (\_ -> tsum0 v)
             , tsum (tbuild1 7 (\ix7 ->
                 treplicate 2 (tfromIndex0 ix7)))
             ])
    _ -> error "nestedSumBuildB: impossible pattern needlessly required"

testNestedSumBuildB :: Assertion
testNestedSumBuildB =
  assertEqualUpToEpsilon' 1e-8
    (OR.fromList [2,3,2,2,2] [30.0,30.0,26.0,26.0,26.0,26.0,26.0,26.0,26.0,26.0,26.0,26.0,26.0,26.0,26.0,26.0,26.0,26.0,26.0,26.0,26.0,26.0,26.0,26.0,26.0,26.0,26.0,26.0,26.0,26.0,26.0,26.0,26.0,26.0,26.0,26.0,26.0,26.0,35.0,35.0,26.0,26.0,26.0,26.0,26.0,26.0,26.0,26.0])
    (rev' @Double @3 nestedSumBuildB (tsum $ tsum $ ttranspose [1, 4, 2, 0, 3] t48))

nestedBuildIndex :: forall ranked r. ADReady ranked r => ranked r 5 -> ranked r 3
nestedBuildIndex v =
  tbuild1 2 $ \ix2 -> tindex (tbuild1 3 $ \ix3 -> tindex (tbuild1 3 $ \ix4 -> tindex v (ix4 `rem` 2:. ix2 :. 0 :. ZI)) [ix3]) (ix2 :. ZI)

testNestedBuildIndex :: Assertion
testNestedBuildIndex =
  assertEqualUpToEpsilon' 1e-10
    (OR.fromList [2,2,1,2,2] [1.0,1.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,1.0,1.0])
    (rev' @Double @3 nestedBuildIndex t16)

barRelu
  :: ( ADReady ranked r, KnownNat n, Differentiable r )
  => ranked r n -> ranked r n
barRelu x = let t = treplicate0N (tshape x) 0.001 * x
            in relu $ bar (t, relu t)

testBarReluADValDt :: Assertion
testBarReluADValDt =
  assertEqualUpToEpsilon1 1e-6
    (OR.fromList [2,2,1,2,2] [1.2916050471365906e-2,1.2469757606504572e-2,1.3064120086501589e-2,1.2320300700062944e-2,0.0,1.217049789428711e-2,1.2185494267265312e-2,0.0,1.4105363649830907e-2,1.3506236503127638e-2,1.3359213691150671e-2,0.0,1.7066665416485535e-2,1.2618022646204737e-2,0.0,1.595161947206668e-2])
    (revDt @Double @5 barRelu t16 (Flip $ OR.constant [ 2 , 2 , 1 , 2 , 2 ] 42.2))

testBarReluADVal :: Assertion
testBarReluADVal =
  assertEqualUpToEpsilon' 1e-10
    (OR.fromList [3,1,2,2,1,2,2] [3.513740871835189e-4,3.8830416352632824e-4,3.981974371104471e-4,4.2420226755643853e-4,4.6186212581292275e-4,4.6805323209889415e-4,5.933633926875981e-4,4.8311739820100107e-4,3.513740871835189e-4,3.8830416352632824e-4,3.981974371104471e-4,4.2420226755643853e-4,4.803836032226148e-4,4.7114455958615145e-4,5.933633926875981e-4,4.6464270870595213e-4,3.060675467148428e-4,2.954918864100193e-4,3.095763053673437e-4,2.9195025355591045e-4,0.0,2.9166656928452994e-4,2.887557883241243e-4,0.0,3.342503234557057e-4,3.2005299770444394e-4,3.165690448140097e-4,0.0,4.0442335110155446e-4,2.990052759764126e-4,0.0,3.780004614233832e-4,2.954918864100193e-4,2.954918864100193e-4,2.954918864100193e-4,2.954918864100193e-4,0.0,0.0,0.0,0.0,3.7466025157760897e-4,0.0,0.0,0.0,3.7466025157760897e-4,3.7466025157760897e-4,3.7466025157760897e-4,3.7466025157760897e-4])
    (rev' @Double @7 barRelu t48)

testBarReluADVal3 :: Assertion
testBarReluADVal3 =
  assertEqualUpToEpsilon' 1e-10
    (OR.fromList [3,1,2,2,1,2,2] [2.8846476339094805e-4,2.885038541771792e-4,2.885145151321922e-4,2.8854294397024206e-4,2.885852309100301e-4,2.885923176600045e-4,2.887454843457817e-4,2.886097295122454e-4,2.8846476339094805e-4,2.885038541771792e-4,2.885145151321922e-4,2.8854294397024206e-4,2.8860655161315664e-4,2.88595871110374e-4,2.887454843457817e-4,2.885884088500461e-4,2.884182085399516e-4,2.884075468755327e-4,2.8842176240868867e-4,2.8840399312321096e-4,0.0,2.8840370860416445e-4,2.884007943794131e-4,0.0,2.884469945274759e-4,2.8843242392031246e-4,2.884288700806792e-4,0.0,2.885212670262263e-4,2.884110805753153e-4,0.0,2.8849283778617973e-4,2.884075468755327e-4,2.884075468755327e-4,2.884075468755327e-4,2.884075468755327e-4,0.0,0.0,0.0,0.0,2.884892851579934e-4,0.0,0.0,0.0,2.884892851579934e-4,2.884892851579934e-4,2.884892851579934e-4,2.884892851579934e-4])
    (rev' @Double @7 barRelu
         (Flip $ OR.mapA (* 0.001) $ runFlip t48))

barRelu10xSlower
  :: ( ADReady ranked r, KnownNat n, Differentiable r )
  => ranked r n -> ranked r n
barRelu10xSlower x = let t = tmap0N (* 0.001) x
                     in relu $ bar (t, relu t)

testReluSimp :: Assertion
testReluSimp = do
  resetVarCounter
  let !t1 = barRelu10xSlower @(AstRanked AstPrimal)
            $ AstVar [1,2,2,1,2,2,2,2,2,1] (intToAstVarId 100000000)
  length (show t1) @?= 36578
  length (show (simplifyAst6 @Float @10 t1)) @?= 36578
  resetVarCounter
  let !t2 = barRelu @(AstRanked AstPrimal)
            $ AstVar [1,2,2,1,2,2,2,2,2,1] (intToAstVarId 100000000)
  length (show t2) @?= 34722
  length (show (simplifyAst6 @Float @10 t2)) @?= 36578

testBarReluADVal320 :: Assertion
testBarReluADVal320 =
  assertEqualUpToEpsilonShort 1e-10
    (OR.fromList [1,2,2,1,2,2,2,2,2,1] [2.885038541771792e-4,2.885145151321922e-4,2.8854294397024206e-4,2.885034988157713e-4,2.885923176600045e-4,2.887454843457817e-4,2.886097295122454e-4,2.8846476339094805e-4,2.885038541771792e-4,2.885145151321922e-4,2.8854294397024206e-4,2.8851415976532735e-4,2.885923176600045e-4,2.887454843457817e-4,2.8849246223035154e-4,2.884182085399516e-4,2.884075468755327e-4,2.8842176240868867e-4,2.8840399312321096e-4,0.0,2.887454843457817e-4,2.886097295122454e-4,2.887454843457817e-4,2.88599069218435e-4,2.887454843457817e-4,2.886097295122454e-4,2.8846476339094805e-4,2.885038541771792e-4,2.885145151321922e-4,2.8854294397024206e-4,2.885145151321922e-4,2.885145151321922e-4,2.8854294397024206e-4,2.8858878438222746e-4,2.885923176600045e-4,0.0,2.884007943794131e-4,0.0,2.884469945274759e-4,2.8843242392031246e-4,2.884288700806792e-4,0.0,2.885034988157713e-4,2.884110805753153e-4,0.0,2.8849283778617973e-4,2.884075468755327e-4,2.884075468755327e-4,2.884075468755327e-4,2.884075468755327e-4,0.0,0.0,0.0,0.0,2.884892851579934e-4,2.884892851579934e-4,2.884892851579934e-4,2.884892851579934e-4,0.0,0.0,0.0,0.0,2.884892851579934e-4,2.884892851579934e-4,2.884892851579934e-4,2.884892851579934e-4,2.8854294397024206e-4,2.884288700806792e-4,2.884395315486472e-4,0.0,2.8849246223035154e-4,2.8850276789489724e-4,0.0,2.8849212704517413e-4,2.8854294397024206e-4,2.884288700806792e-4,2.884395315486472e-4,0.0,2.8849246223035154e-4,2.8850276789489724e-4,0.0,2.8849212704517413e-4,2.8842922547482884e-4,2.885038541771792e-4,2.885145151321922e-4,2.8854294397024206e-4,2.885145151321922e-4,2.8854294397024206e-4,2.894378297730782e-4,2.885923176600045e-4,2.887454843457817e-4,2.88599069218435e-4,2.887454843457817e-4,2.887056688523444e-4,2.887454843457817e-4,2.887056688523444e-4,2.8846476339094805e-4,2.885038541771792e-4,2.885145151321922e-4,2.8854294397024206e-4,2.885145151321922e-4,2.8854294397024206e-4,2.885145151321922e-4,2.8854294397024206e-4,2.884786229769816e-4,2.885923176600045e-4,2.887454843457817e-4,2.886950092188272e-4,2.887454843457817e-4,2.884818011261814e-4,2.887454843457817e-4,2.886097295122454e-4,2.8846476339094805e-4,2.885038541771792e-4,2.885145151321922e-4,2.8854294397024206e-4,2.885145151321922e-4,2.8854294397024206e-4,2.885145151321922e-4,2.8854294397024206e-4,2.887167039107226e-4,2.885923176600045e-4,2.887454843457817e-4,2.8860262265516213e-4,2.887454843457817e-4,2.885884088500461e-4,2.887454843457817e-4,2.88599069218435e-4])
    (rev' @Double @10 barRelu10xSlower
         (Flip $ OR.mapA (* 0.001) $ runFlip t128))

braidedBuilds :: forall ranked n r. (ADReady ranked r, KnownNat n, Differentiable r)
              => ranked r (1 + n) -> ranked r 2
braidedBuilds r =
  tbuild1 3 (\ix1 ->
    tbuild1 4 (\ix2 -> tindex (tfromList
      [tfromIndex0 ix2, 7, tsum0 (tslice 1 1 r), -0.2]) (ix1 :. ZI)))

testBraidedBuilds :: Assertion
testBraidedBuilds =
  assertEqualUpToEpsilon' 1e-10
    (OR.fromList [4] [0.0,4.0,0.0,0.0])
    (rev' @Double @2 braidedBuilds (treplicate0N (4 :$ ZS) 3.4))

testBraidedBuilds1 :: Assertion
testBraidedBuilds1 =
  assertEqualUpToEpsilon' 1e-10
    (OR.fromList [2,2,1,2,2] [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,4.0,4.0,4.0,4.0,4.0,4.0,4.0,4.0])
    (rev' @Double @2 braidedBuilds t16)

recycled :: (ADReady ranked r, KnownNat n)
         => ranked r n -> ranked r 7
recycled r =
  tbuild1 2 $ \_ -> tbuild1 4 $ \_ -> tbuild1 2 $ \_ -> tbuild1 3 $ \_ ->
    nestedSumBuildB (treplicate 4 r)

testRecycled :: Assertion
testRecycled =
  assertEqualUpToEpsilon' 1e-6
    (runFlip $ treplicate0N (2 :$ ZS) 5616)
    (rev' @Double @7 recycled (treplicate0N [2] 1.0001))

testRecycled1 :: Assertion
testRecycled1 =
  assertEqualUpToEpsilon' 1e-6
    (runFlip $ tfromList0N (5 :$ 4 :$ 2 :$ ZS) [5184.0,5184.0,4992.0,4992.0,4992.0,4992.0,4992.0,4992.0,4992.0,4992.0,5424.0,5424.0,4992.0,4992.0,4992.0,4992.0,4992.0,4992.0,4992.0,4992.0,4992.0,4992.0,4992.0,4992.0,4992.0,4992.0,4992.0,4992.0,4992.0,4992.0,4992.0,4992.0,4992.0,4992.0,4992.0,4992.0,4992.0,4992.0,4992.0,4992.0])
    (rev' @Double @7 recycled (treplicate0N [5, 4, 2] 0.0002))

concatBuild :: (ADReady ranked r, KnownNat n, Differentiable r)
            => ranked r (1 + n) -> ranked r (3 + n)
concatBuild r =
  tbuild1 7 (\i ->
    tconcat [ tbuild1 5 (const r)
            , tbuild1 1 (\j -> tmap0N (* tfromIndex0 (j - i)) r)
            , tbuild1 11 (\j ->
                tmap0N (* (tfromIndex0
                  (125 * (j `rem` (abs (signum i + abs i) + 1))
                   + maxF j (i `quot` (j + 1)) * (tprimalPart . tfloor) (tsum0 r)
                   - ifF (r <=. r &&* i <. j)
                         (tprimalPart $ tminIndex (tflatten r))
                         ((tprimalPart . tfloor) $ tsum0 $ r ! ((i * j) `rem` 7 :. ZI))))) r)
            , tbuild1 13 (\_k ->
                tsum $ ttr $ treplicate (tlength r) (tslice 0 1 r)) ])

testConcatBuild0 :: Assertion
testConcatBuild0 =
  assertEqualUpToEpsilon' 1e-10
    (OR.fromList [7] [16917.0,16280.0,16280.0,16280.0,16280.0,16280.0,16280.0])
    (rev' @Double @3 concatBuild
       (Flip $ OR.fromList [7] [0.651,0.14,0.3414,-0.14,0.0014,0.0020014,0.9999]))

testConcatBuild1 :: Assertion
testConcatBuild1 =
  assertEqualUpToEpsilonShort 1e-10
    (OR.fromList [3,1,2,2,1,2,2] [403920.0,403920.0,403920.0,403920.0,403920.0,403920.0,403920.0,403920.0,403920.0,403920.0,403920.0,403920.0,403920.0,403920.0,403920.0,403920.0,403647.0,403647.0,403647.0,403647.0,403647.0,403647.0,403647.0,403647.0,403647.0,403647.0,403647.0,403647.0,403647.0,403647.0,403647.0,403647.0,403647.0,403647.0,403647.0,403647.0,403647.0,403647.0,403647.0,403647.0,403647.0,403647.0,403647.0,403647.0,403647.0,403647.0,403647.0,403647.0])
    (rev' @Double @9 concatBuild t48)

concatBuild2 :: (ADReady ranked r, KnownNat n)
             => ranked r (1 + n) -> ranked r (3 + n)
concatBuild2 r =
  tbuild1 5 (\i ->
    tbuild1 2 (\j -> tmap0N (* (tfromIndex0 (maxF j (i `quot` (j + 1))))) r))

testConcatBuild2 :: Assertion
testConcatBuild2 =
  assertEqualUpToEpsilon' 1e-10
    (OR.fromList [3] [16.0,16.0,16.0])
    (rev' @Double @3 concatBuild2 (Flip $ OR.fromList [3] [0.651,0.14,0.3414]))

testConcatBuild22 :: Assertion
testConcatBuild22 =
  assertEqualUpToEpsilon' 1e-10
    (OR.fromList [3,1,2,2,1,2,2] [16.0,16.0,16.0,16.0,16.0,16.0,16.0,16.0,16.0,16.0,16.0,16.0,16.0,16.0,16.0,16.0,16.0,16.0,16.0,16.0,16.0,16.0,16.0,16.0,16.0,16.0,16.0,16.0,16.0,16.0,16.0,16.0,16.0,16.0,16.0,16.0,16.0,16.0,16.0,16.0,16.0,16.0,16.0,16.0,16.0,16.0,16.0,16.0])
    (rev' @Double @9 concatBuild2 t48)

concatBuild3 :: ADReady ranked r
             => ranked r 1 -> ranked r 2
concatBuild3 _r =
  tbuild1 5 (\i ->
    tbuild1 2 (\j -> tfromIndex0 (maxF j (i `quot` (j + 1)))))

testConcatBuild3 :: Assertion
testConcatBuild3 =
  assertEqualUpToEpsilon' 1e-10
    (OR.fromList [0] [])
    (rev' @Double @2 concatBuild3 (Flip $ OR.fromList [0] []))

testConcatBuild3PP :: Assertion
testConcatBuild3PP = do
  resetVarCounter
  let renames = IM.empty
      t = concatBuild3 @(AstRanked AstPrimal) @Double
      (var3, ast3) = funToAstR [3] t
  "\\" ++ printAstVarName renames var3
       ++ " -> " ++ printAstSimple renames ast3
    @?= "\\dret -> tfromIntegral (tgather [5,2] (tfromList [treplicate 5 (tslice 0 2 tiota), quot (ttranspose [1,0] (treplicate 2 (tslice 0 5 tiota))) (treplicate 5 (treplicate 2 (tconst 1) + tslice 0 2 tiota))]) (\\[i5, i4] -> [ifF (i4 >=. quot i5 (1 + i4)) 0 1, i5, i4]))"
  resetVarCounter
  let (artifact6, _) = revDtFun True t
                                (Flip $ OR.fromList [3] [0.651,0.14,0.3414])
  printGradient6Simple renames artifact6
    @?= "\\dret v2 -> dmkDomains (fromList [dfromR tiota])"
  printPrimal6Simple renames artifact6
    @?= "\\v2 -> tfromIntegral (tgather [5,2] (tfromList [treplicate 5 (tconst (fromList [2] [0,1])), quot (ttranspose [1,0] (treplicate 2 (tconst (fromList [5] [0,1,2,3,4])))) (treplicate 5 (treplicate 2 (tconst 1) + tconst (fromList [2] [0,1])))]) (\\[i3, i4] -> [ifF (i4 >=. quot i3 (1 + i4)) 0 1, i3, i4]))"
  printPrimal6Simple renames (simplifyArtifact6 artifact6)
    @?= "\\v2 -> tfromIntegral (tgather [5,2] (tfromList [treplicate 5 (tconst (fromList [2] [0,1])), quot (ttranspose [1,0] (treplicate 2 (tconst (fromList [5] [0,1,2,3,4])))) (treplicate 5 (tconst (fromList [2] [0,1]) + treplicate 2 (tconst 1)))]) (\\[i3, i4] -> [ifF (i4 >=. quot i3 (1 + i4)) 0 1, i3, i4]))"
